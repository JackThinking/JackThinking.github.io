<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[每周总结6]]></title>
    <url>%2F2018%2F11%2F26%2F%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%936%2F</url>
    <content type="text"><![CDATA[Array and Strings easy系列题 Remove Duplicates from Sorted Array(首先想到放到set里面；然后想到自己写的需要判断是否重复，重复了几个；后面想到由于是有序的，判断发生了几次前后不同即可-&gt;解决) Best Time to Buy and Sell Stock II(首先想到了贪心的方法，即累加所有差值-&gt;解决) Rotate Array(首先想到循环K次，每次循环一个，把尾巴暂存，其他书集体后移一位；答案的方法用了三次数组逆排序，数组逆排序的代码要会背-&gt;解决) Contains Duplicate(首先想到排序后判断前后是否相同，但是这就没啥意义了；然后想到用map或者set的性质，不过这也是偷懒；看到一种解决方法是用桶，求出最大最小值后建立桶数组，然后再遍历数组，要是重复了，桶的false会变成true，虽然时间控制在常数内，但是空间复杂度太高-&gt;解决) Single Number(首先想到了上一题，只是个不同的问法；但是考虑到只有一个出现了1次，其他都是两次，感觉会有简单方法；问题是那句不用任何的额外空间，我想不到什么点子；答案的一个方法非常有意思，由于无法用额外的空间，所以让数组前后不断的异或，由于出现两次的数异或之后会被消除，所以只剩下了那个出现了一次的数-&gt;解决) Intersection of Two Arrays II(取两个数组的交集，无序的版本自己没有任何想法；参考答案的解法是先把数组进行排序，然后用两个指针while循环进行比较-&gt;解决；另外一种答案的解法是用hashmap存储比较，感觉不舒服的解法) Plus One(关于进位的基本题；考验进位标志位和边界9的处理；虽然基本但是值得注意) Move Zeroes(把0移到最后，同时保持非0部分有序；想到的第一种自然的解法是，遇到0暂存，后面全部前移一位，0放到最后；偷懒一点先排序，然后把0移到最后；答案的方法是建立一个新的索引，不等于0的时候才向前进，然后直接在原数组上覆盖，由于原数组有0的存在，指针移动位置总是大于等于新的索引指针的-&gt;解决) Two Sum(老朋友了；首先想到的就是hashmap存储，存数找target-nums[i]-&gt;解决) Valid Sudoku(9*9数独，行列9宫格都不能重复；自己一开始想到这题要干嘛；答案其实就是两个for循环内，用除法取余等方式一起把三个判断调节一起解决了，基本的数据类型是set-&gt;解决) Rotate Image(旋转矩阵，看上去挺可怕的；首先想到的是按行变列，但是题目要求in-order，不能新增一个矩阵来操作；然后我想到swap()函数，但是没有多想；答案的解决方法也是建立在swap之上的，先将对角线进行互换，然后将每一行进行reverse，可见swap,reverse这些都是基本的数组字符串操作) Reverse String(反转数组真的是好基本啊；由于string的不可变性质，所以得先换成char数组，改完后强行改回来-&gt;解决) Reverse Integer(首先想到的是需要考虑负数和0的特殊情况；答案用除法和取余的方式巧妙的解决了，但还是要注意int的上下限问题-&gt;解决) First Unique Character in a String(返回第一个非重复字符的index，首先想到了数组里面XOR的骚操作；然后想到了用map来记录出现的次数，然后遍历map找到第一个值为1的键即可；答案的方式思想和map一样，只不过实现更加的高效，使用char[26]的小型字典来统计出现次数然后遍历找到值为1的，其时间复杂度为O(n) Valid Anagram(首先想到的利用上一题的小型字典，第一次加，第二次减，第三次找0) Valid Palindrome(判断字符串对称，首先想到去掉干扰因素比如空格和标点符号，然后首尾指针移动判断，同时考虑奇偶数;实际解决思想一样，不过是用半个fori循环，直接比较首尾，还剩去了奇偶数的考虑-&gt;解决) String to Integer (atoi)(TODO) Implement strStr()(字符串匹配，相当的经典了；TODO；再多考虑一下当needle为空的时候如何) Count and Say(首先会让人觉得有点难，然后想一下就是判断最大连续字符个数同时还要指出是哪一个字符的问题；TODO) Longest Common Prefix(最长公共序列，又是一道经典题；TODO)Array and Strings middle系列题3Sum12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2; i++) &#123; if (i == 0 || (i &gt;= 1 &amp;&amp; nums[i] != nums[i - 1])) &#123; int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i]; while (lo &lt; hi) &#123; if (nums[lo] + nums[hi] == sum) &#123; res.add(Arrays.asList(nums[i], nums[lo], nums[hi])); while (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + 1]) &#123; lo++; &#125; while (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - 1]) &#123; hi--; &#125; lo++; hi--; &#125; else if (nums[lo] + nums[hi] &lt; sum) &#123; lo++; &#125; else &#123; hi--; &#125; &#125; &#125; &#125; return res; &#125; public static void main(String[] args) &#123; Solution solution = new Solution(); int[] nums = &#123;-1,0,1,2,-1,-4&#125;; System.out.println(solution.threeSum(nums)); &#125;&#125; 首先看到3sum，的确想到了2sum。也想到了挨个把0-nums[i]当做target套用2sum的做法，但是总是没有具体成型的思路，大概看了下答案其实就懂了，关键是先做了排序，然后之后的2sum找值就是简化版的了（双指针移动），同时在一些地方做一下剪枝就大功告成了。 Set Matrix Zeroes123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public void setZeroes(int[][] matrix) &#123; if (matrix.length == 0) &#123; return; &#125; int m = matrix.length; int n = matrix[0].length; boolean fcol = false; boolean frow = false; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (matrix[i][j] == 0) &#123; if (i == 0) frow = true; if (j == 0) fcol = true; matrix[0][j] = 0; matrix[i][0] = 0; &#125; &#125; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][0] == 0 || matrix[0][j] == 0) &#123; matrix[i][j] = 0; &#125; &#125; &#125; if (frow) &#123; for (int i = 0; i &lt; n; i++) &#123; matrix[0][i] = 0; &#125; &#125; if (fcol) &#123; for (int i = 0; i &lt; m; i++) &#123; matrix[i][0] = 0; &#125; &#125; &#125;&#125; 基本的矩阵操作到是熟练的，但是这道题为了效率还是做了不少改进的，比如我在第一次做的时候感觉需要额外的数组来记录哪些行或列需要变零，但是解法巧妙的使用了第一行和第一列作为记录，然后在第二次循环中，以此为判断进行第二次变零，同时考虑到第一行或第一列自己本身也要变零的可能性，还特意设置了标志位进行补充（这边的标志位自己做的时候搞错了）。 Group Anagrams1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; int[] dict = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103&#125;; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (String str : strs) &#123; int k = 1; for (char c : str.toCharArray()) &#123; k *= dict[c - 'a']; &#125; List&lt;String&gt; t; /* * 判断指纹是不是第一次出现以及出现的层数，用map来记录 * */ if (map.containsKey(k)) &#123; t = res.get(map.get(k));//获取层数 &#125; else &#123; t = new ArrayList&lt;&gt;();//新建新的template res.add(t);//添加进res里 map.put(k, res.size() - 1);//在map中加入指纹 &#125; t.add(str);//在确定的层数插入字符 &#125; return res; &#125;&#125; 这题思路还比较清晰的，首先是要确定字符的指纹（即字母出现过即值相同，首先想到了微型字典的想法，但是数组之间比较效率不高，后面用了素数法，其实可以再深入考虑下hash的原理），确定了指纹之后需要判断是不是第一次出现，如果不是的话需要在第几层插入该数字。这就需要用一个map来记录指纹和指纹所在的层数了，接下去的代码就好写了，这道题告诉我需要在编程钱确定好该考虑的问题和思路。 Longest Substring Without Repeating Characters1234567891011121314151617class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.length() == 0) &#123; return 0; &#125; int max = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0, j = 0; i &lt; s.length(); i++) &#123; if (map.containsKey(s.charAt(i))) &#123; j = Math.max(j, map.get(s.charAt(i)) + 1); &#125; map.put(s.charAt(i), i); max = Math.max(max, i - j + 1); &#125; return max; &#125;&#125; 虽然题目不难，但还是没有自己一口气写出来，自己本来是想用微型字典代替map来记录字符状态的，也不是不行，可以再尝试一次，map的方法的话还是好理解的，i,j两个指针进行滑动，i总是滑动，j的话遇到已经出现过的，就向后滑动。 Longest Palindromic Substring12345678910111213141516public class Solution &#123; public boolean increasingTriplet(int[] nums) &#123; int min = Integer.MAX_VALUE; int secondMin = Integer.MAX_VALUE; for (int num : nums) &#123; if (num &lt;= min) &#123; min = num; &#125; else if (num &lt;= secondMin) &#123; secondMin = num; &#125; else &#123; return true; &#125; &#125; return false; &#125;&#125; 这道题我以为是最长上升子序列的特殊情况题（当然，最长上升子序列太经典了），但是由于其指定了只要三个（往往三个就可以大大简化问题，想起之前那个0，1，2的移位排序了嘛），所以换种角度想，只要找到一个数比两个数大就行了，原理就是不断的维护已遍历的最小值和第二小值，然后找到一个数比他们大即可。 Array and Strings hard系列题（不做了，反正到时候也不一定做出来）Product of Array Except SelfSpiral Matrix4Sum IIContainer With Most WaterGame of LifeFirst Missing PositiveLongest Consecutive SequenceFind the Duplicate NumberLongest Substring with At Most K Distinct CharactersBasic Calculator IISliding Window MaximumMinimum Window Substring]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Array and Strings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周总结5]]></title>
    <url>%2F2018%2F11%2F26%2F%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%935%2F</url>
    <content type="text"><![CDATA[Sorting and Searching easy系列题 Merge Sorted Array(这个问题只真是火，链表里面有，归并排序里有，这边也有，不过这次的版本是不需要另建数据的版本，也算是有一点不一样，考虑的东西还是4个判断，只不顾过这道题的方法有个简单的技巧，值得留意) First Bad Version(找到true和false的临界点，算是有序的一种表现，最容易想到的是二分搜索的方法)Sorting and Searching middle系列题Sort Colors12345678910111213141516171819class Solution &#123; public void sortColors(int[] nums) &#123; int n = nums.length; int p1 = 0, p2 = n - 1, index = 0; while (index &lt;= p2) &#123;//这边写错了 if (nums[index] == 0) &#123; nums[index] = nums[p1];//这边也写错了 nums[p1] = 0; p1++; &#125; else if (nums[index] == 2) &#123; nums[index] = nums[p2]; nums[p2] = 2; p2--; index--;//这个地方没有考虑到， &#125; index++; &#125; &#125;&#125; 三种颜色的分类，想到的是三向切分的思想，设立中间元素，遍历的时候把小于他的都换到前面，大于他的都换到后面，等于自己的时候按兵不动。但是需要细细考虑，遍历的index与大小部分索引i,j的关系。尤其是循环截止条件和把大数交换后要对这个大数重新判断。（返回去看一下三向切分的具体实现） Top K Frequent Elements1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) &#123; map.put(num, map.getOrDefault(num, 0) + 1); &#125; List&lt;Integer&gt;[] bucket = new List[nums.length + 1]; /* * 按照值的大小进行排序，不熟练啊卧槽，这个和桶排序是什么关系呀 * */ for (int key : map.keySet()) &#123; int freq = map.get(key); if (bucket[freq] == null) &#123; bucket[freq] = new ArrayList&lt;&gt;(); &#125; bucket[freq].add(key); &#125; /* * 按照值的大小进行弹出 * */ List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = nums.length; i &gt; 0 &amp;&amp; res.size() &lt; k; i--) &#123; if (bucket[i] != null) &#123; res.addAll(bucket[i]); &#125; &#125; return res; &#125;&#125; 问题是问出现频率最K高的数字，那首先我得统计频率，这个是跑不掉了，然后因为这道题只需要前K高的数字，所以我首先想到的是优先级队列，因为优先级队列对求最大值有着不错的效率，之后我又想到优先级队列的存在的对象得是一个键值对，因为我需要根据值（频率的大小）找到相应的键输出。但是我的算法效率并不是很高，所以之后去看了高效答案，他用的是一个桶排序，每个桶是一个ArrayList（有可能几个元素出现的频率是一样的），由于桶的数组是直接按照最坏情况考虑的，所以存在着一定的冗余，但好处是可以提供有序性，最后一次按照桶的逆序和要求k的大小，将相应的值填入到res中就可以得到答案。 Kth Largest Element in an Array1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int n = nums.length; quickSort(nums,0,n-1,n-k); return nums[n-k]; &#125; private void quickSort(int[] nums, int start, int end, int target)&#123; if (start&gt;=end)&#123; return; &#125; int mid = start + (end - start)/2; int pivot = choosePivot(nums[mid], nums[start], nums[end]); int i = start; int j = end; while(i&lt;=j) &#123; while (nums[i] &lt; pivot) &#123; i++; &#125; while (nums[j] &gt; pivot) &#123; j--; &#125; if (i &lt;= j) &#123; if (nums[i] != nums[j]) &#123; swap(nums, i, j); &#125; i++; j--; &#125; &#125; if(target &lt;= i - 1)&#123; quickSort(nums, start, i - 1, target); &#125; else&#123; quickSort(nums, i, end, target); &#125; &#125; private int choosePivot(int a, int b, int c) &#123; if(a &gt; b)&#123; if(c &gt; a)&#123; return a; &#125; else if(c &gt; b)&#123; return c; &#125; else&#123; return b; &#125; &#125; else&#123; if(c &gt; b)&#123; return b; &#125; else if(c &gt; a)&#123; return c; &#125; else&#123; return a; &#125; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 由于找指定大小的数字，其实就和排序差不多了，想到排序一般就快排和归并排序，快排的话还有些改进的算法（三向，去中位数哨兵等），归并的话也有些改进的算法（不用交换而是整体后移or不建立新的数组还是改用其他的）。这边我用是中位数改进快排。 Find Peak Element看到这题，第一个想法自然是要找的数需要进行前后比较，但是最后的答案让我有点懵逼12345678910111213141516class Solution &#123; public int findPeakElement(int[] nums) &#123; int n = nums.length; int left = 0, right = n-1; while(left&lt;right)&#123; int mid = left + (right-left)/2; if (nums[mid]&lt;nums[mid+1])&#123; left = mid +1; &#125; else&#123; right = mid; &#125; &#125; return left; &#125;&#125; 这道题最后的解法利用了二分搜索，但是改动了条件找到了区间峰值。TODO Search for a Range(TODO)这道题是在给定有序的情况下找到目标值的范围，找到其中一个值的想法倒是容易，用二分总是能找到，问题是找到一个后需要进行前后遍历，找到边界值 Merge Intervals(TODO)区间合并，要把重叠的子数组合并成长数组 Search in Rotated Sorted Array123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length-1; while(left&lt;=right)&#123; int mid = left+(right-left)/2; /* * 找到了就返回坐标 * */ if (nums[mid]==target)&#123; return mid; &#125; /* * 大于左边的话，说明左边序列一定是递增的 * */ if (nums[mid]&gt;=nums[left])&#123; /* * 接着判断目标值是不是在递增区间之内 * */ if (target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])&#123; right = mid - 1; &#125; else&#123; left = mid + 1; &#125; &#125; else if(nums[mid]&lt;nums[right])&#123; if (target&gt;nums[mid]&amp;&amp;target&lt;=nums[right])&#123; left = mid + 1; &#125; else&#123; right = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125; 两段有序数组之间找到目标值（无重复），有序数组找值自然想到二分，但是要处理有个分界点的问题，此处需要加入额外的条件进行区分 Search a 2D Matrix II123456789101112131415161718192021class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int m = matrix.length; if (m == 0) &#123; return false; &#125; int n = matrix[0].length; int row = 0; int col = n - 1; while (row &lt; m &amp;&amp; col &gt;= 0) &#123; int num = matrix[row][col]; if (num == target) return true; if (num &gt; target) &#123; col--; &#125; else &#123; row++; &#125; &#125; return false; &#125;&#125; 这道题的第一题是行有序，列有序，且行列之间前后也有序，那其实就是套用二分的模板，这边的第二题则行列之间有序性去除，但是从右上角的角度去观察的话，其实会发现这是一颗变相的二叉树，依次按照二分的思想去找依旧能和找到。 Sorting and Searching hard系列题Wiggle Sort II(水平不够，完全没有思路)(TODO)Kth Smallest Element in a Sorted Matrix(TODO)Median of Two Sorted Arrays(TODO)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len1 = 0; int len2 = 0; if (nums1 == null &amp;&amp; nums2 == null)&#123; return 0.0; &#125; else if (nums1 == null)&#123; len2 = nums2.length; &#125; else if (nums2 == null)&#123; len1 = nums1.length; &#125; else&#123; len1 = nums1.length; len2 = nums2.length; &#125; if ((len1+len2)%2 == 0)&#123; return (double) (findKth(nums1, 0 ,len1 , nums2, 0,len2, (len1+len2)/2)+findKth(nums1, 0 ,len1 , nums2, 0,len2, (len1+len2)/2+1))/2.0; &#125; else&#123; return (double) (findKth(nums1, 0 ,len1 , nums2, 0,len2, (len1+len2)/2+1)); &#125; &#125; private int findKth(int[] nums1, int start1, int len1, int[] nums2, int start2, int len2, int k)&#123; /* * 统一为len1更小，方便处理 * */ if (len1&gt;len2)&#123; return findKth(nums2, start2, len2, nums1, start1, len1, k); &#125; /* * 循环结束条件 * */ if (len1 == 0)&#123; return nums2[start2+k-1]; &#125; /* * 额外的循环结束条件 * */ if (k==1)&#123; return Math.min(nums1[start1],nums2[start2]); &#125; /* * 最核心的一般处理过程，包含divide * */ int p1 = Math.min(len1, k/2); int p2 = k - p1; int n1 = nums1[start1+p1-1]; int n2 = nums2[start2+p2-1]; if (n1 == n2)&#123; return n1; &#125; else if (n1&lt;n2)&#123; return findKth(nums1, start1+p1 ,len1-p1 , nums2, start2,len2,k-p1); &#125; else &#123; return findKth(nums1, start1 ,len1 , nums2, start2+p2,len2-p2,k-p2); &#125; &#125;&#125; 最先想到的一种方法是先进行合并（这个是考过很多次的了），合并之后马上能找到中位数，但是这个方法时间复杂度不满足要求。实际的解法还是很复杂的，自己很难想到。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Sorting and Searching</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周总结4]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%934%2F</url>
    <content type="text"><![CDATA[ListNode-easy系列题 Delete Node in a Linked List(node.val = node.next.val; node.next = node.next.next;连接跳过即可) Remove Nth Node From End of List(要删除尾巴指定位置的节点，首先是先找到它，快慢指针的思想在于，先让两个指针起点一下，然后快指针先走N步，然后两者一起走，当快指针走到头时，慢指针所在的位置就是我们想要的位置，这么麻烦的原因也是因为listnode没有按照序号遍历的功能，只能很原始的去找) Reverse Linked List(一个指针一直指在新链接的头上，另外一个不断是去编制，注意编织的顺序，让head及时滑向下一个) Merge Two Sorted Lists(合并两个有序链表，考虑4中情况，其实就是归并排序的merge子函数，没啥，递归解决) Palindrome Linked List(思路是快慢指针进行二分，注意有快指针的话，判断条件fast!=null&amp;&amp;fast.next!=null，同时这道题也要注意奇偶数的判断，有一个额外的判断条件让slow越过那个奇数值) Linked List Cycle(还是利用了快慢指针的思想，要是存在圈，快慢指针一定会相遇导致slow==fast )ListNode-middle系列题Add Two Numbers1234567891011121314151617181920212223class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode result = new ListNode(0);//结果指针，表示答案，它不能滑动 ListNode point = result;//苦力指针，用来滑动编制 int temp = 0;//进位标志位 while(l1 != null || l2 != null || temp != 0)&#123; if (l1!=null)&#123; temp += l1.val; l1 = l1.next; &#125; if (l2!=null)&#123; temp += l2.val; l2 = l2.next; &#125; ListNode tempnode = new ListNode(temp%10);//取新节点 point.next = tempnode;//编制 point = point.next;//编制完移动 temp = temp/10;//进位标志位更新 &#125; return result.next;//去掉头部无用节点返回 &#125;&#125; 这道题第一感觉难在进位上，还有就是要考虑到两条链表不是一样长的时候的情形。对于链表的编制，往往都需要一个钉在开头的指针和一个不断编制的苦力指针（苦力指针基本上要执行node1.next=node2;node = node.next）。 Odd Even Linked List123456789101112131415class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if (head!=null)&#123; ListNode odd = head, even = head.next, evenhead = even;//奇数偶数各一个起始位，并且保留偶数起始位，用于之后的连接 while(even!=null&amp;&amp;even.next!=null)&#123;//只要while里面涉及到了node = node.next的话，就需要进行next判断，之前我是觉得fast才需要的 odd.next = odd.next.next;//奇数编制 odd = odd.next;//奇数滑动 even.next = even.next.next;//偶数编制 even = even.next;//偶数滑动 &#125; odd.next = evenhead;//两条连接进行合并 &#125; return head; &#125;&#125; 奇偶数的分开再编制，思路简单，但是这道题没有新建一个node来表示答案，而是直接用head返回，之后要考虑下什么时候需要新建node，什么时候可以返回node。 Intersection of Two Linked Lists1234567891011121314public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null)&#123; return null; &#125; ListNode pointA = headA; ListNode pointB = headB; while(pointA!=pointB)&#123; pointA = pointA == null ? headB : pointA.next; pointB = pointB == null ? headA : pointB.next; &#125; return pointA; &#125;&#125; 问题在于两条链表的长度不同的话，无法进行比较，否则只需要进行node1==node2指针比较即可，那么问题在于长度 不同，可以让链表1连上链表2；链表2连上链表1，这样长度就一样了，之后再判断就可以了。 ListNode-hard系列题Merge k Sorted Lists1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; return sortByPartition(lists, 0, lists.length-1); &#125; private ListNode sortByPartition(ListNode[] lists, int start, int end)&#123; /* * 递归先确定结束条件 * */ if (start == end)&#123; return lists[start]; &#125; /* * 经典的分治理念，切半，递归递归，合并 * */ int mid = start+(end-start)/2; ListNode left = sortByPartition(lists, start, mid); ListNode right = sortByPartition(lists, mid+1, end); return merge(left,right); &#125; private ListNode merge(ListNode left, ListNode right)&#123; /* * 同样是递归，先要确定结束条件 * */ if (left == null || right == null)&#123; return left == null ? right : left; &#125; /* * 链表合并总是要有连接的过程的，这边需要额外注意 * */ if (left.val&lt;right.val)&#123; left.next = merge(left.next,right); return left; &#125; else &#123; right.next = merge(left,right.next); return right; &#125; &#125;&#125; 这不就是归并排序嘛，之前的middle难度的merge双lists算是merge的练习的话，这个就是merge sort的链表版本，区别是归并排序merge的是等长的数组，这边merge的是一条条的链表,对于链表合并的优先性，这边取的是二分法，有点不确定这和挨个合并的区别；还有一点是排序版本的么merge需要（lo,mid（是因为要判断用尽）,hi）而listnode版本的只需要（list1，list2）。 Sort List123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode slow = head, fast = head, pre = head; /* * 这个相当于是二分啦 * */ while (fast != null &amp;&amp; fast.next != null) &#123;//有fast的存在，判断的时候需要有两个判断条件 pre = slow;//这个pre用来切数组，周末一定要把链表的 slow = slow.next; fast = fast.next.next; &#125; pre.next = null; ListNode left = sortList(head); ListNode right = sortList(slow); return merge(left, right); &#125; private ListNode merge(ListNode left, ListNode right) &#123; if (left == null) &#123; return right; &#125; if (right == null) &#123; return left; &#125; if (left.val &lt; right.val) &#123; left.next = merge(left.next, right); return left; &#125; else &#123; right.next = merge(left, right.next); return right; &#125; &#125;&#125; 归并和链表也太相配了吧，merge部分还是一样的，主要是sort部分，结合之前总结的快慢指针代替二分的方法，pre用来断开链接。 Copy List with Random Pointer`javapublic class Solution { public RandomListNode copyRandomList(RandomListNode head) { if (head == null){ return null; } Map&lt;RandomListNode,RandomListNode&gt; map = new HashMap&lt;RandomListNode,RandomListNode&gt;(); /* * 节点意义复制到map中 * */ RandomListNode point = head; while(point!=null){ map.put(point,new RandomListNode(point.label)); point = point.next; } /* * 指针重新指向开头的地方 * */ point = head; while(point!=null){ map.get(point).next = map.get(point.next); map.get(point).random = map.get(point.random); point = point.next; } return map.get(head); } }`链表的深拷贝，不是很懂他的原理，之后如果遇到了再看看吧。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周总结3]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%933%2F</url>
    <content type="text"><![CDATA[动态规划专题，总结一下dp使用的特点 DP-easy系列题 Climbing Stairs（走一步还是走二步，考虑可能性的话是不是大多是+？sol[i] = sol[i-1] + sol[i-2]） Best Time to Buy and Sell Stock（股票问题，感觉都不算dp，在遍历的中找一个最小值，用max函数维护一个num[i]-min的值，maxprofit = Math.max(maxprofit,prices[i]-min);，min = Math.min(min,prices[i])，一个max和一个min维护的dp形式） Maximum Subarray（最大子序列和，好题，考虑两点：如果新来的num[i]比之前的sum还要大，那新的sum系列直接从新的num开始，并且将之前的sum记录下来；sum = Math.max(sum+num, num);sum_array = Math.max(sum_array,sum);，两个max函数维护的dp形式，第一个是curr的sum变动，第二个是history的sum值变动） House Robber（抢劫房子，偷或者不偷，只能选一种，是不是大多是max?则考虑最近的两个情况，money[i] = Math.max(nums[i]+money[i-2],money[i-1])）DP-middle系列题 Jump Game（青蛙跳问题，感觉和easy不同的就是，这属性限制性dp，而不是发散性，限制性的dp需要最后的值符合某个要求；这道题实际做的时候使用了逆向思维，从尾巴找起，因为失败发生的情况无法是跳到了一个0的地方，然后无法继续前进，所以逆向找到0，让设置step长度为1，往回找，要是找不到一个能跨越step的num，就失败了） Unique Paths（棋盘可能性，属于+的问题，思路简单，赋予边界初始值，然后+就完事了，sum[i][j] = sum[i-1][j]+sum[i][j-1]） Coin Change（符合目标的最少硬币数，硬币，用或者不用，用的话，在之前的dp中找到减去该硬币面值的数，然+1，与不用的时候比，这里是根据硬币的可能性多次对dp进行更新，最后找到，dp[i] = Math.min(dp[i-coin]+1,dp[i])） Longest Increasing Subsequence（无序数组中最长上升散序列，维护一个尾巴最小的上升数组，新来的数如果比数组都大，那就加长数组的长度，否则就更新上升数组，有必要重新写一次）DP-hard系列题Maximum Product Subarray（TODO）12345678910111213141516171819class Solution &#123; public int maxProduct(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int n = nums.length; int[] maxdp = new int[n+1]; int[] mindp = new int[n+1]; int maxVal = Integer.MIN_VALUE; maxdp[0] = 1; mindp[0] = 1; for (int i = 1; i &lt; n+1; i++) &#123; maxdp[i] = Math.max(maxdp[i-1]*nums[i-1], Math.max(mindp[i-1]*nums[i-1], nums[i-1])); mindp[i] = Math.min(mindp[i-1]*nums[i-1], Math.min(maxdp[i-1]*nums[i-1], nums[i-1])); maxVal = Math.max(maxVal, maxdp[i]); &#125; return maxVal; &#125;&#125; 这道题，由于要考虑到正负数的问题，故要设立两个dp数组，考虑状态转移方程，当新来了一个数，可能的情况有三种，第一这个数很大，直接替换了直接的数组；第二这个数是正数，与之前的相乘使得max更大；第三这个数是负数与之前保存的最小负数相乘一跃变成最大。考虑完之后，可以用两个dp数组，三个方程求出最大值，这道题由于只涉及i和i-1的关系，还可以简化。 Decode Ways（）12345678910111213141516171819class Solution &#123; public int numDecodings(String s) &#123; int n = s.length(); int pre = 1; int now = s.charAt(n-1) == '0' ? 0 : 1; int curr = now; for (int i = n-2; i &gt;= 0; i--) &#123; if (s.charAt(i) == '0')&#123; curr = 0; &#125; else&#123; curr = Integer.parseInt(s.substring(i,i+2))&lt;27 ? pre+now:now; &#125; pre = now; now = curr; &#125; return curr; &#125;&#125; 可能性问题，转移方程一般是+，即找(i-2)+(i-1)的个数，从尾巴开始找起，以2为窗口进行搜索，遇到0则需要改变状态量重新搜索。其中pre表示i-2，now表示i-1，curr表示i，使用时不要忘记，后面需要进行更新。 Best Time to Buy and Sell Stock with Cooldown（TODO）1234567891011121314151617class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) return 0; int max = 0, n = prices.length; int cooldown = 0; int sell = 0; int diff = -prices[0]; for (int i = 1; i &lt; n; i++) &#123; int temp = cooldown; cooldown = Math.max(temp,sell); sell = Math.max(sell,prices[i] + diff); diff = Math.max(diff, temp - prices[i]); max = Math.max(Math.max(max,sell),cooldown); &#125; return max; &#125;&#125; 原来的做法实在看不懂，之后再试其他的方法，并且理解。 Perfect Squares（）123456789101112131415class Solution &#123; public int numSquares(int n) &#123; int[] res = new int[n+1]; res[0] = 0; for (int i = 1; i &lt; n+1; i++) &#123; int min = Integer.MAX_VALUE; for (int j = 1; j &lt;= Math.sqrt(i); j++) &#123; min = Math.min(res[i-j*j]+1,min); &#125; res[i] = min; &#125; return res[n]; &#125;&#125; 本质还是硬币凑数问题，思路也是一样的，先用小额度的数字去填dp数组，然后慢慢的用较大的数组去填，最小化使用数字的个数，区别就是i-j*j了，变成了减去一个平方数。 Word Break（）1234567891011121314151617181920212223class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; if (s == null || s.length() == 0) return false; int n = s.length(); boolean[] dp = new boolean[n+1]; dp[0] = true; int longestLen = 0; for (String word : wordDict) &#123; if (word.length() &gt; longestLen) &#123; longestLen = word.length(); &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= longestLen; j++) &#123; if (i&gt;=j &amp;&amp; dp[i-j]==true &amp;&amp; wordDict.contains(s.substring(i-j,i)))&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[n]; &#125;&#125; 这道题反而不是很想一道dp的题，主要还是那个判断条件，从最后一个字母倒推的话，必须有一个个的dp点为true，直到第一个数字。 Word Break II（TODO）123456789101112131415161718192021222324class Solution &#123; public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123; return dfs(s, wordDict, new HashMap&lt;Integer, List&lt;String&gt;&gt;(),0); &#125; public List&lt;String&gt; dfs(String s, List&lt;String&gt; dict, Map&lt;Integer, List&lt;String&gt;&gt; map, int start) &#123; if (map.containsKey(start)) return map.get(start);//剪枝，较少不必要的寻找 List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (start == s.length()) &#123; res.add("");//?? return res;//结束的return &#125; for (String word : dict) &#123; if (s.startsWith(word, start)) &#123; List&lt;String&gt; sublist = dfs(s, dict, map, start + word.length()); for (String n : sublist) &#123; res.add(word + (n.length() == 0 ? "" : " ") + n); &#125; &#125; &#125; map.put(start, res); return res;//寻找过程的return &#125;&#125; 不是很能理解，放到之后去去看吧。 Burst Balloons（）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周总结2]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%932%2F</url>
    <content type="text"><![CDATA[昨天做了到利用HashMap的Sum类型题，感觉其思路挺有意思的，联想到LeetCode第一题Two Sum的高效解法也是用的HashMap，所以在此归纳总结下这类题目的深层次理解。 Two sum(1)——（无序数组）123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] index = new int[]&#123;0, 1&#125;; HashMap&lt;Integer, Integer&gt; hm = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (hm.containsKey(target - nums[i])) &#123; index[1] = i; index[0] = hm.get(target - nums[i]); &#125; else &#123; hm.put(nums[i], i); &#125; &#125; return index; &#125;&#125; 一开始我的想法是很粗暴的，就是想每两个值加起来和target比较一下，但是实际上这效率太低，实际使用可以在之后的数数组中找是否有target-i的数，没有的话用一个map记录每个值和其序号，便于后面的寻找。 Two Sum II(167)——（排序数组）1234567891011121314class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int l = 0; int r = numbers.length - 1; while (numbers[l] + numbers[r] != target) &#123; if (numbers[l] + numbers[r] &gt; target) &#123; r--; &#125; else &#123; l++; &#125; &#125; return new int[]&#123;l + 1, r + 1&#125;; &#125;&#125; 利用其有序性，设立两个标志从左右加，将其和与target比较即可。 Two Sum IV(653)——（TODO）12345678910111213141516171819202122232425262728class Solution &#123; public boolean findTarget(TreeNode root, int k) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); inorder(root, list); int l = 0; int r = list.size() - 1; while (l &lt; r) &#123; int sum = list.get(l) + list.get(r); if (sum == k) &#123; return true; &#125; else if (sum &gt; k) &#123; r--; &#125; else &#123; l++; &#125; &#125; return false; &#125; private void inorder(TreeNode root, List&lt;Integer&gt; list) &#123; if (root == null) &#123; return; &#125; inorder(root.left, list); list.add(root.val); inorder(root.right, list); &#125;&#125; BST的中序遍历是有序的，问题就简化为上一小题了，但是这种方法并不高效，之后可以改进。 Subarray Sum Equals K(560)12345678910111213141516class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int count = 0; int sum = 0; Map&lt;Integer,Integer&gt; hashmap = new HashMap&lt;&gt;(); hashmap.put(0,1); for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (hashmap.containsKey(sum-k))&#123; count+= hashmap.get(sum-k); &#125; hashmap.put(sum, hashmap.getOrDefault(sum,0)+1); &#125; return count; &#125;&#125; 这道题提供了一个新思路，如果我想遍历长度的5的各种可能性，我改怎么办？比如我想试试1,2,3,4,5；{1,2}{2,3}{3,4}等等直到{1,2,3,4,5}；这道题的告诉我们可以用sum[j]-sum[i]的方式，并将其值存在map里面，map的存的是sum[i]即按序累加的值，当sum[j]-sum[i]的时候，就可以出现各种子情况了。 Combination Sum(39)——（DEBUG）123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); helper(new ArrayList&lt;Integer&gt;(),candidates,0,target);//new出来的不要具体说明的嘛? return res; &#125; private void helper(List&lt;Integer&gt; list, int[] candidates, int start, int remain)&#123; if (remain == 0)&#123; res.add(new ArrayList&lt;&gt;(list));//为什么不直接add list呢？ return; &#125; else&#123; for (int i = start; i &lt; candidates.length; i++) &#123; if (remain&lt;candidates[i])&#123; continue; &#125; list.add(candidates[i]); helper(list,candidates,i,remain-candidates[i]); list.remove(list.size()-1); &#125; &#125; &#125;&#125; 这道题利用了dfs的思路，而且同样使用了sum题基本思路，把本来加起来的sum变成remain(target-nums[i])，这样在不断的dfs的时候，remain的值不断变化。这道题还要注意到的是数据可以重复利用，所以其start的值不需要每层加1；最后要注意的是dfs到底部发现不满足的话要把最靠近底部的值给弹出去；add(list)的时候要用new出来的，负责list的内容会是最终状态，这个之后debug再理解。 Path Sum(112)12345678910111213141516class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; return helper(root, sum, 0); &#125; private boolean helper(TreeNode root, int sum, int temp) &#123; if (root == null) &#123; return false; &#125; temp += root.val; if (root.left == null &amp;&amp; root.right == null &amp;&amp; temp == sum) &#123; return true; &#125; return helper(root.left, sum, temp) || helper(root.right, sum, temp); &#125;&#125; PathSum的第一题简单，都是老套路，dfs的时候把remain或者sum值放在函数里面传递。 Path Sum II(113)1234567891011121314151617181920212223242526class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); helper(root, sum, 0, temp); return res; &#125; private void helper(TreeNode root, int sum, int num, List&lt;Integer&gt; temp) &#123; if (root == null) &#123; return; &#125; temp.add(root.val); num += root.val; if (root.left == null &amp;&amp; root.right == null &amp;&amp; num == sum) &#123; res.add(new ArrayList&lt;Integer&gt;(temp)); temp.remove(temp.size()-1); return; &#125;else&#123; helper(root.left, sum, num, temp); helper(root.right, sum, num, temp); &#125; temp.remove(temp.size()-1); &#125;&#125; 这道题融合了PathSum的性质和CombinationSum的要求，就是把数组找出来，这样我们需要在dfs函数上加一个temp的list来记录当前遍历的数组内容，再设一个全局list变量来作为return的ans，其他思路照旧。 Path Sum III(437)——（DEBUG）123456789101112131415161718192021222324252627class Solution &#123; int res = 0; Map&lt;Integer, Integer&gt; map; public int pathSum(TreeNode root, int sum) &#123; if (root == null) &#123; return 0; &#125; map = new HashMap&lt;&gt;(); map.put(0, 1); helper(root, sum, 0); return res; &#125; private void helper(TreeNode root, int sum, int tempSum) &#123; if (root == null) &#123; return; &#125; tempSum += root.val; res += map.getOrDefault(tempSum - sum, 0);//?????? map.put(tempSum, map.getOrDefault(tempSum, 0) + 1); helper(root.left, sum, tempSum); helper(root.right, sum, tempSum); map.put(tempSum, map.get(tempSum) - 1);//????????? &#125;&#125; 之前两道pathsum都是说好从根节点到子节点的，这到题就没说了，这样按照之前的思路，我们需要一个map来记录；最后照旧，需要在dfs后把尾部弹出，不过这里还不是很理解，要再看看。 Target Sum(494)——（TODO）12345678910111213141516171819class Solution &#123; int count = 0; public int findTargetSumWays(int[] nums, int S) &#123; helper(nums, 1, S - nums[0]); helper(nums, 1, S + nums[0]); return count; &#125; private void helper(int[] nums, int index, int target) &#123; if (index == nums.length) &#123; if (target == 0) &#123; count++; &#125; return; &#125; helper(nums, index + 1, target - nums[index]); helper(nums, index + 1, target + nums[index]); &#125;&#125; 两种dfs中的方式，一种是存sum的累加值，一种是放taregt-nums[i]的值，两种方式的详细区别之后在看看。明天改成sum的形式。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Two Sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周总结1]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%931%2F</url>
    <content type="text"><![CDATA[之前的每日算法更新结束，文章多了后，hexo编译好慢，而且每天写的话有点浪费时间，算法题还是每天在做，之后改成总结更新类的方式。 TreeNode-easy系列题 Maximum Depth of Binary Tree（树的深度） Validate Binary Search Tree（二叉搜索树的判定） Symmetric Tree（对称树-学到了helper的双遍历） Binary Tree Level Order Traversal（根据树的深度来找同一层的点，helper函数需要加入level属性） Convert Sorted Array to Binary Search Tree（有序数组变成二叉搜索树-中序遍历的特点-需要在helper函数里面不断的找中点，然后左右递归，边界条件要注意） TreeNode-middle系列题 Binary Tree Inorder Traversal（树的中序遍历） Binary Tree Zigzag Level Order Traversal（Z形level遍历，在原有easy的基础上对add函数做一下小处理，在末端加入，有点trick的感觉） Construct Binary Tree from Preorder and Inorder Traversal（根据先序中序遍历结果进行重新排列，有点难度，搞清楚就是先序的节点作为中序数组的分界点） Populating Next Right Pointers in Each Node（给树增加右向指针，可以好好理解BFS和DFS的区别） Kth Smallest Element in a BST（根据二叉搜索树的特点统计每个节点左右两边的节点个数，依据个数来找出index的node） Number of I slands（可以说是比较经典的二维图遍历了，用dfs的思路进行遍历，找到后变0，这样之后再遇到就不会对下一个图产生误导了） TreeNode-hard系列题 Word Ladder（很难，从首到尾BFS将相差1个字的单词从原有数组去掉，加入到该level的数组中） Surrounded Regions（二维数组，去掉被包围的点，这道题是逆向思维，从4条边缘进行dfs,将遇到的点给值，然后再遍历的时候，如果没有被给值就直接变成X） Lowest Common Ancestor of a Binary Tree（这道题还是要在看一下YouTube视频理解一下，是一道经典题） Binary Tree Maximum Path Sum（二叉树上的最大路径，基于DFS，需要识别负数，return的时候有点技巧） Friend Circles（朋友圈，也是用dfs，不过要理解visited的含义） Course Schedule（拓扑搜索，用一个set和dp的数组来解决） Course Schedule II（用一个stack和一个set可以解决） Longest Increasing Path in a Matrix（二维数据的找最大上升序列，需要一个visited数组作数据记录） Alien Dictionary Count of Smaller Numbers After Self（其实这道题换个角度理解就是一个个进行二分插入，统计插入位置的index，进index进行记录）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Treenode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷68]]></title>
    <url>%2F2018%2F09%2F25%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B768%2F</url>
    <content type="text"><![CDATA[简单的5到tree综合总结（104、98、101、102、108）代码就不贴了，暂时就说说感想： tree的题基本都是可以用递归做的，可以用来巩固递归的知识 tree的遍历基本知识：先中后序遍历，层次遍历及递归与非递归实现 tree的树高，对称判断，建树等基本操作的递归实现]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Treenode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷67]]></title>
    <url>%2F2018%2F09%2F09%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B767%2F</url>
    <content type="text"><![CDATA[241. Different Ways to Add Parenthesesiven a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.Example 1:12345Input: "2-1-1"Output: [0, 2]Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2:12345678Input: "2*3-4*5"Output: [-34, -14, -10, -10, 10]Explanation: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123; public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); List&lt;String&gt; operaters = new ArrayList&lt;&gt;(); split(input,nums,operaters);//以后有想法就先把函数写出来再说 return calculate(nums, operaters, 0, nums.size()-1); &#125; private void split(String input, List&lt;Integer&gt; nums, List&lt;String&gt; operaters)&#123; StringBuilder sb = new StringBuilder();//不需要预先设置长度 for (int i = 0; i &lt; input.length(); i++) &#123; char character = input.charAt(i);//charAt充当遍历器 if (character == '+' || character == '-' || character == '*')&#123; nums.add(Integer.valueOf(sb.toString()));//是错位的加法 sb = new StringBuilder(); operaters.add(character+"");//只是为了char 2 string,一定要是双引号 &#125; else &#123; sb.append(character);//这么感觉有点蠢，之后再看看 &#125; &#125; nums.add(Integer.valueOf(sb.toString())); &#125; private List&lt;Integer&gt; calculate(List&lt;Integer&gt; nums, List&lt;String&gt; operaters, int start, int end)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;();//这个是要返回的结果呀 /* * 写结束条件 * */ if (start == end)&#123; res.add(nums.get(start)); return res; &#125; /* * 一般处理情况 * */ for (int i = start; i &lt; end; i++) &#123; List&lt;Integer&gt; left = calculate(nums, operaters, start, i); List&lt;Integer&gt; right = calculate(nums, operaters, i+1, end); mergelist(left, right, res, operaters.get(i)); &#125; return res; &#125; private void mergelist(List&lt;Integer&gt; left, List&lt;Integer&gt; right, List&lt;Integer&gt; res, String operator)&#123; for (int i = 0; i &lt; left.size(); i++) &#123; for (int j = 0; j &lt; right.size(); j++) &#123; int num = operate(left.get(i), right.get(j), operator); res.add(num); &#125; &#125; &#125; private int operate(int i, int j, String operator)&#123; switch (operator)&#123; case "+": return i+j; case "-": return i-j; case "*": return i*j; &#125; return 0; &#125;&#125; 数字符合种类合集 分治的思想 程序较为复杂，自己还hold不住 对于string字符串中数据的提取很不熟练 对于switch基本函数的运用 对于stringbuilder的运用 递归的基本思想实践能力不行 程序的逻辑性分析大体倒是对了 最近事情多，不能静下心来思考很伤]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷66]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B766%2F</url>
    <content type="text"><![CDATA[138. Copy List with Random PointerA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list with a random pointer. * class RandomListNode &#123; * int label; * RandomListNode next, random; * RandomListNode(int x) &#123; this.label = x; &#125; * &#125;; */public class Solution &#123; public RandomListNode copyRandomList(RandomListNode head) &#123; if (head == null)&#123; return null; &#125; Map&lt;RandomListNode,RandomListNode&gt; map = new HashMap&lt;RandomListNode,RandomListNode&gt;(); /* * 节点意义复制到map中 * */ RandomListNode point = head; while(point!=null)&#123; map.put(point,new RandomListNode(point.label)); point = point.next; &#125; /* * 指针重新指向开头的地方 * */ point = head; while(point!=null)&#123; map.get(point).next = map.get(point.next); map.get(point).random = map.get(point.random); point = point.next; &#125; return map.get(head); &#125;&#125; 带随机指针链表的深拷贝: 做的不明所以 步骤能能够理解，但是效率不高，之后可以再改进 最近一周实在是效率低下，装机也要适可而止，不能影响到日常生活]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷65]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B765%2F</url>
    <content type="text"><![CDATA[23. Merge k Sorted ListsMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example:1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; return sortByPartition(lists, 0, lists.length-1); &#125; private ListNode sortByPartition(ListNode[] lists, int start, int end)&#123; /* * 递归先确定结束条件 * */ if (start == end)&#123; return lists[start]; &#125; /* * 经典的分治理念，切半，递归递归，合并 * */ int mid = start+(end-start)/2; ListNode left = sortByPartition(lists, start, mid); ListNode right = sortByPartition(lists, mid+1, end); return merge(left,right); &#125; private ListNode merge(ListNode left, ListNode right)&#123; /* * 同样是递归，先要确定结束条件 * */ if (left == null || right == null)&#123; return left == null ? right : left; &#125; /* * 链表合并总是要有连接的过程的，这边需要额外注意 * */ if (left.val&lt;right.val)&#123; left.next = merge(left.next,right); return left; &#125; else &#123; right.next = merge(left,right.next); return right; &#125; &#125;&#125; 非常经典非常好的题-多链表按序合并 可以使用优先级队列（但是这样使用了内建函数） 最后参考的方法是分治，其有着有一定的规律，比如先中分，俩边递归，然后合并 链表合并的递归函数还是蛮经典的，之后要会默写]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷64]]></title>
    <url>%2F2018%2F08%2F31%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B764%2F</url>
    <content type="text"><![CDATA[148. Sort ListSort a linked list in O(n log n) time using constant space complexity. Example 1:12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 Example 2:12Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Solution &#123; /* * 链表合并的递归方式，妙的很，理解上需要从最后一步反推，链表的连接像是倒着连一样 * */ public ListNode merge(ListNode h1, ListNode h2) &#123; if (h1 == null)&#123; return h2; &#125; if (h2 == null)&#123; return h1; &#125; if (h1.val&lt;h2.val)&#123; h1.next = merge(h1.next,h2); return h1; &#125; else&#123; h2.next = merge(h1,h2.next); return h2; &#125; &#125; /* * 同样是递归，原理是归并排序的原理，先分开排序再进行合并，具体原理再多理解一下 * */ public ListNode sortList(ListNode head) &#123; /* * 归并的第一步：确定最后的返回条件 * */ if (head == null)&#123; return head; &#125; if (head.next == null)&#123; return head; &#125; /* * 快慢指针达到二分的效果 * */ ListNode slow = head, fast = head, pre = head;//pre存储slow指针的上一个节点，用于分割 /* * 由于有快指针，循环条件要以快的那个为准，而且要有两种情况，以防跳到null * */ while (fast != null &amp;&amp; fast.next != null)&#123; pre = slow; slow = slow.next; fast = fast.next.next; &#125; /* * x.next进行分割；不同于slow = slow.next是指针滑动 * */ pre.next = null; /* * 归并的一般推演逻辑 * */ ListNode h1 = sortList(head); ListNode h2 = sortList(slow); return merge(h1,h2); &#125; public static void main(String[] args) &#123; Solution solution = new Solution(); ListNode.print(solution.sortList(ListNode.createTestData("[2,1,3,5]"))); &#125;&#125; 链表排序题： 用到的排序原理是归并 不知道为啥不用其他排序算法 各种排序算法优劣学习]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷63]]></title>
    <url>%2F2018%2F08%2F30%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B763%2F</url>
    <content type="text"><![CDATA[61. Rotate ListGiven a linked list, rotate the list to the right by k places, where k is non-negative.Example 1:12345Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2:1234567Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL 12345678910111213141516171819202122232425class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if (head == null || k==0)&#123; return head; &#125; ListNode cur = head, pre = null; int count = 0; while(cur!=null)&#123; pre = cur; cur = cur.next; count++; &#125; pre.next = head; k %= count; int left = count-k; cur = head; while(left&gt;0)&#123; pre = cur; cur = cur.next; left--; &#125; pre.next = null; return cur; &#125;&#125; 旋转链表题： 先连成环；再走到起点；把终点断开 连成环是一种新的基本思想 如果需要使用某一位置之前的一个指针时，可以在while循环里用pre=cur来记录，然后让cur自增]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷62]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B762%2F</url>
    <content type="text"><![CDATA[160. Intersection of Two Linked ListsWrite a program to find the node at which the intersection of two singly linked lists begins.For example, the following two linked lists:12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1.Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 1234567891011121314public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null)&#123; return null; &#125; ListNode pointA = headA; ListNode pointB = headB; while(pointA!=pointB)&#123; pointA = pointA == null ? headB : pointA.next; pointB = pointB == null ? headA : pointB.next; &#125; return pointA; &#125;&#125; 找公共起始点： 核心问题是两条链路长度不一样怎么办？ 我的写法是写计数两个指针到null的值，然后让其中一个先走几步，但是显然有点蠢 答案的方法很妙，如果两者长度相同，不会超时额外操作；如果不用的话根据x+y=y+x的原理，走完自己这里的链路再走对方的链路，总长度一定一样，一定能找到]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷61]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B761%2F</url>
    <content type="text"><![CDATA[92. Reverse Linked List IIReverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example:12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 12345678910111213141516171819202122class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null)&#123; return null; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for (int i = 0; i &lt; m-1; i++) &#123; pre = pre.next; &#125; ListNode start = pre.next; ListNode then = start.next; for (int i = 0; i &lt; n-m ; i++) &#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; return dummy.next; &#125;&#125; 链表指定区间反转： 自己的方法没有顾忌到结尾的反转 对于链表指针的熟悉使用 这道题是有点绕的 x.next = y.next（链路重置） x = x.next; (指针移动，不影响原来的链路) x.next = y（建立链路链接） x = y.next（同理）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷60]]></title>
    <url>%2F2018%2F08%2F28%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B760%2F</url>
    <content type="text"><![CDATA[328. Odd Even Linked ListGiven a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1:12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL Example 2:12Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULLOutput: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on … 12345678910111213141516class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if (head!=null)&#123; ListNode odd = head, even = head.next, evenhead = even;//指针定位 while(even!=null&amp;&amp;even.next!=null)&#123; odd.next = odd.next.next;//编织链表 even.next = even.next.next; odd = odd.next;//链表向后拓展 even = even.next; &#125; odd.next = evenhead;//evenhead保存even头部位置 &#125; return head; &#125;&#125; 链表奇偶改造： 道理不难 没有必要新建链表保存数据 基本功不扎实 有.next.next形式时七while条件往往是(even!=null&amp;&amp;even.next!=null) 两个指针时，考虑奇偶情况，以位置靠后的那个为准，一般是偶数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷59]]></title>
    <url>%2F2018%2F08%2F25%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B759%2F</url>
    <content type="text"><![CDATA[445. Add Two Numbers IIYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up:What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: 12Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;(); Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;(); while(l1!=null)&#123; s1.add(l1.val); l1 = l1.next; &#125; while(l2!=null)&#123; s2.add(l2.val); l2 = l2.next; &#125; ListNode head = new ListNode(0); int temp = 0; while(! s1.empty() || !s2.empty())&#123; if (! s1.empty())&#123; temp += s1.pop(); &#125; if (! s2.empty())&#123; temp += s2.pop(); &#125; head.val = temp%10; ListNode tempnode = new ListNode(temp/10);//考虑最后一步 tempnode.next = head;//指向反转 head = tempnode;//指向反转 temp = temp/10; &#125; return head.val == 0 ? head.next:head;//同样为了考虑最后一步 &#125;&#125; 链表加法的升级版，顺序反过来了： 思路一致 不准反转 使用堆栈 由于链路指向反过来了，细节上需要注意]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷58]]></title>
    <url>%2F2018%2F08%2F25%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B758%2F</url>
    <content type="text"><![CDATA[2. Add Two NumbersYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example:123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode result = new ListNode(0);//新建链表头，当做返回值 ListNode point = result;//设立指针 int carry = 0;//进位标志位 int sum = 0;//和标志位 while(l1 != null || l2 != null || carry != 0)&#123; sum = (l1 != null?l1.val:0) + (l2 != null? l2.val : 0) + carry;//计算和 carry = sum/10;//计算进位 ListNode temp = new ListNode(sum%10);//新建临时节点，用于连接 point.next = temp;//建立连接 point = point.next;//i++ if (l1!=null)&#123; l1 = l1.next; &#125; if (l2!=null)&#123; l2 = l2.next; &#125; &#125; return result.next; &#125;&#125; 链表的加法进位题： 自己对于链表的概念是对的 具体思路见注释 还有提升空间见下 1234567891011121314151617181920212223class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode result = new ListNode(0); ListNode point = result; int temp = 0; while(l1 != null || l2 != null || temp != 0)&#123; if (l1!=null)&#123; temp += l1.val; l1 = l1.next; &#125; if (l2!=null)&#123; temp += l2.val; l2 = l2.next; &#125; ListNode tempnode = new ListNode(temp%10); point.next = tempnode; point = point.next; temp = temp/10; &#125; return result.next; &#125;&#125; 优化如下： 由于sum,carry,和取余值有顺序，所以一个temp按照顺序来就可以了 先当做sum 再当做取余 最后做进位]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷57]]></title>
    <url>%2F2018%2F08%2F24%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B757%2F</url>
    <content type="text"><![CDATA[142. Linked List Cycle IIGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up:Can you solve it without using extra space? 12345678910111213141516171819public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode fast = head, slow = head; while(fast!= null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; if (fast == slow)&#123; ListNode slow2 = head; while(slow!=slow2)&#123; slow = slow.next; slow2 = slow2.next; &#125; return slow; &#125; &#125; return null; &#125;&#125; 判断回环找到起始点： 快慢指针 加入数学分析（A+B=N -&gt; A=N-B）根据这个找到A的值 N的值可以从图上分析得到]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷56]]></title>
    <url>%2F2018%2F08%2F24%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B756%2F</url>
    <content type="text"><![CDATA[141. Linked List CycleGiven a linked list, determine if it has a cycle in it. Follow up:Can you solve it without using extra space? 12345678910111213141516171819public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode fast = head, slow = head; while(fast!= null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; if (fast == slow)&#123; ListNode slow2 = head; while(slow!=slow2)&#123; slow = slow.next; slow2 = slow2.next; &#125; return slow; &#125; &#125; return null; &#125;&#125; 判断回环： 快慢指针（要是有机会，总是能再相见） 找不到起始点的 对于while循环的判断条件要细细考虑]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷55]]></title>
    <url>%2F2018%2F08%2F23%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B755%2F</url>
    <content type="text"><![CDATA[234. Palindrome Linked ListGiven a singly linked list, determine if it is a palindrome. Example 1:12Input: 1-&gt;2Output: false Example 2:12Input: 1-&gt;2-&gt;2-&gt;1Output: true Follow up:Could you do it in O(n) time and O(1) space?12345678910111213141516171819public class Solution &#123; public boolean isPalindrome(ListNode head) &#123; ListNode point = head; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); while(point!=null)&#123; s.push(point.val); point = point.next; &#125; while (head!=null)&#123; if (head.val!=s.pop())&#123; return false; &#125; else&#123; head = head.next; &#125; &#125; return true; &#125;&#125; 首先想到的是堆栈法： 先全部压如栈，再一个个弹出来比较 显然效率不高，遍历了两次 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public boolean isPalindrome(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; &#125; if (fast!=null)&#123; slow = slow.next;//这个地方不要可以，可以少遍历一个数 &#125; slow = reverse(slow); fast = head; while(slow!=null)&#123; if (slow.val!=fast.val)&#123; return false; &#125; slow = slow.next; fast = fast.next; &#125; return true; &#125; private ListNode reverse(ListNode head)&#123; ListNode result = null; while(head!=null)&#123; ListNode point = head; head = head.next; point.next = result; result = point; &#125; return result; &#125;&#125; 然后是效率较高的快慢指针法： 总体应该是遍历1.5次（不确定） 利用快慢指针先对半分，然后把后半部分逆序，与前半部分一一比较 对于逆序的head = head.next;point.next = result;有顺序要求，head得先操作跑掉，否则point的操作影响了head]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷54]]></title>
    <url>%2F2018%2F08%2F23%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B754%2F</url>
    <content type="text"><![CDATA[21. Merge Two Sorted ListsMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example:12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; ListNode result = new ListNode(0);//(方便头部的边界问题) ListNode point = result;//（point相当于i） while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; point.next = l1; l1 = l1.next; &#125; else &#123; point.next = l2; l2 = l2.next; &#125; point = point.next;//（相当于i++） &#125; if (l1 == null)&#123; point.next = l2; &#125; if (l2 == null)&#123; point.next = l1; &#125; return result.next;//去掉头部，就可以吃了 &#125;&#125; 合并两个表： 思路容易 确定规范（见注释）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷53]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B753%2F</url>
    <content type="text"><![CDATA[206. Reverse Linked ListReverse a singly linked list. Example:12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Follow up:A linked list can be reversed either iteratively or recursively. Could you implement both? 12345678910111213class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode newhead = null; ListNode tempnode = null; while(head!= null)&#123; tempnode = head; head = head.next; tempnode.next = newhead; newhead = tempnode; &#125; return newhead; &#125;&#125; 迭代法： head = head.next加上while(head!= null)作为迭代循环器 中间节点tempnode用来指选节点 新链表newhead一步步完成逆序1234567891011121314151617class Solution &#123; public ListNode reverseList2(ListNode head) &#123; return reverseListInt(head,null); &#125; private ListNode reverseListInt(ListNode head, ListNode newHead) &#123; if (head == null)&#123; return newHead; &#125; ListNode tempnode = null; tempnode = head; head = head.next; tempnode.next = newHead; return reverseListInt(head,tempnode); &#125;&#125; 回溯法： 核心函数相同 将迭代的结束条件单独拎出来 用递归替代迭代的遍历]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷52]]></title>
    <url>%2F2018%2F08%2F19%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B752%2F</url>
    <content type="text"><![CDATA[19. Remove Nth Node From End of ListGiven a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid. 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode start = new ListNode(0); ListNode slow = start,fast = start;//同时指向start，slow,fast操作的时候会影响到start start.next = head;//把头指向head /* * 先派fast先走两步，fast在这里只是充当探底，找到倒数第二个数的作用 * */ for (int i = 0; i &lt;= n; i++) &#123; fast = fast.next; &#125; /* * 一起走两步 * */ while (fast!=null)&#123; fast = fast.next; slow = slow.next; &#125; /* * 关键的操作，跳过slow后面的那个 * */ slow.next = slow.next.next;//但是为什么要设置一个头呢，是不是因为怕影响原始的你的node呢 return start.next; &#125;&#125; 按照python版本的写的，说实话，觉得没必要加上虚拟第一个节点，加上第一个节点可以避免第一个head的node造成的逻辑错误，下面的方法就是不需要的： 12345678910111213141516public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode tmp=head,pre=head; while(n--!=0)&#123; tmp=tmp.next; &#125; if(tmp==null) return head.next;//list contains n ele while(tmp.next!=null)&#123; pre=pre.next; tmp=tmp.next; &#125; pre.next=pre.next.next; return head; &#125; 这一种的方法的话需要额外加一个判断，判断是不是删除第一个节点]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷51]]></title>
    <url>%2F2018%2F08%2F19%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B751%2F</url>
    <content type="text"><![CDATA[237. Delete Node in a Linked ListWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list – head = [4,5,1,9], which looks like following: 4 -&gt; 5 -&gt; 1 -&gt; 9 Example 1:1234Input: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked listshould become 4 -&gt; 1 -&gt; 9 after calling your function. Example 2:1234Input: head = [4,5,1,9], node = 1Output: [4,5,9]Explanation: You are given the third node with value 1, the linked listshould become 4 -&gt; 5 -&gt; 9 after calling your function. Note: The linked list will have at least two elements. All of the nodes’ values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. 1234567891011121314/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val;//没有删除节点，而是把后面的节点转移到改节点上 node.next = node.next.next; &#125;&#125; 链接表的删除，没啥好说的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷50]]></title>
    <url>%2F2018%2F08%2F18%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B750%2F</url>
    <content type="text"><![CDATA[287. Find the Duplicate NumberGiven an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1:12Input: [1,3,4,2,2]Output: 2 Example 2:12Input: [3,1,3,4,2]Output: 3 Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once. 123456789101112131415161718192021class Solution &#123; public int findDuplicate(int[] nums) &#123; int left = 1,right = nums.length-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; int count = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i]&lt;=mid)&#123; count++; &#125; &#125; if (count&gt;mid)&#123; right = mid - 1; &#125; else&#123; left = mid+1; &#125; &#125; return left; &#125;&#125; 这道题的条件其实隐约告诉我们可以用O(NlogN)的做法来做： O(NlogN)隐含：循环+二分 空间复杂度限制我们不能用数组 自己第一次没做出来，看答案理解了很久 可以理解mid含义为左边不大于mid的不重复的最大值{1，2，3，4，5}，比3小的不重复的话count为3；要是count大于mid，说明mid之前的数字大小（注意不是数组里的值）肯定有重复的，进而进行二分 left从一开始还不理解 这道题还有O(N)的解法，用链的思路去做（TODO）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷49]]></title>
    <url>%2F2018%2F08%2F17%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B749%2F</url>
    <content type="text"><![CDATA[213. House Robber IIYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: 123Input: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),because they are adjacent houses. 1234567891011121314151617181920212223242526public class Solution &#123; public int rob(int[] nums) &#123; int len = nums.length; if (len == 0)&#123; return 0; &#125; if (len &lt; 2)&#123; return nums[0]; &#125; int dp1[] = new int[len+1]; int dp2[] = new int[len+1]; dp1[0] = 0; dp1[1] = nums[0]; dp2[0] = 0; dp2[1] = 0; for (int i = 2; i &lt;= len; i++) &#123; dp1[i] = Math.max(dp1[i-1],dp1[i-2]+nums[i-1]);//最后一位取不到 dp2[i] = Math.max(dp2[i-1],dp2[i-2]+nums[i-1]);//第一位取不到 &#125; return Math.max(dp1[len-1],dp2[len]); &#125;&#125; 抢劫邻居题2： 最简单的状态转移方程，容易一口气写出 这道题难在成环 解决方法是设置两个dp,判断是要第一个数据还是最后一个数据（没有想到） 涉及到i-2,i-1,i的问题，可以设置两个标志位来取代dp数组，分别是循环里的tmp和循坏外的dp2，改造后代码如下： 12345678910111213141516171819202122public class Solution &#123; public int rob(int[] nums) &#123; int len = nums.length; if (len == 0)&#123; return 0; &#125; if (len &lt; 2)&#123; return nums[0]; &#125; int dp1 = 0,dp2 = 0,dp3 = 0,dp4 = 0; for (int i = 2; i &lt; len; i++) &#123; int tmp1 = Math.max(dp1,dp2+nums[i]); int tmp2 = Math.max(dp3,dp4+nums[i]); dp2 = dp1; dp1 = tmp1; dp4 = dp3; dp3 = tmp2; &#125; return Math.max(dp1,dp3); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷48]]></title>
    <url>%2F2018%2F08%2F16%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B748%2F</url>
    <content type="text"><![CDATA[647. Palindromic SubstringsGiven a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1:123Input: "abc"Output: 3Explanation: Three palindromic strings: "a", "b", "c". Example 2:123Input: "aaa"Output: 6Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa". Note:The input string length won’t exceed 1000. 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; int res; public int countSubstrings(String s) &#123; int[][] memo = new int[s.length()][s.length()]; helper(s,memo,0,s.length()-1); return res; &#125; public int helper(String s, int[][] memo, int left, int right)&#123; if (memo[left][right] != 0)&#123; return memo[left][right]; &#125; if (left == right)&#123; memo[left][right] = 1; res++; return memo[left][right]; &#125; if (s.charAt(left) == s.charAt(right))&#123; if (left == right-1)&#123; memo[left][right] = 1; res++; &#125; else&#123; if (helper(s,memo,left+1,right-1)!=0)&#123; memo[left][right] = 1; res++; &#125; &#125; &#125; if (left&lt;s.length())&#123; helper(s,memo,left+1,right); &#125; if (right&gt;0)&#123; helper(s,memo,left,right-1); &#125; return memo[left][right]; &#125;&#125; 回文判断： 带备忘录的自顶向下 超时（？？？） return的值有讲究，这个问题出错导致debug了好久 子问题重复严重，这个时候带备忘录效果还是不好 123456789101112131415161718192021class Solution &#123; public int countSubstrings(String s) &#123; int sum = 0; for(int i = 0;i &lt; s.length();i++) &#123; int t1 = search(s, i, i); int t2 = search(s, i, i + 1); sum += t1 + t2; &#125; return sum; &#125; public int search(String s, int left, int right) &#123; int valid = 1; while(left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; left--; right++; valid++; &#125; return valid - 1; &#125;&#125; 高效解法： 不知道归啥类 基本不会产生重复判断 自底向上 分成两种情况考虑]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷47]]></title>
    <url>%2F2018%2F08%2F16%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B747%2F</url>
    <content type="text"><![CDATA[682. Baseball Gameou’re now a baseball game point recorder. Given a list of strings, each string can be one of the 4 following types: Integer (one round’s score): Directly represents the number of points you get in this round. “+” (one round’s score): Represents that the points you get in this round are the sum of the last two valid round’s points. “D” (one round’s score): Represents that the points you get in this round are the doubled data of the last valid round’s points. “C” (an operation, which isn’t a round’s score): Represents the last valid round’s points you get were invalid and should be removed. Each round’s operation is permanent and could have an impact on the round before and the round after. You need to return the sum of the points you could get in all the rounds. Example 1:12345678Input: ["5","2","C","D","+"]Output: 30Explanation: Round 1: You could get 5 points. The sum is: 5.Round 2: You could get 2 points. The sum is: 7.Operation 1: The round 2's data was invalid. The sum is: 5. Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15.Round 4: You could get 5 + 10 = 15 points. The sum is: 30. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int calPoints(String[] ops) &#123; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); int sum = 0; for (String c : ops) &#123; if (c.equals("+"))&#123; int temp = s.pop(); int add = temp+s.peek(); sum += add; s.push(temp); s.push(add); &#125; else if(c.equals("C"))&#123; int cancel = s.pop(); sum -= cancel; &#125; else if(c.equals("D"))&#123; int db = s.pop(); int db_2 = db*2; sum += db_2; s.push(db); s.push(db_2); &#125; else&#123; int temp = Integer.parseInt(c); sum += temp; s.push(temp); &#125; &#125; return sum; &#125;&#125; 棒球比赛积分： 堆问题 计算的时候需要找最近的几个数据 可能这就是堆问题的一点特征吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷46]]></title>
    <url>%2F2018%2F08%2F16%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B746%2F</url>
    <content type="text"><![CDATA[20. Valid ParenthesesGiven a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1:12Input: "()"Output: true Example 2:12Input: "()[]&#123;&#125;"Output: true Example 3:12Input: "(]"Output: false Example 4:12Input: "([)]"Output: false Example 5:12Input: "&#123;[]&#125;"Output: true 12345678910111213141516171819202122class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (Character c: s.toCharArray())&#123; if ( c == '(')&#123; stack.push(')'); &#125; else if (c == '&#123;')&#123; stack.push('&#125;'); &#125; else if (c == '[')&#123; stack.push(']'); &#125; else&#123; if (stack.isEmpty() == true || stack.pop() != c)&#123; return false; &#125; &#125; &#125; return stack.isEmpty(); &#125;&#125; 一道简单的栈问题： 括号匹配问题 最新的一对匹配跳出 符合先进后出原则 此题不用map，利用人为压栈括号的反面，出栈时对比相同，巧妙]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷45]]></title>
    <url>%2F2018%2F08%2F15%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B745%2F</url>
    <content type="text"><![CDATA[84. Largest Rectangle in HistogramGiven n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Example: 12Input: [2,1,5,6,2,3]Output: 10 12345678910111213141516171819class Solution &#123; public int largestRectangleArea(int[] height) &#123; int len = height.length; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;() ; int max = 0; for (int i = 0; i &lt; len+1; i++) &#123; int h = (i==len?0:height[i]); if (stack.isEmpty() || h &gt;= height[stack.peek()])&#123; stack.push(i); &#125; else&#123; int top = stack.pop(); max = Math.max(max,height[top]*((stack.isEmpty())?i:i-1-stack.peek())); i--; &#125; &#125; return max; &#125;&#125; 水坑问题： 栈解决（不熟练） 栈方法的适用范围？ 栈方法与dp的关系？]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷44]]></title>
    <url>%2F2018%2F08%2F15%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B744%2F</url>
    <content type="text"><![CDATA[64. Minimum Path SumGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: 12345678Input:[ [1,3,1], [1,5,1], [4,2,1]]Output: 7Explanation: Because the path 1→3→1→1→1 minimizes the sum. 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int minPathSum(int[][] grid) &#123; int row = grid.length; int col = grid[0].length; int dp[][] = new int[row][col]; dp[0][0] = grid[0][0]; if (row == 1)&#123; int temp = 0; for (int i = 0; i &lt; col; i++) &#123; temp += grid[0][i]; &#125; return temp; &#125; if (col == 1)&#123; int temp = 0; for (int i = 0; i &lt; row; i++) &#123; temp += grid[i][0]; &#125; return temp; &#125; for (int i = 1; i &lt; row; i++) &#123; dp[i][0] = dp[i-1][0]+grid[i][0]; for (int j = 1; j &lt; col; j++) &#123; dp[0][j] = dp[0][j-1]+grid[0][j]; dp[i][j] = Math.min(dp[i-1][j]+grid[i][j],dp[i][j-1]+grid[i][j]); &#125; &#125; return dp[row-1][col-1]; &#125;&#125; 解法一： 自底向上 二维数组dp(可以优化) 棋盘问题 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int minPathSum(int[][] grid) &#123; int row = grid.length; int col = grid[0].length; int[][] memo = new int[row][col];//备忘录 return helper(grid,memo,row-1,col-1); //顶部开始 &#125; public int helper(int[][] grid, int[][] memo, int x, int y)&#123; //结束条件 if (x==0 &amp;&amp; y==0)&#123; return grid[0][0]; &#125; //剪枝条件 if (memo[x][y] != 0)&#123; return memo[x][y]; &#125; //一般处理条件 int left = Integer.MAX_VALUE; int up = Integer.MAX_VALUE; if (y&gt;0)&#123; up = helper(grid,memo,x,y-1); &#125; if (x&gt;0)&#123; left = helper(grid,memo,x-1,y); &#125; //核心转移方程 int dist = grid[x][y]+Math.min(left,up); //备忘录记录 memo[x][y] = dist; return dist; &#125;&#125; 解法二： 带备忘录自顶向下 带剪枝 helper函数的状态量确定（不熟练） 回溯写法不熟练]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机-Chapter11]]></title>
    <url>%2F2018%2F08%2F15%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Chapter11%2F</url>
    <content type="text"><![CDATA[晚期（运行期）优化概述Java程序在运行的期间，可能会有某个方法或者代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时JVM会将这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler,JIT编译器）。 解释器与编译器事实上，现在许多主流的商用虚拟机，都同时包含有解释器与编译器，解释器与编译器两者各有优势。与解释器相比，编译器会将常运行到的代码编译成本地代码区实现，可以获取更高的执行效率。而当程序运行环境中内存资源限制较大时，可以使用解释执行节约内存，反之可以使用编译执行来提高效率。解释器和编译器之间还可以通过逆优化退回到解释状态继续执行，因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作。关系如图所示： HotSpot编译器中出现两个编译器Client Compiler称为「C1编译器」，Server Compiler称为「C2编译器」。JVM默认采用解释器与其中一个编译器直接配合的方法工作，程序使用哪个编译器，取决于虚拟机运行的模式，HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用“-client”或“server”参数去强制指定虚拟机运行在Client模式还是Server模式。 编译对象与触发条件编译对象在运行过程中会被即时编译器编译的“热点代码”有两类： 被多次调用的方法。 被多次执行的循环体。 对于第一种情况，由于是由方法调用触发的编译，因此编译器会以整个方法作为编译对象，这种编译也是虚拟机中标准的JIT编译方式。而对第二种情况，尽管编译动作是由循环体所触发的，但编译器依然会以整个方法作为编译对象，这种编译方式因为编译发生在方法执行过程之中，因此形象地被称为栈上替换，简称为OSR编译，即方法栈帧还在栈上，方法就被替换了。 触发条件判断一段代码是不是为热点代码，是不是需要触发即时编译，这样的行为称为热点探测，但进行热点探测也是不一定要知道方法具体被调用了多少次，目前主要的热点探测判定方法有两种： 基于采样的热点探测：虚拟机会周期性地检查各种线程的栈顶，如果发现某个或者某些方法经常出现在栈顶，那这个方法就是“热点方法”。 优点：实现简单、高效，还可以很容易地获取方法调用方法。 缺点：很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。 基于计数器的热点探测：虚拟机会为每个方法尽力计数器，统计方法的执行次数，如果执行次数超过一定的阙值就认为它是热点方法。 优点：统计结构相对来说更加精确与严谨。 缺点：实现起来麻烦，需要为每个方法及建立并维护计数器，而且不能直接获取到方法的调用关系。 在HotSpot中使用的是第二种方法，基于计数器的热点探测法，因此它为每个方法准备了两类计数器：方法调用计数器和回边计数器（回边计数器是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为”回边“；显然，建立回边计数器统计的目的是为了触发OSR 编译） 方法调用计数器（统计方法被调用次数） 当一个方法被调用时，会先检查该方法是否存在被JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法计数器的阈值。若超过了，则将会向即时编译器提交一个该方法的代码编译请求； 整个JIT 编译的交互过程如下图所示： 回边计数器（统计方法循环体代码执行次数） 当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的version，如果有，他将会优先执行已编译的代码，否则就把回边计数器的值加1，然后判断方法调用计数器与回边计数器之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果，整个执行过程如下图所示： 编译过程在默认设置下，无论是方法调用产生即使「编译请求」，还是「OSR编译请求」，虚拟机在代码编译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线程中进行。 在后台执行编译的过程中，对于Client Compiler来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。 一个平台独立前段将字节码构造成一种高级中间代码表示（HIR），HIR使用 静态单分配的形式来表示代码值，这可以使得一些在JIR的构造过程之中和之后进行的优化动作更容易实现。在此之前，编译器会在字节码上完成一部分基础优化，如方法内联、常量传播等。 一个平台相关的后端从HIR中产生低级中间代码表示，而在此之前，在HIR上完成另外一些优化， 如空值检查消除、范围检查消除等。 在平台的后端使用线性扫描算法在LIR上分配寄存器，并在LIR上做窥孔优化，然后产生机器代码。 过程如图所示： 对于Server Compiler则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译期，也是一个充分优化过的高级编译器，它会执行所有经典的优化动作。Server Compiler的寄存器分配器是一个全局图着色分配器，它可以充分利用某些处理器架构上的大寄存器集合。所以它也是比较缓慢的，但是编译代码质量高，可以减少本地代码的执行时间，从而抵消了额外的编译时间开销，所以很多非服务端的应用选择使用server模式的虚拟机运行。 编译优化技术]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机-Chapter10]]></title>
    <url>%2F2018%2F08%2F15%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Chapter10%2F</url>
    <content type="text"><![CDATA[早期（编译期）优化概述JVM的编译器可以分为三个编译器： 前端编译器：把.java转变为.class的过程。如Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。 JIT编译器：把字节码转变为机器码的过程，如HotSpot VM的C1、C2编译器。 AOT编译器：静态提前编译器，直接将*.java文件编译本地机器代码的过程。 本节讲述的仅限于第一类编译过程 Java即时编译器在运行期的优化过程对于程序运行来说更加重要，而前端编译器在编译期的优化过程对于程序编码，来说关系更加密切。 Javac编译器Javac编译器本身是由Java语言编写的程序。 编译过程大致可以分为3个过程： 解析与填充符号表过程。 插入式注解处理器的注解处理过程。 分析与字节码生成过程。 这3个步骤之间的关系与交互顺序如下： 解析与填充符号表解析步骤包括了词法分析和语法分析两个过程 词法分析与语法分析词法分析：将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记。如“int a=b+2”这句代码就包含了6个标记，分别是int、a、=、b、+、2。 语法分析：是根据Token序列构造抽象语法树的过程，「抽象语法树」是一种用来描述程序代码语法结构的树形表述方式。语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、接口、返回值甚至代码注释都可以是一个语法结构。 经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都是建立在抽象语法树之上的。 填充符号表完成抽象语法树之后，下一步就是填充符号表的过程，即enterTrees()方法。符号表是由一组符号地址和符号信息构成的表格，类似于哈希表中K-V值对的形式。符号表中所登记的信息在编译的不同阶段都要用到。当对符号名进行地址分配时，符号表是地址分配的依据。 注解处理器JDK1.5之后，Java提供了对注解的支持，这些注解与普通的Java代码一样，在运行期间发挥作用。 可以把它看做是一组编译器的插件，在这些插件里面，可以读取。修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round。也是上图中的回环过程。 语义分析与字节码生成语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源代码抽象。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。在Javac编译过程中，语法分析过程分为标注检查以及数据及控制流分析两个步骤。 标注检查：标注检查步骤检查的内容包括诸如：变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。此外，这个过程中还有一个重要的步骤称为常量折叠，如定义int a = 1 + 2 和 int a = 1 + 2 是一样的 数据及控制流分析：数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以查出诸如程序员局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译期的数据及控制流分析与类加载时的数据及数据流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或者运行期才能进行。如将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障。 解语法糖：语法糖是指在计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。Java是一种“低糖语言”，常用的语法糖主要是之前提到的泛型、变长参数、自动装箱/拆箱等。虚拟机运行时不支持这些语法，它们在编译期还原回简单的基础语法结构，这个过程称为解语法糖。 字节码生成：字节码生成是Javac编译过程的最后一个阶段，字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化为字节码写入磁盘中，编译器还进行了少量代码添加和转换工作。实例构造器&lt; init &gt;方法和类构造器&lt; clinit &gt;方法就是在这个阶段添加到语法树中的。 Java语法糖泛型和类型擦除与C#的泛型不一样的是，Java的泛型只存在于程序源码中，在编译后的字节码文件中，就已经替换成原来的原生类型，也称为裸类型，并且在相应的地方插入了强制转型代码。 对于运行期的Java语言来说，ArrayList&lt; String &gt;与ArrayList&lt; Integer &gt;就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。 故当方法名一样，List&lt; String &gt;和List&lt; Integer &gt;作为参数时，擦除使得两者的特征签名变得一样，导致拥有这两个方法无法重载。 擦除法所谓的擦除，仅仅是对方的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。 自动装箱、拆箱与遍历循环自动装箱、拆箱在编译之后就被转换成了相应的包装和还原方法，如Integer.valueOf()与Integer,intValue()方法，而遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历类实现Iterable接口的原因。栗子： 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; Long h = 2L; System.out.println(c==d); System.out.println(e==f); System.out.println(c==(a+b)); System.out.println(c.equals(a+b)); System.out.println(g==(a+b)); System.out.println(g.equals(a+b)); System.out.println(g.equals(a+h)); System.out.println(a==b); &#125;&#125; 输出结果： 12345678truefalsetruetruetruefalsetruefalse 当包装器类进行“==”比较时，内部会调用 Integer.valueOf方法进行自动装箱（int -&gt; Integer），源码如下： 1234567891011121314151617181920/** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */ public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 从源码中可见，Integer对象内部有IntegerCache类，可缓存（-128~127范围的数值），如果超过了，则会返回一个新的Integer类。由于“==”比较的是内存地址，因此，在“-128~127”数值范围内，比较的是同一个对象，得到true，而超过了该范围，则是返回自动装箱后的新对象，因此得到false。 总结： Integer（-128~127）、Short（-128~127）、Byte（-128~127）、Character（0~127）、Long（-128~127）这几个包装类的valueOf方法的实现是类似的 Double、Float的valueOf方法的实现是类似的，并没有缓存，直接返回一个新的实例化对象 Boolean的valueOf方法的实现是个三目运算，形如return (b ? TRUE : FALSE); TRUE、FALSE为两个内部定义的静态成员，这里直接返回两者其一 当 “==”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算或含有基本类型）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷43]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B743%2F</url>
    <content type="text"><![CDATA[72. Edit DistanceGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: * Insert a character * Delete a character * Replace a character Example 1: 123456Input: word1 = "horse", word2 = "ros"Output: 3Explanation: horse -&gt; rorse (replace 'h' with 'r')rorse -&gt; rose (remove 'r')rose -&gt; ros (remove 'e') Example 2: 12345678Input: word1 = "intention", word2 = "execution"Output: 5Explanation: intention -&gt; inention (remove 't')inention -&gt; enention (replace 'i' with 'e')enention -&gt; exention (replace 'n' with 'x')exention -&gt; exection (replace 'n' with 'c')exection -&gt; execution (insert 'u') 12345678910111213141516171819202122232425class Solution &#123; public int minDistance(String word1, String word2) &#123; int len1 = word1.length(); int len2 = word2.length(); int dp[][] = new int[len1+1][len2+1]; for (int i = 0; i &lt;= len1; i++) &#123; dp[i][0] = i; &#125; for (int j = 0; j &lt;= len2; j++) &#123; dp[0][j] = j; &#125; for (int i = 1; i &lt;= len1; i++) &#123; for (int j = 1; j &lt;= len2 ; j++) &#123; if (word1.charAt(i-1)==word2.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1]; &#125; else&#123; dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i-1][j-1]),dp[i][j-1])+1; &#125; &#125; &#125; return dp[len1][len2]; &#125;&#125; 单词最短距离： 二维数组dp 自底向上 根据三个方式（增减换）确定状态转移方程 由于题目中的二维数组dp[i][j]，只与dp[i-1][j]，dp[i][j-1]，dp[i-1][j-1]有关，所以可以改编成一位数组，降一维，但是dp[i][j-1]这个选项，需要额外设置暂存值来进行比较。改进后可以把复杂度降低到O(n)12345678910111213141516171819202122232425262728class Solution &#123; public int minDistance(String word1, String word2) &#123; int len1 = word1.length(); int len2 = word2.length(); int dp[] = new int[len2+1]; for (int j = 0; j &lt;= len2; j++) &#123; dp[j] = j; &#125; for (int i = 1; i &lt;= len1; i++) &#123; int prev = i; for (int j = 1; j &lt;= len2 ; j++) &#123; int cur; if (word1.charAt(i-1)==word2.charAt(j-1))&#123; cur = dp[j-1]; &#125; else&#123; cur = Math.min(Math.min(dp[j-1],prev),dp[j])+1; &#125; dp[j-1] = prev; prev = cur; &#125; dp[len2] = prev; &#125; return dp[len2]; &#125;&#125; 每次存dp[j-1],prev表示“dp[i]”，cur表示现有值，这边可能有点绕。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷42]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B742%2F</url>
    <content type="text"><![CDATA[42. Trapping Rain WaterGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example:12Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 123456789101112131415161718192021class Solution &#123; public int trap(int[] height) &#123; if(height == null || height.length &lt;= 2) &#123; return 0; &#125; int len = height.length; int left[] = new int[len]; int right[] = new int[len]; left[0]= height[0]; right[len-1] = height[len-1]; for (int i = 1; i &lt; len; i++) &#123; left[i] = left[i-1]&lt;height[i] ? height[i] : left[i-1]; right[len-1-i] = height[len-i-1]&gt;right[len-i] ? height[len-i-1] : right[len-i]; &#125; int sum = 0; for (int i = 0; i &lt; len; i++) &#123; sum += Math.min(left[i],right[i])-height[i]; &#125; return sum; &#125;&#125; 水坑题： 自底向上 双dp数组 状态转移函数可以从图形上抽象得出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷41]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B741%2F</url>
    <content type="text"><![CDATA[32. Longest Valid ParenthesesGiven a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. Example 1:123Input: "(()"Output: 2Explanation: The longest valid parentheses substring is "()" Example 2:123Input: ")()())"Output: 4Explanation: The longest valid parentheses substring is "()()" 123456789101112131415161718192021class Solution &#123; public int longestValidParentheses(String s) &#123; int maxVal = 0; int len = s.length(); int[] dp = new int[len]; for (int i = 1; i &lt; len; i++) &#123; if (s.charAt(i) == ')')&#123; if (s.charAt(i-1) == '(')&#123; dp[i] = ((i&gt;=2)?dp[i-2]:0)+2; &#125; else&#123; if (i - dp[i - 1] - 1 &gt;= 0 &amp;&amp; s.charAt(i-1-dp[i-1]) == '(' )&#123; dp[i] = dp[i-1]+((i - dp[i - 1] - 2) &gt;= 0 ? dp[i - dp[i - 1] - 2] : 0)+2;//陷阱 &#125; &#125; &#125; maxVal = Math.max(maxVal,dp[i]); &#125; return maxVal; &#125;&#125; 括号匹配类型题，这道题目而言是典型的动态规划题，解法为自底向上，核心在于状态转移方程的建立，首先是找到一对()匹配对，然后分成两种情况，一种是简单的叠加，另外一种比较复杂，要考虑到大范围括号的计算。摘抄公式如下：12345678910111213For s[i], if s[i] is '(', dp[i] will be 0.else, dp[i] will be dp[i - 2] + 2 when s[i - 1] = '(' i.e. ...() i dp[i] will be dp[i - 1] + dp[i - dp[i - 1] - 2]+ 2 when s[i-1] = ')' &amp;&amp; s[i - dp[i - 1] - 1] = '(' i.e. ...)) i e.g. ()(() ) j = i - dp[i - 1] - 1 j i We keep track of the maximum dp[i] on the fly.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷40]]></title>
    <url>%2F2018%2F08%2F11%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B740%2F</url>
    <content type="text"><![CDATA[Combination SumGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.Example 1:123456Input: candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]] Example 2: 1234567Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] 123456789101112131415161718192021222324class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); helper(new ArrayList&lt;Integer&gt;(),candidates,0,target);//new出来的不要具体说明的嘛? return res; &#125; private void helper(List&lt;Integer&gt; list, int[] candidates, int start, int remain)&#123; if (remain == 0)&#123; res.add(new ArrayList&lt;&gt;(list));//为什么不直接add list呢？ return; &#125; else&#123; for (int i = start; i &lt; candidates.length; i++) &#123; if (remain&lt;candidates[i])&#123; continue; &#125; list.add(candidates[i]); helper(list,candidates,i,remain-candidates[i]); list.remove(list.size()-1); &#125; &#125; &#125;&#125; 一看到这道题就觉得是硬币问题coinchange2的难度加强版，于是就用dp的思路尝试写了一次，不过比较复杂，需要记录一个2层的list来保存中间值，最后提取，自己没有写出来，LeetCode中有人做出来了，网址在这https://leetcode.com/problems/combination-sum/discuss/16509/Iterative-Java-DP-solution。 另外一个用的较多的方法是DFS形式的回溯，这边的DFS可以说是很经典的了，甚至自己一开始无法理解start的含义，拿IDE跑了debug后理解。同时这道题还有t提升的空间，可以加入剪枝的技术，进一步t提高效率，总之是道好题，回去再好好琢磨琢磨。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷39]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B739%2F</url>
    <content type="text"><![CDATA[Container With Most WaterGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. Example: 12Input: [1,8,6,2,5,4,8,3,7]Output: 49 12345678910111213141516171819public int maxArea(int[] height) &#123; int len = height.length; int sum = 0; int left = 0; int right = len-1; while(left&lt;=right)&#123; int tempsum; if (height[left]&lt;=height[right])&#123; tempsum = (right-left)*height[left]; left++; &#125; else&#123; tempsum = (right-left)*height[right]; right--; &#125; sum = Math.max(sum,tempsum); &#125; return sum;&#125; 自己一开始的做法，思路是维护左边右边两个编制位，用一个sum的标志位记录最大值，然后根据左右两边的相对大小判断，左右指针的移动，能通过AC，但是自己也感觉到了很多不必要的搜寻，比如确定一边后，另外一边可以不计算面积，一直移动到比确定边大的值的时候，才有可能取得更大的值。 1234567891011121314151617class Solution &#123; public int maxArea(int[] height) &#123; int len = height.length; int left = 0,right = len - 1,max = 0; while(left&lt;right)&#123; int h = Math.min(height[left],height[right]); max = Math.max(max,h*(right-left)); while(left&lt;right &amp;&amp; height[left]&lt;=h)&#123; left++; &#125; while(left&lt;right &amp;&amp; height[right]&lt;=h)&#123; right--; &#125; &#125; return max; &#125;&#125; 改进后的算法，将指针移动和面积计算剥离，减少不必要的计算提高效率。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷38]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B738%2F</url>
    <content type="text"><![CDATA[Best Time to Buy and Sell Stock with Transaction FeeYour are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: 12345678Input: prices = [1, 3, 2, 8, 4, 9], fee = 2Output: 8Explanation: The maximum profit can be achieved by:Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 12345678910111213141516class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; if (prices == null || prices.length &lt;= 1) &#123; return 0; &#125; int n = prices.length; int hold = -prices[0]; int nothold = 0; for (int i = 1; i &lt; n; i++) &#123; hold = Math.max(hold,nothold-prices[i]); nothold = Math.max(nothold,hold-fee+prices[i]); &#125; return nothold; &#125;&#125; 这道题在原来股票问题2的基础上加了交易费，使得股票问题2中的那种简单的方法没法用了，这道题回归到dp的方法做，但是需要有两个dp数组，分别是hold和nothold这是一种新的要注意的点： dp数组的方式可以是一位数组，标志位，二维数组，交替使用的2个一维数组等等 然后这道题的另外一个要点是，本来是用的数组，但是由于状态转移方程之和前面一个有关，就可以退化为2个标志位了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷37]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B737%2F</url>
    <content type="text"><![CDATA[Coin Change 2You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Note: You can assume that 0 &lt;= amount &lt;= 5000 1 &lt;= coin &lt;= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer Example 1:123456789101112131415161718Input: amount = 5, coins = [1, 2, 5]Output: 4Explanation: there are four ways to make up the amount:5=55=2+2+1**Example 1**5=2+1+1+15=1+1+1+1+1``` **Example 2**:```jsInput: amount = 3, coins = [2]Output: 0Explanation: the amount of 3 cannot be made up just with coins of 2.``` **Example 3**:```jsInput: amount = 10, coins = [10] Output: 1 123456789101112131415161718class Solution &#123; public int change(int amount, int[] coins) &#123; int[] dp = new int[amount+1]; dp[0] = 1; for (int coin:coins)&#123; for (int i = coin; i &lt;= amount; i++) &#123; dp[i] += dp[i-coin]; &#125; &#125; if (dp[amount] == 0)&#123; return 0; &#125; else&#123; return dp[amount]; &#125; &#125;&#125; 这道题可以说是和硬币题的第一题是很经典的背包问题了，之前的要求是用最少的硬币找到目标金额的值，这道题是用尽量多的方法找到目标金额的值，讲道理难度差不多，不过又没有做出来，后来翻了答案，发现把两个循环的顺序反一下就可以了，而且还避免了设置标志位的麻烦，总之，这道题非常经典，之后的笔试题很有可能会考的。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机-Chapter8]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Chapter8%2F</url>
    <content type="text"><![CDATA[虚拟机字节码执行引擎 代码编译的结果是从本地机器码变成字节码，是存储格式发展的一小步，却是编程语言发展的一大步。 运行时栈帧结构 栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。 每一个栈帧都包含了局部变量表、操作数栈、动态连接、方法返回地址等信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定，并且写入到方法表的Code属性之中。 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。 在活动线程中，只有位于栈顶的栈帧才是有效的。 局部变量表 局部变量表(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。 局部变量与类变量不同，必须要赋初始值 。 操作数栈 操作数栈(Operand Stack)也常称操作栈，它是一个后入先出(Last In First Out,LIFO)栈。操作数栈的最大深度也在编译的时候写如了Code属性的max_stacks数据项中。 当一个方法刚刚开始执行时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。 在概念模型中，两个栈帧作为虚拟机栈的元素，是完全独立的，但在大多数虚拟机的实现里都会做一些优化梳理，令两个栈帧出现一部分重叠。 动态连接 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。 Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以 常量池中指向方法的符号引用作为参数 。 这些符号引用一部分会在类加载阶段或第一次使用的时候就转化为直接引用，这种转化称为 静态解析 。另外一部分将在每一次运行期间转化为直接引用，这部分称为 动态连接 。 方法返回地址 当一个方法开始执行后，只有两种方式可以退出这个方法： 第一种方式是执行引擎遇到任意一个 方法返回的字节码指令 ，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口(Normal Method Invocation Comletion)。 另一种是，在方法执行过程中遇到异常，并且这个异常没有在方法体内得到处理，就会导致方法退出，这种退出方法的方式称为 异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。 一般来说，方法正常退出时，调用者的 PC计数器的值 可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过 异常处理器表 来确定的，栈帧中一般不会保存这部分信息。 方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有： 恢复上层方法的局部变量表和操作栈帧 返回值（如果有的话）压入调用者栈帧的操作数栈中 调整PC计数器的值 指向方法调用指令后面的一条指令等 附加信息方法调用方法调用并不等同于方法执行，方法调用阶段唯一的任务就是 确定被调用方法的版本（即调用哪一个方法） ，暂时还不涉及方法内部的具体运行过程。 解析 在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括 静态方法 和 私有方法 两个大类，前者与类型直接关联，后者在外部不可被访问，这决定了它们不可能通过继承或别的方式重写其他版本，因此它们都适合 在类加载阶段进行解析 。 与之相对应的是，在Java虚拟机里面提供了5条方法调用字节码指令： invokestatic：调用静态方法。 invokespecial：调用实例构造器方法、私有方法和父类方法。 invokevirual：调用所有的虚方法。 invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。 invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有 静态方法 、 私有方法 、 实例构造器 、 父类方法 4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法称为「非虚方法」。 还有一种特殊情况就是被final修饰的方法，虽然final方法使用invokevirual指令来进行调用，但是由于其无法被覆盖，没有其他版本，所以无须对方接受者进行多态选择。 分派！！！Java具备面向对象的三个基本特征：继承，封装和多态 静态分派——重载(Overload)的体现 重载：两同一不同 类、方法名 相同 形参列表 不同 返回类型、修饰符 无关 12345678910111213141516171819202122232425//方法静态分派演示public class StaticDispatch&#123; static abstract class Human&#123; &#125; static class Man extends Human&#123; &#125; static class Woman extends Human&#123; &#125; public void sayHello(Human guy)&#123; System.out.println("hello,guy!"); &#125; public void sayHello(Man guy)&#123; System.out.println("hello,getleman!"); &#125; public void sayHello(Woman guy)&#123; System.out.println("hello,lady!"); &#125; public static void main(String[] args)&#123; Human man = new Man(); Human woman = new Woman(); StaticDispatch sr = new StaticDispatch(); sr.sayHello(man); //输出hello,guy! sr.sayHello(woman); //输出hello,guy! &#125;&#125; 对于 Human man = new Man(); ：我们把 Human 称为变量的 静态类型 (Static Type)，或者叫做变量的 外观类型 (Apparent Type)，后面的 Man 则称为变量的 实际类型 (Actual Type)。 静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期 可知 的；而 实际类型 变化的结果在 运行期 才可确定，编译器在编译程序的时候并 不知道 一个对象的实际类型是什么。 回到上述代码，main()里面的两次sayHello()方法调用，在方法接收者已经确定是对象“sr”情况下，使用哪个重载版本，就完全 取决于传入参数的数量和数据类型 。虚拟机（准确地说是编译器）在重载时是通过参数的 静态类型 而不是实际类型作为判定依据的。 所有依赖静态类型来定位方法执行版本的分派动作称为 静态分派 。 123456789101112131415161718192021222324252627//重载方法匹配优先级public class Overload&#123; public static void sayHello(Object args)&#123; System.out.println("hello object"); //优先级六，char装箱后转型为父类了，如果有多个父类，则在继承关系中由下往上搜索，越接近上层的优先级越低。 &#125; public static void sayHello(int args)&#123; System.out.println("hello int"); //优先级二，'a'可以代表数据97（'a'的Unicode数值为十进制数字97） &#125; public static void sayHello(long args)&#123; System.out.println("hello long"); //优先级三，进一步转型为长整数97L，（安装char-&gt;int-&gt;long-&gt;float-&gt;double的顺序转型） &#125; public static void sayHello(Character args)&#123; System.out.println("hello Character"); //优先级四，发生一次自动装箱，'a'被包装成它的封装类型java.lang.Character &#125; public static void sayHello(char args)&#123; System.out.println("hello char"); //优先级一（最高），‘a’是一个char类型的数据 &#125; public static void sayHello(char... args)&#123; System.out.println("hello char..."); //优先级七，变长参数的重载优先级是最低的，这时候字符'a'被当做了一个数组元素 &#125; public static void sayHello(Serializable args)&#123; System.out.println("hello Serializable"); //优先级五，java.lang.Serializable是java.lang.Character类实现的一个接口，当自动装箱之后发现还是找不到装箱类，但是找到了装箱类实现的接口类型，所以又发生了一次自动转型。char可以转型成int，但Character是绝对不会转型为Integer的，它只能安全地转型为它实现的接口或父类。 &#125; public static void main(String[] args)&#123; sayHello('a'); &#125;&#125; 优先级规则： 先char-int-long-float-double方向转换（byte和short不会，因为转型不安全） 自动装箱（char-Character） 检查接口 检查父类 变长参数 动态分派——重写(Override)的体现 重写：两同两小一大 方法名、形参列表 相同 子类返回类型、抛出异常 小于等于 父类方法返回类型、父类方法抛出异常 子类访问权限 大于等于 父类方法访问权限。 12345678910111213141516171819202122232425262728293031public class DynamicDispatch&#123; static abstract class Humam&#123; protected abstract void sayHello(); &#125; static class Man extends Human&#123; @override protected void sayHello()&#123; System.out.println("man say hello"); &#125; &#125; static class Woman extends Human&#123; @override protected void sayHello()&#123; System.out.println("woman say hello"); &#125; &#125; public static void main(String[] args)&#123; Human man = new Man(); Human woman = new Woman(); man.sayHello(); woman.sayHello(); man = new Woman(); man.sayHello(); &#125;&#125;/** *运行结果： *man say hello *woman say hello *woman say hello **/ invokevirtual指令的运行时解析过程大致分为以下几个步骤： 找到操作数栈顶的第一个元素所指向的对象的 实际类型 ，记作C 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。 由于invokevirtual指令执行的第一步就是在运行期确定接收者的 实际类型 ，所有两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中 方法重写的本质 。 我们把这种在 运行期 根据实际类型确定方法执行版本的分派过程称为动态分派。 单分派与多分派12345678910111213141516171819202122232425262728public class Dispatch &#123; static class QQ &#123;&#125; static class _360 &#123;&#125; public static class Father &#123; public void hardChoice(QQ arg) &#123; System.out.println("father choose qq"); &#125; public void hardChoice(_360 arg) &#123; System.out.println("father choose 360"); &#125; &#125; public static class Son extends Father &#123; public void hardChoice (QQ arg) &#123; System.out.println("son choose qq"); &#125; public void hardChoice (_360 arg) &#123; System.out.println("son choose 360"); &#125; &#125; public static void main(String[] args) &#123; Father father = new Father(); Father son = new Son(); father.hardChoice(new _360()); son.hardChoice(new QQ()); &#125;&#125;//father choose 360//son choose qq 方法的接收者与方法的参数统称为方法的 宗量 。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。我们看编译阶段编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点：一是静态类型是Father还是Son，二是方法参数是QQ还是360这次选择结果产生了两条invokevirtual指令，两条指令的参数分别是常量池中指向 Father.hardChoice(360) 及 Father.hardChoice(QQ) 方法的符号引用。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。 再看运行阶段虚拟机的选择，也就是动态分派的过程。在执行 son.hardChoice(new QQ()) 这句代码时（准确地说时在执行这句代码所对应的invokevirtual指令时），由于 编译期已经决定目标方法的签名必须是 hardChoice(QQ) ，虚拟机此时不会关心传递过来的参数“QQ”到底时“腾讯QQ”还是“奇瑞QQ”，因为这时参数的静态类型、实际类型都对方法的选择 不会 构成影响，唯一可以影响虚拟机选择的因素只有 此方法的接受者的实际类型 是Father还是Son。因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。 Java语言的 静态分派 属于 多分派 类型； 动态分派 属于 单分派 类型。 虚拟机动态分派的实现 “稳定优化” 手段就是为类在方法区中建立一个「虚方法表」（Vritual Methdo Table，也成为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Interface Method Table，简称itable），使用虚方法表索引来代替元数据查找以提高性能。 虚方法表中存放着各个方法的实际入口地址。 如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。 如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。 基于栈的字节码解释执行引擎解释执行 词法分析、语法分析以至后面的优化器和目标代码生成器都可以选择独立与执行引擎，形成一个完整意义的编译器去实现，这类代表是 c/c++ 语言。 选择把其中的一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器，这类代表是 Java 语言。 把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中，如大多数的 JavaScript 。 Java 语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java的编译解释 半独立 的实现。 基于栈的指令集与基于寄存器的指令集 栈指令集： 优点：可移植，代码更加紧凑，编译器实现简单 确定：速度慢，完成相同功能指令数量多 基于栈的解释器执行过程具体见书]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷36]]></title>
    <url>%2F2018%2F08%2F01%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B736%2F</url>
    <content type="text"><![CDATA[Unique Paths IIA robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1:123456789101112Input:[ [0,0,0], [0,1,0], [0,0,0]]Output: 2Explanation:There is one obstacle in the middle of the 3x3 grid above.There are two ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down -&gt; Down2. Down -&gt; Down -&gt; Right -&gt; Right 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length;//行的个数 int n = obstacleGrid[0].length;//列的个数 int[][] sum = new int[m][n]; for (int i = 0; i &lt; n; i++) &#123; if (obstacleGrid[0][i] == 1)&#123; break; &#125; else&#123; sum[0][i] = 1; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; if (obstacleGrid[i][0] == 1)&#123; break; &#125; else&#123; sum[i][0] = 1; &#125; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (obstacleGrid[i][j] == 1)&#123; sum[i][j] = 0; &#125; else&#123; sum[i][j] = sum[i-1][j]+sum[i][j-1]; &#125; &#125; &#125; return sum[m-1][n-1]; &#125;&#125; 这道棋盘题目就是之前棋盘题的小小升级版，加了障碍的石头，解决思路也简单，大体按照原来的思想，要是在中间遇到石头就使dp二维数组为0，要是在两边就做一个分界点，若是遇到了石头，则当前包括之后的的dp数组都是0，这边自己犯傻了，利用数组默认为0，然后关键点break1就行的，自己强行加戏设置flag，绕远路了。最后就是二维数组，脑子清醒一点，行数为obstacleGrid.length，列数为obstacleGrid[0].length。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机-Chapter13]]></title>
    <url>%2F2018%2F08%2F01%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Chapter13%2F</url>
    <content type="text"><![CDATA[线程安全与锁优化 首先需要保证正确性，然后在此基础上实现高效 概述 「面向过程」的编程思想：站在计算机的角度去抽象问题和解决问题，把数据和过程分别作为独立的部分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据。 「面向对象」的编程思想：站在现实世界的角度去抽象和解决问题，把数据和行为都看做是对象的一部分，这样可以让程序员能以符合现实世界的思维方式来编写和组织程序。 线程安全 严格定义：“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。” 这个定义比较严谨，要求线程安全的代码有一个特征：代码本身封装了所有必要的正确性保障手段，这点听起来容易，实际很难做到，在大多数场景中，我们会把定义弱化一点。把“调用这个对象的行为”改为“单词调用”，就可以称之为线程安全了。 Java语言中的线程安全按照线程安全的“安全程度”由强至弱来排序，可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 不可变 在Java语言中，不可变(Immutable)的对象一定是线程安全的。“不可变”带来的安全性是最简单和最纯粹的。 Java语言中， 如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的； 如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产出任何影响才行。 例如java.lang.String类的对象就是一个典型的不可变对象，我们调用它的substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象 。 保证对象行为不影响自己状态的途径有很多种，最简单的就是对象中 带有状态的变量都声明为final ，这样在构造函数结束之后，它就是不可变的。 符合不可变要求的类型，除了String外，常用的还有枚举类型，以及java.lang.Number的部分子类，如Long和Double等数值包装类型，BigInteger和BigDecimal等大数据类型；但同为Number的子类型的原子类 AtomicInteger 和 AtomicLong 则并非不可变的。 绝对线程安全 不管运行时环境如何，调用者都不需要任何额外的同步措施。 在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。 相对线程安全 相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。 在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、 HashTable、Collections的synchronizedCollection()方法包装的集合等。 线程兼容线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数的时候指的是这一种情况。Java API中大部分的类都是属于线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。 线程对立线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。如Thread类的suspend()和resume()方法，System.setIn()、System.setOut()和System.runFinalizersOnExit() 等。 线程安全的实现的实现方法互斥同步(Mutual Exclusion &amp; Synchronization) 同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段， 「临界区(Critical Section)」、「互斥量(Mutex)」和「信号量(Semaphore)」都是主要的互斥实现方式。 在Java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成 monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。 在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将所计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。 两点值得注意： 首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。 其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。 synchronized是Java语言中一个「重量级(Heavyweight)」的操作，在确实有必要情况下才使用。 除了synchronized之外，还可以使用java.util.concurrent包中的「重入锁(ReentrantLock)」 来实现同步。ReentrantLock和synchronized在代码写法上有点区别：一个表现为API层面的互斥锁（lock()h和unlock()方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁。 ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断 、可实现公平锁，以及锁可以绑定多个条件 。 等待可中断是值当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 synchronized中的锁是非公平的 ，ReetrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。 锁绑定多个条件是指一个ReetrantLock对象可以同时绑定多个Condition对象，只需多次调用newCondition()方法即可。 提倡在synchronized能实现需求的情况下，优先考虑synchronized来进行同步。 非阻塞同步(Non-Blocking Synchronization) 互斥同步主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也被称为「阻塞同步」(Blocking Synchronization)，属于一种悲观的并发策略。 基于冲突检测的乐观并发策略：就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，就采取其他的补救措施（如不断重试，直到成功），这种乐观的并发策略的许多实现不需要把线程挂起，因此这种同步策略称为「非阻塞同步」。 使用乐观并发策略需要硬件指令集的发展，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有： 测试并设置（Test-and-Set） 获取并增加（Fetch-and-Increment） 交换（Swap） 比较并交换（Compare-and-Swap，CAS）—— 核心 加载链接/条件存储（Load-Linked/Store-Conditional, LL/SC） CAS指令需要三个操作数，分别是内存位置V，旧的预期值A，新值B，CAS执行时，当且仅当V符合A时，处理器用B值更新V的值，否则不执行。无论是否更新，都是原子操作。 无同步方案 要保证线程安全，并不是一定就要进行同步，两个没有因果关系。 「可重入代码」(Reentrant Code)：这种代码也叫做纯代码(Pure Code)，所有的可重入的代码都是线程安全的。如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求。 「线程本地存储」(Thread Local Storage)：共享数据的代码保证在一个线程中执行。如使用消费队列的架构模式（如“生产者-消费者”模式）中经典Web交互模型中的“一个请求对应一个服务器线程(Thread-per-Request)”的处理方式。Java可以通过java.lang.ThreadLocal类来实现线程本地存储功能。 锁优化自旋锁与自适应自旋 互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态完成。 如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就释放锁。为了让线程等待，我们只需要让线程执行一个忙循环（自旋） ，这项技术就是所谓的「自旋锁 」。 自适应的自旋锁：自适应意味着自旋的时间不在固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 锁消除 锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。 怎么会在明知道不存在数据征用的情况下设置同步呢？原因是许多同步措施不是程序员自己加进去的，而是Java中的代码自己加的。 123456789101112//一段看起来没有同步的代码public String concatString(String s1, String s2, String s3)&#123; return s1 + s2 + s3;&#125;//经javac转化后的字符串链接操作public String concatString(String s1, String s2, String s3)&#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.toString();&#125; 每个StringBuffer.appeng()方法中都有一个同步块，锁就是sb对象。虚拟机观察变量sb，很快发现它的动态作用域被限制在concatString()方法内部，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。 锁粗化 原则上，总是推荐将同步块的作用范围限制的尽量小——只在共享数据的实际作用域才进行同步。 但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体内的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损坏。 如果虚拟机探测到有这样一串零碎的操作对同一个对象加锁（如上面的append()），将会把加锁同步的范围扩展（粗化）到这个操作序列的外部。 轻量级锁 轻量级锁的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 HotSpot虚拟机的对象头(Object Header)分为两部分信息： 第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄(Generational GC Age)等，这部分数据的长度在32位和64位的虚拟机分别为32bit和64bit，称为“Mark Word”，它是实现轻量级锁和偏向锁的关键。 另一部分用于存储指向方法区对象类型数据的指针。 Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽可能多的信息。 在代码进入同步块的时候 如果此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。 然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为“00”，即表示 此对象处于轻量级锁定状态。 如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就膨胀为重量级锁，Mark Word中存储的就是执行重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。 如果没有竞争，轻量级锁可以使用CAS操作避免互斥操作的开销；如果有竞争，则算是额外发生了CAS操作，因此比传统的重量级锁还慢。 偏向锁 轻量级锁是在无竞争的情况下使用CAS操作去取消除同步使用的互斥量。 偏向锁是在无竞争的情况下把整个同步都取消掉，连CAS操作都不做了。]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷35]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B735%2F</url>
    <content type="text"><![CDATA[Best Time to Buy and Sell Stock IVSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1:123Input: [2,4,1], k = 2Output: 2Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2:1234Input: [3,2,6,5,0,3], k = 2Output: 7Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. 123456789101112131415161718192021222324252627class Solution &#123; public int maxProfit(int k, int[] prices) &#123; int n = prices.length; if (n&lt;2)&#123; return 0; &#125; if (k &gt;= n/2)&#123; int maxtemp = 0; for (int i = 1; i &lt; n; i++) &#123; if (prices[i]&gt;prices[i-1])&#123; maxtemp += prices[i]-prices[i-1]; &#125; &#125; return maxtemp; &#125; int[][] dp = new int[k+1][n]; for (int i = 1; i &lt;= k; i++) &#123; int localmax = dp[i-1][0]-prices[0]; for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = Math.max(dp[i][j-1],prices[j]+localmax); localmax = Math.max(localmax,dp[i-1][j]-prices[j]); &#125; &#125; return dp[k][n-1]; &#125;&#125; 这道题算是股票问题的最终形态了，从单次最大利益，到不限次数的最大利益到，到带冷却的最大利益，到两次交易的最大利益，到k次交易的最大利益，但是问题的本质没变，都是dp问题，变的是转移方程。越到后面，转移方程的形式越复杂。这次这道题需要用到dp[k][n]的二维数组才行，这点我居然没有想到；还有就是状态转移方程，其结构和硬币问题很像（现在的状态要嘛和之前的一样，要嘛就是卖了这个价加上之前的dp值，看谁大，当然其满足子问题重叠性和最优子结构这两大基本要求）还有点就是看到了状态转移方程的比较容易的写法，看到写法后能比较快的找到几个max的拆分点。这个问题之前一直无法解决。明天再看看一道max个数多的dp题目。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机-Chapter2]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Chapter2%2F</url>
    <content type="text"><![CDATA[Java内存区域与内存溢出异常 java与c++之间有一堵由内存动态分配和垃圾收集技术所围城的‘高墙’，墙外的人想进去。墙里面的人想出来 运行时的数据区域 程序计数器程序计数器是一块较小的内存空间，它可以看做是当前线程执行的字节码行号的指示器。由于java虚拟机的多线程是通过线程轮流切换并分配处理器时间的方式来执行的，在任何一个确定的时刻，一个处理器都只会执行一个线程。因此，线程切换后为了能够恢复到正确的位置，每个线程都要有一个独立的程序计数器，各个线程的程序计数器独立存储，相互不影响，所以程序计数器这块内存是线程私有。 Java虚拟机栈与程序计数器一样，虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧，这个栈帧用于存储「局部表量表」，「操作数栈」，「动态连接」，「方法出口」等信息。每一个方法从调用到执行完的过程，对应着一个栈帧在虚拟机栈中进栈和出栈的过程。 局部变量表：存放了编译器可知的各种基本数据类型（boolean，byte，char等）、对象引用和returnAddress类型 这个区域规定了两种异常情况： 如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出StackOverflowError异常； 如果虚拟机栈可以动态扩展，扩展时无法申请到足够的空间，就会抛出OutOfMemoryError异常。 本地方法栈本地方法栈与虚拟机栈发挥的作用十分类似，但本地方法是为虚拟机执行「Native方法」服务的，有的虚拟机（如HotSpot）就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，这个区域也有StackOverflowError和OutOfMemoryError异常。 Java堆与程序计数器和虚拟进栈不同的是，堆是所有线程所共享的一块区域。这个区域的唯一目的就是存放实例对象 Java虚拟机规范：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸技术的成熟，又变得不那么绝对了 从内存分配的角度来看，由于现在的收集器基本都采用分代收集算法，所以Java堆又可以划分成： 新生代 Eden区域 From Survivor区域 To Survivor区域 老年代 划分的目的是为了更好的垃圾回收，但是无论哪个区域，存储的都是对象实例。 Java堆可以处在不连续的内存空间中，只要逻辑上是连续的即可，可以是固定大小的，也可以是可扩展的。当对象实例没有完成实例分配，并且堆无法扩展时，就会抛出OutOfMemoryError异常。 方法区首先方法区和Java堆一样，是所有线程共享的区域。它用于存储虚拟机加载的「类信息」，「常量」，「静态变量」等数据。当方法区的内存无法满足内存分配需求时，会抛出OutOfMemoryError异常。 很多人叫方法区为“永久代”，本质上并不等价，应该说是Hotspot虚拟机使用永久代的技术实现了方法区而已，现在看来不是个好主意，会导致内存更容易溢出，之后又用native memory实现方法区的规划了 运行时常量池运行时常量池是方法区的一部分，Class文件中有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池。 Java虚拟机对class文件每一部分都有严格规定，但对于运行时常量池，则没有任何细节要求 一般来说，除了保存class文件中描述的「符合引用」外，还会把翻译出来的「直接引用」也存储在运行时常量池中 运行时常量池相对于的另外一个重要特征是具备「动态性」 直接内存直接内存既不是虚拟机运行区的一部分，也不是内存部分，但是这部分被频繁调用的话，也会导致OutOfMemoryError异常 HotSpot对象对象的创建 当虚拟机遇到一条new指令是，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，那么限制性这个类的相应的加载过程。 在类加载完成后，将为新生对象分配空间。对象所需内存大小在类加载完成后即可完全确定，为对象分配空间的任务等同于把一块与对象大小相等的内存从堆中划分出来。 假设Java堆中的内存是绝对工整的，就是说所有用过的内存都放在一边，没有用过的都放在另一边，中间放着一个指示器作为分界点。那么分配内存的过程其实就是将指示器向空闲内存的一边移动对象大小的距离即可，这种分配方式称为「指针碰撞」。 若堆内存不工整，那么虚拟机必须维护一个列表，记录哪些内存是可用的，哪些内存已经使用过了，在分配时候从空闲内存中找出一块足够大的给对象，这种分配方式称为「空闲列表」。 除了如何「划分内存空间」划分内存空间之外，另一个需要考虑的问题就是「对象创建在虚拟机中是一个非常频繁的行为」，包括两个 ，即使是一个简单的指针移动，在并发情况下也是不安全的。这种问题有两种解决方案： 将移动指针的操作进行同步处理； 把内存分配的动作按照每个线程划分在不同的区域中，即每个线程在Java堆预先划分出一块内存区域，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在哪个线程的TLAB上分配。 「内存分配」完成后，虚拟机需要将分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段可以不赋初值就直接使用。虚拟机接下去对对象进行必要的设置，至于这个对象是哪个类的实例，如何找到元数据信息，对象的哈希码等信息都存放在对象的对象头之中。 上述工作完成后，一个新的对象实际上就已经产生了，但是需要执行init把对象按照程序员的意向初始化，这样才算完全产生一个对象。 对象的内存布局在HotSpot虚拟机中，对象在内存中的存储布局分为三个部分： 对象头 第一部分用于存储对象运行时数据（如哈希码，GC年代，锁状态标识等） 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。 实例数据 实例部分存储的是对象真正有效的信息，也就是在程序代码中所定义的各种类型字段的内容。 对齐填充 对齐填充并不是必然的存在，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，当对象实例数据部分没有对齐时，就需要通过对齐填充来不全。 对象的访问定位Java程序需要通过栈上的reference数据来操作堆上的具体对象，由于reference在Java虚拟机规范中值规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的具体位置，所以对象访问方式也是取决于虚拟机具体实现的。目前主流的方式是句柄和直接指针。 句柄：Java堆中将会划分出来一块内存作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址。 直接指针访问：那么reference中存放的就是对象地址。 两种访问对象的方式，使用各有优势 句柄来访问最大的好处就是reference中存储的句柄地址是稳定的，不会随着对象的移动而移动 直接指针访问的最大好处就是访问速度快 就HotSpot而言，它是使用直接指针方式访问数据的]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷34]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B734%2F</url>
    <content type="text"><![CDATA[Best Time to Buy and Sell Stock IIISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1:1234Input: [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. Example 2: 12345Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.Note that you cannot buy on day 1, buy on day 2 and sell them later, as you areengaging multiple transactions at the same time. You must sell before buying again. Example 3:123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int maxProfit(int[] prices) &#123; int n = prices.length; if (n&lt;1)&#123; return 0; &#125; int dp[] = new int[n]; dp[0] = 0; int buy = prices[0]; int max = 0; for (int i = 1; i &lt; n; i++) &#123;//第一次循环，记录单次收益最大值 buy = Math.min(buy,prices[i-1]); int sell = prices[i]; max = Math.max(max,sell-buy); dp[i] = max; &#125; max = 0;//清空max，再来一次右边到左边的循环 int totalmax = 0; int sell = prices[n-1]; for (int i = n-2; i &gt;= 0 ; i--) &#123; buy = prices[i]; sell = Math.max(sell, prices[i + 1]); max = Math.max(max, sell - buy); int remain = 0;//之前的dp数组，代表左边的数据 if (i &gt; 1) &#123; remain = dp[i - 1]; &#125; totalmax = Math.max(totalmax, remain + max); &#125; return totalmax; &#125;&#125; 这道题说难不难，说简单也不能算简单，关键是要想到把数组分成两半，各自都回了股票问题的的最简单的形态，就是求单次最大利润，分成两半后求左边一次最大的，右边一次最大的，两者做个分界点分离之后再求它的和的最大值，这道题的解法算是自底向上的方法，先做了一个dp数组，接下去用到了该数组的值来进行演算。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机-Chapter12]]></title>
    <url>%2F2018%2F07%2F29%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Chapter12%2F</url>
    <content type="text"><![CDATA[Java内存模型和线程 并发处理的广泛应用是人类“压榨”计算机运行能力的最有利武器 为啥需要并发？ 计算机的运行速度和其他存储和通信子系统差距太大 一个服务端需要为多个客户端提供服务 硬件的效率与一致性 运算任务不能只靠 CPU 来完成，现代计算机加入了读写速度尽量接近 CPU 高速缓存最为内存与处理器之间的缓冲 但是带来了缓存一致性的问题（多个处理器读取同一块内存） 为了解决该问题，各个处理器访问缓存时需要遵守协议（MSI，MESI，MOSI等等） 除了增加高速缓存之外，处理器还会对代码进行乱序执行 Java内存模型 Java 模型定义必须得足够严谨，使其并发内存访问操作不会产生歧义 Java 模型定义必须得足够宽松，使其可以利用硬件的各种特性 主内存与工作内存Java 内存模型的主要目标是定义程序中各个变量的访问规则 变量：与 Java 编程中变量有区别，此处是指实例字段，静态字段和构成数组的对象，但不包括局部变量和方法参数 所有的内存都存储在主内存（与物理硬件的主内存名字一样） 每条线程还有自己的工作内存（与物理硬件的高速缓存类似） 线程的工作内存保存了变量的主内存拷贝副本，对变量操作都在工作内存中，不能直接读取主内存的变量 副本拷贝不是整个对象拷贝，只是对象的一些引用和用到的字段volatile 变量依然有工作内存的拷贝，但是由于其特殊的操作顺序，所以看起来如同直接在主内存中读写访问一般 内存间交互操作 主内存与工作内存之间具体的交互协议，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是「原子的、不可再分」的 lock（锁定）：作用于 主内存 的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于 主内存 的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于 主内存 的变量，它把一个变量的值从 主内存 传输到线程的 工作内存中，以便随后的load动作使用。 load（载入）：作用于 工作内存 的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本 中。 use（使用），作用于 工作内存 的变量，它把工作内存中一个变量的值传递给执行引擎 ，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于 工作内存 的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于 工作内存 的变量，它把 工作内存中一个变量的值传送到 主内存中，以便随后的write操作使用。 write(写入)：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作 如果要把变量从工作内存同步会主内存，就要顺序地执行store和write操作 注意，Java内存模型只要求上述两个操作必须按顺序执行 ，而没有保证是连续执行 ava内存模型还规定了在执行上述8种基本操作时必须满足如下规则： 允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中 一个新的变量只能在主内存中“诞生” ，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，即对一个变量实施use、store操作之前，必须先执行过了assign和load操作 一个变量在同一个时刻只允许一条线程对其进行lock操作 ，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量 对一个变量执行unlock操作之前，必须 先把此变量同步回主内存中(执行store、write操作) 对于volatile型变量的特殊规则 关键字volatile可以说是 Java 虚拟机提供的最轻量级的同步机制 当一个变量定义为volatile之后，它将具备两种特性： 保证此变量对所有线程的可见性 、禁止指令重排序优化 可见性：这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。 提示：Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的，可以通过一段简单的演示来说明原因： 12345678910111213141516171819202122232425public class VolatileTest &#123; public static volatile int race = 0; public static void increase() &#123; race++; &#125; private static final int THREADS_COUNT = 20; public static void main(String[] args) &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; increase(); &#125; &#125; &#125;); threads[i].start(); &#125; //等待所有累加线程都结束 while (Thread.activeCount() &gt; 1) Thread.yield(); System.out.println(race); //输出结果并非200000，而是每次输出的结果都不一样，都是一个小于200000的数字。 &#125;&#125; 问题就出现在自增运算“race++”上，不是原子操作。 volatile变量只能保证「可见性」不能保证「原子性」，在不符合以下两条规则的运算场景中，我们仍然要通过「加锁」（使用synchronized或java.util.concurrent中的原子类）来保证「原子性」。 使用volatile变量的第二个语义是禁止「指令重排序优化」。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获得到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。而volatile赋值后有类似内存屏障(Memory Barrier/Memory Fence)，重排序时不能把后面的指令重排序到内存屏障之前的位置。 1234567891011121314//双重检验模式（DCL）单例模式public class Singleton &#123; private volatile static Singleton instance; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 通过对比生成的汇编代码可知，关键在于volatile修饰的变量，多执行了“lock addl $0x0,(%esp)”，这个lock前缀不允许配合nop指令使用，效果是前面volatile的修改 volatile性能：在某些情况下，volatile的同步机制的性能优于锁（synchronized关键字或者java.util.concurrent包里的锁） volatile读操作的性能消耗和普通变量没什么差别 volatile写操作可能会慢一点，因为需要插入内存屏障指令来保证不发生乱序执行 Java内存模型中对volatile变量定义的特殊规则。假定T表示一个线程，V和W分别表示两个volatile型变量 要求在工作内存中，每次使用V前都必须先从主内存 刷新 最新的值，用于保证能看见其他线程对变量V所做的修改后的值。 要求在工作内存中，每次修改V后都必须立刻 同步 回主内存，用于保证其他线程可以看到自己对变量V所做的修改。 要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。 对于long和double型变量的特殊规则 对于64位的数据（long和double），定义了一条相对宽松的规定：允许虚拟机实现选择可以不保证64位数据类型的load，store，read和write这四个操作的原子性（long和double的「非原子性规定」） 这种情况十分罕见，目前商用的虚拟机几乎都选择64位数据的读写操作作为原子操作 原子性、可见性与有序性 原子性(Atomicity) ：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为8种基本数据类型的访问读写是具备原子性的。 尽管虚拟机未把lock和unlock操作直接开始给用户使用，但却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性 可见性(Visibility) ：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传媒介质的方式来实现可见性的。 volatile 保证了多线程操作时变量的可见性。除此之外，Java还有两个关键字能实现可见性，即 synchronized 和 final 。 synchronized同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的 final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去，那在其他线程中就能看见final字段的值。 有序性(Ordering) ：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”(Within-Thread As-If-Serial Semantics)，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。 Java语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性， volatile关键字本身就包含了禁止指令重排序的语义， 而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条原则决定了持有同一个锁的两个同步块只能串行地进入。 synchronized万能的优缺点： 优点：用起来方便 缺点：越方便越大的性能损耗 先行发生原则 下面是Java内存模型下一些“天然的”先行发生关系，无须任何同步手段： 程序次序规则(Program Order Rule) ：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生与书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。 volatile变量规则(Volatile Variable Rule)：对一个volatile变量的 写操作 先行发生于后面对这个变量的 读操作 。 线程启动规则(Thread Start Rule) ：Thread对象的 start() 方法先行发生于此线程的每一个动作。 线程终止规则(Thread Termination Rule) ：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。 线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。 对象终结规则(Finalizer Rule)：一个对象的初始化完成（构造函数执行结束）先行发生与它的finalize()方法的开始。 传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生与操作C的结论。 结论：“时间上先发生”与“先行发生”之间没有太大的关系 一切以先行发生原则进行 Java与线程线程的实现 线程是比进程更加轻量级的调度单位 各个线程既可以共享进度资源（内存地址、文件I/O等），又可以独立调度（ 线程是CPU调度的基本单位 ） 每个执行了start()的且还没有结束的Thread类的实例就代表了一个线程（所有方法都是Native的） Java API中Native方法往往需要结合平台先关的技术 实现线程主要有3种方式： 使用 内核线程 实现 使用 用户线程 实现 使用 用户线程加轻量级进程混合实现。 使用内核线程实现 内核线程(Kernel-Level Thread,KLT)就是直接由操作系统内核(Kernel)支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器(Scheduler)对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视作内核的一个分身，支持多线程的内核就叫做多线程内核(Multil-Threads Kernel)。 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process, LWP)，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。 局限性： 代价高：由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态(User Mode)和内核态(Kernel Mode)中来回切换。 数量有限：每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。 使用用户线程实现 用户线程(User Thread)的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也可以支持规模更大的线程数量。 这种进程与用户线程之间1：N的关系称为一对多的线程模型。 优势在于不需要系统内核支援 劣势在与没有系统内核的支援，所有的线程操作都需要用户程序自己处理。 Java、Ruby等语言都曾经使用过用户线程，最终又都放弃使用它。 使用用户线程加轻量级进程混合实现 用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的 轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。 用户线程与轻量级进程的数量比是不定的，即为N:M的关系，称为多对多的线程模型。 Java线程的实现 基于操作系统原生线程模型： 对于Sun JDK来说，它的Windows版与Linux版都是使用 一对一的线程模型 实现的，一条Java线程就映射到一条轻量级进程之中。 而在Solaris平台中，同时支持一对一和多对多。 Java线程调度 线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是 协同式线程调度(Cooperative Threads-Scheduling)和 抢占式线程调度(Preemptive Threads-Scheduling) 协同式调度：线程的执行时间由线程本身来控制 ，线程把自己的工作执行完了之后，要主动通知系统切换到另一个线程上。实现简单，没有线程同步问题，但线程执行时间不可控制，可能导致阻塞。Lua语言的“协同例程”就是这类实现。 抢占式调度：每个线程将由系统来分配执行时间 ，线程的切换不由线程本身来决定（在Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。线程的执行时间可控，也不会有一个线程导致整个进程阻塞的问题。 Java使用抢占式调度。 Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两个线程同时处于Ready状态 时，优先级越高的线程越容易被系统选择执行。 并不是很靠谱，操作系统的优先级不一定是10个，就无法一一对应，再者，优先级可能会被系统自动改变。 状态转换 Java语言定义了5种线程状态（与操作系统定义的线程状态有所不同），在任意一个时间点，一个线程只能有且只有其中的一种状态。 新建(New) ：创建后尚未启动的线程处于这种状态。 运行(Runable) ：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。 无限期等待(Waiting) ：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显示地唤醒 。以下方法会让线程陷入无限期的等待状态： 没有设置Timeout参数的Object.wait()方法 没有设置Timeout参数的Thread.join()方法 LockSupport.park()方法 限期等待(Timed Waiting) ：处于这种状态的线程 也不会 被分配CPU执行时间，不过在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态： Thread.sleep()方法 设置了Timeout参数的Object.wait()方法 设置了Timeout参数的Thread.join()方法 LockSupport.parkNamos()方法 LockSupport.parkUntil()方法 阻塞(Blocked) :线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁。这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。 在程序等待进入同步区域的时候，线程将进入这种状态。 结束(Terminated) ：已终止线程的线程状态，线程已经结束执行。]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷33]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B733%2F</url>
    <content type="text"><![CDATA[Find Peak ElementA peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: 1234Input: nums = [1,2,3,1]Output: 2Explanation: 3 is a peak element and your function should return the index number 2. Example 2: 12345Input: nums = [1,2,1,3,5,6,4]Output: 1 or 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. Note:Your solution should be in logarithmic complexity. 12345678910111213141516class Solution &#123; public int findPeakElement(int[] nums) &#123; int n = nums.length; int left = 0, right = n-1; while(left&lt;right)&#123; int mid = left + (right-left)/2; if (nums[mid]&lt;nums[mid+1])&#123; left = mid +1; &#125; else&#123; right = mid; &#125; &#125; return left; &#125;&#125; 额。。。说实话自己只能想到暴力破解的方法，但是题目要求是用分治来做，参考了答案中的解法，虽然看着答案的形式很简单，但是其思路还是要好好想才能想通的，额。。。排序题准备之后先看看算法的书再统一练习，之后先不做了。 I find it useful to reason about binary search problems using invariants. While there are many solutions posted here, neither of them provide (in my opinion) a good explanation about why they work. I just spent some time thinking about this and I thought it might be a good idea to share my thoughts.Assume we initialize left = 0, right = nums.length - 1. The invariant I’m using is the following:nums[left - 1] &lt; nums[left] &amp;&amp; nums[right] &gt; nums[right + 1]That basically means that in the current interval we’re looking, [left, right] the function started increasing to left and will eventually decrease at right. The behavior between [left, right] falls into the following 3 categories:nums[left] &gt; nums[left + 1]. From the invariant, nums[left - 1] &lt; nums[left] =&gt; left is a peakThe function is increasing from left to right i.e. nums[left] &lt; nums[left + 1] &lt; .. &lt; nums[right - 1] &lt; nums[right]. From the invariant, nums[right] &gt; nums[right + 1] =&gt; right is a peakthe function increases for a while and then decreases (in which case the point just before it starts decreasing is a peak) e.g. 2 5 6 3 (6 is the point in question)As shown, if the invariant above holds, there is at least a peak between [left, right]. Now we need to show 2 things:I) the invariant is initially true. Since left = 0 and right = nums.length - 1 initially and we know that nums[-1] = nums[nums.length] = -oo, this is obviously trueII) At every step of the loop the invariant gets reestablished. If we consider the code in the loop, we have mid = (left + right) / 2 and the following 2 cases:a) nums[mid] &lt; nums[mid + 1]. It turns out that the interval [mid + 1, right] respects the invariant (nums[mid] &lt; nums[mid + 1] -&gt; part of the cond + nums[right] &gt; nums[right + 1] -&gt; part of the invariant in the previous loop iteration)b) nums[mid] &gt; nums[mid + 1]. Similarly, [left, mid] respects the invariant (nums[left - 1] &lt; nums[left] -&gt; part of the invariant in the previous loop iteration and nums[mid] &gt; nums[mid + 1] -&gt; part of the cond)As a result, the invariant gets reestablished and it will also hold when we exit the loop. In that case we have an interval of length 2 i.e. right = left + 1. If nums[left] &gt; nums[right], using the invariant (nums[left - 1] &lt; nums[left]), we get that left is a peak. Otherwise right is the peak (nums[left] &lt; nums[right] and nums[right] &lt; nums[right + 1] from the invariant).]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机-Chapter6]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Chapter6%2F</url>
    <content type="text"><![CDATA[“代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。” 类文件结构啥是无关性？ JVM不仅具有平台无关性，还具有语言无关性。 平台无关性是指不同操作系统都有各自的JVM。 语言无关性是指Java虚拟机能运行除Java以外的代码！ 无关性的基石 平台无关性的基石：字节码 语言无关性的基础：虚拟机和字节码存储格式 纵观Class文件结构 Class文件是一组以8位字节为基础单位的二进制流；各个数据项目严格按照顺序紧凑排列，中间无任何分隔符；遇到8位字节以上的时候按照高位在前分割。 Class文件采用一种类似C语言结构体的数据结构来存储数据，这种结构体中只有2中数据类型：无符号数和表 无符号数：描述数字，索引引用，数量值或者按照UTF-8编码构成字符串值（u1、u2、u4、u8，分别代表1字节的无符号数…） 表：描述有层次的复合结构的数据（顺序还是数量都是严格限定） 魔数与Class文件版本 每个Class文件头4个字节称为魔数（Magic Number），确定这个文件是否是Class文件，固定为0xCAFEBABE。 紧跟着魔数的4个字节存储了Class的版本号，JDK能向下兼容旧版本的Class文件，但不能向上兼容。 常量池Class文件的资源仓库，与其他项目关联最多的数据类型。 前置了u2类型的常量池容量计数器，很奇葩，从1开始(而不是0) 常量分为两大类： 字面量(Literal) 类似于Java语言的常量，如文本字符串、final值等。 符号引用(Symbolic References) 类和接口的全限定名(Fully Qualified Name) 字段的名称和描述符(Descriptor) 方法的名称和描述符 访问标志是Class类还是接口 是否public 是否abstract 是否final等 类索引、父类索引与接口索引集合都是u2类型 确定了这个类的全限定名 父类的全限定名 接口的全限定名集合 字段表集合字段表用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。 方法表集合与字段表几乎一致，依次包括访问标志、名称索引、描述符索引、属性表集合。 属性表集合在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。 字节码指令简介Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（操作码）以及跟随其后的零至多个代表此操作所需参数（操作数）而构成。 Java虚拟机面向操作数栈而不是寄存器的架构 大多数之类不包含操作数，只有一个操作码 操作码长度为1个字节，即指令集操作码总数不能超过256条 处理超过一个字节的数据时会重建，缺点是导致一定的性能损失，优点是省略很多填充和间隔符号 字节码与数据类型大多指令有对应的数据类型，有特殊字符来助记 指令集被故意设计成非完全独立（要不然操作码不够） 大多数对于boolean,byte,short,char之类的数据操作，实际上都是使用int类型作为运算 加载和存储指令用于数据在栈帧中的局部变量和操作数栈之间来回传输 有一部分是尖括号结尾的表示是一组之类（iload_\&lt;n>） 运算指令用于对两个操作栈上的值进行某种特定运算 大体分为两种（整数型数据&amp;浮点型数据） Java虚拟机没有明确规定数据溢出的具体运算结果 只有除法和求余指令中除数为0时会导致抛出ArithmeticException异常 Java虚拟机要求计算浮点数时，所有运算结果都必须舍入都适当的精度 Java虚拟机要求计算浮点数时，不会抛出任何异常 类型转换指令将两种不同精度的数值类型进行互相转换 宽化类型 int到long,float,double long到float,double float到double 窄化类型 必须显示使用转换指令，而且会造车精度的丢失 对象创建于访问指令操作数栈管理指令控制转移指令方法调用和返回指令异常处理指令Java虚拟机中，处理异常不是由字节码指令来实现的，而是采用异常表来完成 同步指令公有设计和私有设计改进虚拟机的性能，主要是有两种方式： 将输入的java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集 将输入的java虚拟机代码在加载或执行时翻译成宿主CPU的本地指令集（JIT） Class文件结构的发展 Class文件结构一直处于稳定的状态，几乎没有改动 所有对于其的改动都集中在访问标志，属性表这些设计上就可扩展上的内容 Class文件索所具备的平台中立、紧凑、稳定、可扩展的特点，是实现「平台」无关，「语言」无关的重要支柱。]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷32]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B732%2F</url>
    <content type="text"><![CDATA[Kth Largest Element in an ArrayFind the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1:12Input: [3,2,1,5,6,4] and k = 2Output: 5 Example 2: 12Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4 Note:You may assume k is always valid, 1 ≤ k ≤ array’s length. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int n = nums.length; quickSort(nums,0,n-1,n-k); return nums[n-k]; &#125; private void quickSort(int[] nums, int start, int end, int target)&#123; if (start&gt;=end)&#123; return; &#125; int mid = start + (end - start)/2; int pivot = choosePivot(nums[mid], nums[start], nums[end]); int i = start; int j = end; while(i&lt;=j) &#123; while (nums[i] &lt; pivot) &#123; i++; &#125; while (nums[j] &gt; pivot) &#123; j--; &#125; if (i &lt;= j) &#123; if (nums[i] != nums[j]) &#123; swap(nums, i, j); &#125; i++; j--; &#125; &#125; if(target &lt;= i - 1)&#123; quickSort(nums, start, i - 1, target); &#125; else&#123; quickSort(nums, i, end, target); &#125; &#125; private int choosePivot(int a, int b, int c) &#123; if(a &gt; b)&#123; if(c &gt; a)&#123; return a; &#125; else if(c &gt; b)&#123; return c; &#125; else&#123; return b; &#125; &#125; else&#123; if(c &gt; b)&#123; return b; &#125; else if(c &gt; a)&#123; return c; &#125; else&#123; return a; &#125; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 又是一道自尊心备受打击的一道题，题目的基本思路是用快排，然后加以一些剪枝的操作，以及选值的特殊函数，可惜快排都理解了好久，更不提其他的技巧了，明天先搞定快排的特点再说。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷31]]></title>
    <url>%2F2018%2F07%2F24%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B731%2F</url>
    <content type="text"><![CDATA[Top K Frequent ElementsGiven a non-empty array of integers, return the k most frequent elements. 12For example,Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note:You may assume k is always valid, 1 ≤ k ≤ number of unique elements.Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size. 123456789101112131415161718192021222324class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer,Integer&gt; table = new HashMap&lt;&gt;(); List&lt;Integer&gt;[] bukcet = new List[nums.length+1]; for(int n: nums)&#123; table.put(n,table.getOrDefault(n,0)+1); &#125; for(int key: table.keySet())&#123; int fqc = table.get(key); if (bukcet[fqc] == null)&#123; bukcet[fqc] = new ArrayList&lt;&gt;(); &#125; bukcet[fqc].add(key); &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = nums.length; i &gt;= 0 &amp;&amp; res.size()&lt;k; i--) &#123; if (bukcet[i]!=null)&#123; res.addAll(bukcet[i]); &#125; &#125; return res; &#125;&#125; 这道题是参考了别人的解法的。看上去复杂度像是O(n)，但是由于使用了HashMap，其实在操作的时候复杂度是大于O(n)的（之后好好研究一下HashMap的复杂度），其次这个桶排序和我在书中看到的桶排序有着一定的出入，不能算正宗的桶排序。 此处引用一段别人的评论： This is not a normal bucket sort. Normally you will sort inside the buckets when you have bucketed, but in this case the sort is unnecessary since all elements inside the single bucket have the same value (same frequency). Therefore you can simply iterate from the highest frequency to the lowest frequency. You can do this in linear time since you know the frequency for any element must be &lt;= n. As I mentioned in another comment. There is degenerate input for this solution and every other solution which depends on hash maps. The frequencyMap hash map can degenerate to O(n) lookup (making his first loop O(n^2)) if the input causes your hash function to map to the same slot (large amount of collisions). I think in an interview you want to discuss ways to avoid this, e.g. randomly pick from a set of hash functions]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷30]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B730%2F</url>
    <content type="text"><![CDATA[Sort ColorsGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Example: 12Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2] java class Solution { public void sortColors(int[] nums) { int p1 = 0, p2=nums.length-1, index = 0; while(index&lt;=p2){ if (nums[index] == 0){ nums[index] = nums[p1]; nums[p1] = 0; p1++; } else if (nums[index] == 2){ nums[index] = nums[p2]; nums[p2] = 2; p2--; index--; } index++; } } }这道题啊用了双指针的想法，使用p1和p2了来框定上下界，index作为遍历指针，思想不错，把012分为三个区，遍历的时候把2放到最后，0放到最前面，1则不动，对于只有三个数的话的确有效，之后可以考虑大于三个数是不是就是完全不同的做法了呢？需要注意的是当nums[index] == 2是，不能index++，而是要不动，万一换过来的是1，耳之后的数字是0，则会出错。（双指针的思想也是排序题目里经常出现的，之后可以总结归纳一下）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷29]]></title>
    <url>%2F2018%2F07%2F22%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B729%2F</url>
    <content type="text"><![CDATA[MergeGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.Note:The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: 12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 12345678910111213141516171819202122class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int p = m-1; int q = n-1; int k = m+n-1; while(p&gt;=0 &amp;&amp; q&gt;=0)&#123; if (nums1[p]&lt;nums2[q])&#123; nums1[k] = nums2[q]; q--; k--; &#125; else&#123; nums1[k] = nums1[p]; p--; k--; &#125; &#125; for (int i = 0; i &lt; q+1; i++) &#123; nums1[i] = nums2[i]; &#125; &#125;&#125; 1234567891011public class Solution &#123; public void merge(int A[], int m, int B[], int n) &#123; int i = m - 1, j = n - 1, k = m + n - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; A[k--] = A[i] &gt; B[j] ? A[i--] : B[j--]; &#125; while(j &gt;= 0) &#123; A[k--] = B[j--]; &#125; &#125;&#125; 这道题是简单的排序题，思路比较容易想到，用三个指针加while循环快要解决，有一点需要注意，考虑到nums2的指针p可能在nums1的指针q走完之前还没有到位置0，导致有些数据没有写到nums1的开头，故需要nums1[:q+1] = nums2[:q+1]。 此外，在写法上，参考了其他人的写法，可以写的更加凝练，充分利用三目表达式和i–的特性。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机-Chapter7]]></title>
    <url>%2F2018%2F07%2F21%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Chapter7%2F</url>
    <content type="text"><![CDATA[虚拟机类加载机制概述虚拟机的类加载机制：虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。 与那些在编译时需要进行连接工作的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的， 缺点：这种策略会令类加载时稍微增加一些性能开销 优点：为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。 例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；约定： 第一，在实际情况中，后文中直接对「类」的描述都包括了类和接口的可能性，而对于类和接口需要分开描述的场景会特别指明； 第二，「Class 文件」并非特指某个存在于具体磁盘中的文件，这里所说的「Class 文件」应当是一串二进制的字节流，无论以何种形式存在都可以。 类加载的时机七个阶段: 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的 解析阶段则不一定,它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定） 注意，这里说的是按部就班地「开始」，这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。也就是说可能有些阶段未完成，下一个阶段就开始了。 对于初始化阶段，虚拟机规范严格规定了有且只有 5 种情况必须立即对类进行「初始化」（而加载、验证、准备自然需要在此之前开始）： 遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 生成这 4 条指令的最常见的 Java 代码场景是： 使用 new 关键字实例化对象的时候、 读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候， 以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个类），虚拟机会先初始化这个主类。 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 主动引用：以上 5 种场景中的行为称为对一个类进行主动引用。 被动引用：除了以上 5 种场景中的行为以外的对一个进行引用的行为。 类加载的过程加载在加载阶段，虚拟机需要完成以下 3 件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。 虚拟机规范的这3点要求其实并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。 一个非数组类的加载阶段，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的 loadClass()方法）。 准确地说，是加载阶段中获取类的二进制字节流的动作是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成 对于数组类而言，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。 一个数组类（下面简称为 C）创建过程就遵循以下规则： 如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（一个类必须与类加载器一起确定唯一性） 如果数组的组件类型不是引用类型（例如 int[] 数组），Java 虚拟机将会把数组 C 标记为与引导类加载器关联。数组类的可见性与它的组件类型的可见性一致， 如果组件类型不是引用类型，那数组类的可见性将默认为 public。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象 Class 对象比较特殊，它虽然是对象，但是存放在方法区里面 加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，这两个阶段的开始时间仍然保持着固定的先后顺序。 验证为什么需要验证？ 验证是虚拟机对自身保护的一项重要工作。 验证什么？ 文件格式验证(保证输入的字节流能正确地解析并存储于方法区之内) 是否以魔数 0xCAFEBABE 开头。 主、次版本号是否在当前虚拟机处理范围之内。 常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）。 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 …… 元数据验证(保证其描述的信息符合 Java 语言规范的要求) 这个类是否有父类（除了 java.lang.Object 之外，所有的类都应当有父类）。 这个类的父类是否继承了不允许被继承的类（被 final 修饰的类）。 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。即，非抽象类是否实现了所有应该实现的方法. 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。 字节码验证(保证被校验类的方法在运行时不会做出危害虚拟机安全的事件) 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。 保证跳转指令不会跳到方法体意外的字节码指令上。 保证方法体中的类型转换是有效的。 如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。 离散数学中一个很著名的问题「Halting Problem」（停机问题） ：通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。 符号引用验证(将符号引用转化为直接引用的时候,对类自身以外的信息进行匹配性校验) 符号引用中通过字符串描述的全限定名是否能找到对应的类。 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的*方法和字段。 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 首先，这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量(实例变量将会在对象实例化时随着对象一起分配在 Java 堆中) 其次，这里所说的初始值「通常情况」下是数据类型的零值,这时候尚未开始执行任何 Java 方法。public static final int value=123； 「通常情况」:public static final int value=123；那变量在准备阶段过后的初始值是0而不是123 「特殊情况」:public static final int value=123；那么在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123(如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值) 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 符号引用于虚拟机实现的内存布局无关 直接引用是和虚拟机实现的内存布局相关的 如果有了直接引用，那引用的目标必定已经在内存中存在。 对同一个符号进行多次解析请求时很常见的事情，除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存，从而避免解析重复 对于invokedynamic指令，则不然。指令的目的本来就是用于动态语言支持，它所对应的引用称为「动态调用点限定符」（Dynamic Call Site Specifier） 「动态」的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。 「静态」是指可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。 类或接口的解析字段解析类方法解析接口方法解析类加载器类加载器是Java的一大创新，也是其流行的原因之一，最初是为Applet需要开发，现在却在类层次划分，OSGi，热部署，代码加密等领域大放异彩。 类与类加载器如何比较两个类相等？ 类本身是不是相等 类加载器是不是相等 双亲委派模型 从Java虚拟机的角度来讲，只存在两种不同的类加载器： 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现 ，是虚拟机自身的一部分； 另一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度来看，绝大部分Java程序都会使用到以下3种系统提供的类加载器。 启动类加载器（Bootstrap ClassLoader）：启动类无法直接被用户使用，只能通过子类返回 null 来间接调用。 扩展类加载器（Extension ClassLoader）：开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）：负责加载用户路径上所指定类库，可以直接被开发者使用。 该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。 此处的父子关系通常不会通过 继承 关系来实现，而是选择组合关系来复用父加载器的代码 工作过程：当一个类加载器收到了类加载的请求时，它不是自己加载，而是将这个请求委派给父类加载器去完成，每一层的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成该请求时，子加载器才会尝试自己去加载。 好处： Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。 保证 java 核心库的安全性（例如：如果用户自己写了一个 java.lang.String 类就会因为双亲委派机制不能被加载，不会破坏原生的 String 类的加载） 「破坏」双亲委派模型双亲委派模型并不是一个强制性的约束模型。 双亲委派模型的第一次「被破坏」其实发生在双亲委派模型出现之前——即 JDK 1.2 发布之前。 双亲委派模型的第二次「被破坏」是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载）基础类之所以称为「基础」，是因为它们总是作为被用户代码调用的 API，但是基础类调用回用户的代码不容易（用回调不行？？）一个典型的例子便是 JNDI 服务 双亲委派模型的第三次「被破坏」是由于用户对程序动态性的追求而导致的，这里所说的「动态性」指的是当前一些非常「热门」的名词：代码热替换（HotSwap）、模块热部署（HotDeployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、U 盘，不用重启机器就能立即使用。热插拔？ 在 OSGi 环境下，类加载器不再是双亲委派模型中的「树状结构」，而是进一步发展为更加复杂的「网状结构」，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索： 将以 java.*开头的类委派给父类加载器加载。 否则，将委派列表名单内的类委派给父类加载器加载。 否则，将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载。 否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。 否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。 否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。 否则，类查找失败。]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷28]]></title>
    <url>%2F2018%2F07%2F21%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B728%2F</url>
    <content type="text"><![CDATA[今天做了一道二分查找的简单题，发现二分虽然原理简单，但是有不少坑，在此记录一下，先看题目： First Bad VersionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: 1234567Given n = 5, and version = 4 is the first bad version.call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. 12345678910111213141516171819public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int left = 1; int right = n; while(left&lt;=right)&#123; //int mid = left + ((right - left) &gt;&gt; 1);//用移位的写法 int mid = left + (right-left)/2;// 避免整数加法溢出 //int mid = (left + right)/2;//可能有加法溢出风险 if (isBadVersion(mid))&#123; right = mid - 1; &#125; else&#123; left = mid + 1; &#125; &#125; return left; &#125;&#125; 题目思路简单，没什么好说的，就是二分，下面说说二分的陷阱有哪些。 第一点：上述代码的问题就出在int mid = (left + right)/2，这句可能导致整数溢出，此时该方法就会抛出数组越界的异常。这个是我遇到的第一个坑。 第二点：while循环里面为什么取等号？具体一点就是，如果令 high = n - 1 (n是数组长度)，则 while 的循环条件为 low &lt;= high，从而更新右边界位置的时候为 high = mid - 1；而如果令 high = n，则 while 循环的循环条件为 left &lt; right，从而更新右边界位置的时候为 high = mid。同时，mid 的计算不能写在循环外，否则无法得到更新。 第三点：JDK本身对于除2的运算都是以位运算&gt;&gt;1来代替的，是不是效果更好，查了网上的资料后发现的确效率更高。 总结一下，二分查找大的方面需要注意三点： mid 赋值问题，注意溢出情况。 判断 while 循环体是否终止的语句的编写 边界值 left, right 和区间值这三个地方要保持一致 位运算代替除法，效率更高]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷27]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B727%2F</url>
    <content type="text"><![CDATA[Gas StationThere are N gas stations along a circular route, where the amount of gas at station i is gas[i].You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note: If there exists a solution, it is guaranteed to be unique.Both input arrays are non-empty and have the same length.Each element in the input arrays is a non-negative integer. Example 1: 1234Input: gas = [1,2,3,4,5]cost = [3,4,5,1,2]Output: 3 Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 4. Your tank = 4 - 1 + 5 = 8Travel to station 0. Your tank = 8 - 2 + 1 = 7Travel to station 1. Your tank = 7 - 3 + 2 = 6Travel to station 2. Your tank = 6 - 4 + 3 = 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index. Example 2: 1234Input: gas = [2,3,4]cost = [3,4,3]Output: -1 Explanation:You can’t start at station 0 or 1, as there is not enough gas to travel to the next station.Let’s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 0. Your tank = 4 - 3 + 2 = 3Travel to station 1. Your tank = 3 - 3 + 3 = 3You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.Therefore, you can’t travel around the circuit once no matter where you start. 123456789101112131415161718192021222324252627class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int sum_gas = 0; int sum_cost = 0; int n = gas.length; for (int i = 0; i &lt; n; i++) &#123; sum_gas = sum_gas + gas[i]; sum_cost = sum_cost + cost[i]; &#125; if (sum_gas &lt; sum_cost)&#123; return -1; &#125; int start = 0; int curr = 0; for (int i = 0; i &lt; n; i++) &#123; int diff = gas[i] - cost[i]; if (curr+diff&gt;=0)&#123; curr = curr + diff; &#125; else&#123; curr = 0; start = i + 1; &#125; &#125; return start; &#125;&#125; 贪心的题，总是容易陷入做dp的思路去，自己的总体思路是对的，先求差值diff，然后找差值数组里的最大子序列，但是这就变成了dp了，而且循环的部分不好处理，可能要多写一个循环，这道题简单点的话，就安排一次循环，然后检测diff+curr的值会不会小于0，小于就重置参数再来，但是你可能会有疑虑，这样不是不能循环检测了吗，由于这道题说如果可以就只有一种解法，所以这样子做没问题。纵使要顺时针，也能找到相应的数字。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷26]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B726%2F</url>
    <content type="text"><![CDATA[做了一道贪心的题，一开始用动态规划的思想做，感觉走了弯路，一般能用贪心解决的题都可以用复杂一点的DP来做，我就是做了这个复杂的DP。 Jump Game IIGiven an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.Your goal is to reach the last index in the minimum number of jumps.Example:1234Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2.Jump 1 step from index 0 to 1, then 3 steps to the last index. Note:You can assume that you can always reach the last index. 123456789101112131415class Solution &#123; public int jump(int[] A) &#123; int sc = 0; int e = 0; int max = 0; for(int i=0; i&lt;A.length-1; i++) &#123; max = Math.max(max, i+A[i]); if( i == e ) &#123; sc++; e = max; &#125; &#125; return sc; &#125;&#125; 由于这道题说了，一定能到达目标的，所以反过来考虑，对于nums中的每个数字，其位置i加上值nums[i]最大的就一定是终点了，再反推，子问题同样满足这个条件，即可以说局部最优解同时是全体最优解。即贪心选择性，相比于dp少了子问题重叠性。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机-Chapter3]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Chapter3%2F</url>
    <content type="text"><![CDATA[垃圾收集器与内存分配策略 主要思考的问题: 标记-那些内存(那些死,那些活着)需要回收? 什么时候回收? 如何回收? 内存部分分类 线程独有：程序计数器，虚拟机栈，本地方法栈 线程共享：堆，方法区 标记概要标记算法 引用计数法(不能用): 每当一个地方引用它时,计数器+1,引用失效时,计数器-1,任何时刻计数器为0的对象就是不可能在被使用 java没有用最主要的原因很难解决对象之间互相循环引用的问题; 1234567891011public class ReferenceCountingGC &#123; public Object instance=null; public static void main(String[] args) &#123; ReferenceCountingGC objA= new ReferenceCountingGC(); ReferenceCountingGC objB= new ReferenceCountingGC(); objA.instance=objB; objB.instance=objA; objA=null; objB=null; &#125;&#125; 可达性分析算法:当一个对象到GC Roots没有任何引用链相连的话，则证明该对象是不可用的 Java 语言中,可作为GC Roots的对象包括下面几种; 虚拟机栈中(栈帧中的本地变量表)的引用对象 方法区中类静态属性引用对象 方法区中类常量引用对象 本地方法栈JNI引用的对象 再谈引用 目标：描述“鸡肋”引用，即内存足够时保留，不足时抛弃 引用分为四种 强,软,弱,虚四种 强度依次减弱 强引用:类似Object obj=new Object() 这类引用,只要强引用还在,垃圾收集器就永远不会回收被引用的对象; 软引用:用来描述一些还有用但并未必须的对象。内存溢出异常之前,会把这些对象列入回收范围之内进行二次回收。如果回收后还没有足够的内存这回OOM; 弱引用:用来描述非必须的对象。若引用关联的对象只能活到下一次垃圾回收之前; 虚引用:唯一目的对象被回收时收到一个系统通知 不可达对象的最后历程 总结:finalize()方法不执行或者只能执行一次 不可达对象,也并非”非死不可” 这时候是在缓刑阶段。要真正宣告死亡,至少要经理两次标记过程。 如果对象进行可达性分析后发现没有GC Roots相关联的引用链,会被第一次标记并且进行一次筛选,筛选条件是此对象是否有必要执行finalize()方法。 对象没有覆盖finalize方法(逃脱命运的最后机会),或者finalize()方法被虚拟机掉用过(只能执行一次),虚拟机将这两种情况都视为”没有必要执行” 如果被判定有必要执行,那么对象会放置叫一个F-Queue的队列之中,并且稍后虚拟机自动建立Finalize线程去执行它既finalize方法 但并不承诺会等待他运行结束,怕死循环或者运行缓慢。finalize方法是逃脱命运的最后机会,如果没有逃脱就真的被回收了 回收方法区（又叫HotSpot中的永久代） 永久代回收“性价比”低 永久代回收：废弃常量和无用的类 什么是无用的类？ 无所有实例 无加载该类的ClassLoader 无该类的引用包括反射 啥时候需要？ 大量使用反射，动态代理 CGLib等ByteCode框架 动态生成JSP以及OSGi 总之就是需要频繁自定义ClassLoader的场景 垃圾收集算法标记-清除算法(基础算法,剩下的都是基于它的不足而进行改进的)标记:标记所有需要回收的对象 清除:统一回收所有被标记的对象 不足1:效率问题,标记和清除效率都不高; 不足2:空间问题,产生大量的不连续的内存碎片 复制算法内存容量划分两个大小相等的两块,每次使用其中的一块。这块用完了复制存活的对象到另一块,在把这块清理掉 不足:代价太高 把内存缩小为原来的一半; 现代的商用虚拟街都采用这种算法来回收新生代; 因为新生代都是朝生暮死,所以不需要1:1来划分,而将内存分为一块较大的Eden 和两个较小的Survivor,默认大小比;8:1, 每次新生代中可用的内存空间是整个新生代容量的90=(Eden+Survivor),“浪费” 10 因为没办法保证回收只有不多于10的存活,Survivor空间不够需要老年代进行担保; 标记-整理(Mark-Compact)算法(老年代常用)标记和以前一样,后续步骤不是直接回收,而是存活对象向一端移动,然后清理边界以外的内存 分代收集根据对象存活周期将内存划分不同的几块。一般堆分为 新生代 和老年代。这样根据年代的特点采用最适当的收集算法 新生代:少量存活 选择复制算法 老年代:存活率高,没有额外空间担保,必须使用 标记清理 或者标记整理; HotSpot的算法实现枚举根节点可达性分析必须在一个能确保一致性的快照中进行，这导致GC进行时必须停顿所有Java执行线程(Sun称为“Stop-The-World”)。CMS收集器中，枚举根节点时也是必须要停顿的。 一致性：整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可能出现分析过程中对象引用关系还在不断变化的情况，该点不满足就无法保证分析结果准确性 由于目前的主流Java虚拟机使用的都是精准式GC，在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内对应偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。 准确式GC：就是让JVM知道内存中某位置数据的类型什么。比如当前内存位置中的数据究竟是一个整型变量还是一个引用类型。这样JVM可以很快确定所有引用类型的位置，从而更有针对性的进行GC roots枚举。 安全点 GC会产生停顿(Sun也叫它 “Stop The World”),OoMap 存放着GC Roots,不是每条指令都生成一个。不是任何时都能停下来进行 GC ,只有在 “特定的位置” 才可以GC 这个位置也叫安全点(Safepoint)安全点的选定基本上是以程序”是否具有让程序长时间执行的特征”为标准选定的 关于安全点另一个需要考虑的就是如何在GC发生的时让所有线程都”跑”到最近的安全点上在停下来;有两种方案 抢先式中断(Preemptive Suspension)(现在几乎都这种方案):不需要线程的执行代码主动配合,GC发生时候先把线程全部中断,如果有线程不在安全点,就回复线程让它跑到安全点。 主动式中断(Voluntary Suspension):当GC需要中断线程的时候,不对线程造作,仅仅简单地设置一个标志位,各个线程执行的时候主动去轮询这个标志位,发现中断标志位真就挂起,轮询标志的地方安全点重合。而对于不执行的线程,任何时间都是安全的也称为安全区; 安全区域全点的机制似乎已经完美的解决了 “什么时候以及何时开始 GC” 的问题，但是实际情况并非如此；安全点机制仅仅是保证了程序执行时不需要太长时间就可以进入一个安全点进行 GC 动作，但是当特殊情况时，比如线程休眠、线程阻塞等状态的情况下，显然 JVM 不可能一直等待被阻塞或休眠的线程正常唤醒执行；此时就引入了安全区的概念。 安全区(Saferegion)：安全区域是指在一段区域内，对象引用关系等不会发生变化，在此区域内任意位置开始 GC 都是安全的；线程运行时，首先标记自己进入了安全区，然后在这段区域内，如果线程发生了阻塞、休眠等操作，JVM 发起 GC 时将忽略这些处于安全区的线程。当线程再次被唤醒时，首先他会检查是否完成了 GC Roots枚举(或这个GC过程)，然后选择是否继续执行，否则将继续等待 GC 的完成。 垃圾收集器Serial收集器Serial:单线程收集器，在进行垃圾收集时，必须要暂停其他所有的工作线程，直到它收集结束。 需要STW（Stop The World），停顿时间长。 简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。 ParNew收集器ParNew:是Serial的多线程版本，除了使用多线程进行垃圾收集外，其他行为与Serial完全一样 Tips：1.Server模式下虚拟机的首选新生收集器，与CMS进行搭配使用 Parallel Scavenge收集器Parallel Scavenge:目标是达到一个可控制的吞吐量。 吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) 高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务，并且虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应调节策略。 Serial Old收集器Serial Old:老年代的单线程收集器，使用标记 - 整理算法， Parallel Old收集器Parallel Old:老年代的多线程收集器，使用标记 - 整理算法，吞吐量优先，适合于Parallel Scavenge搭配使用 CMS收集器CMS（Conrrurent Mark Sweep）收集器是以获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法，收集过程分为如下四步： 初始标记，标记GCRoots能直接关联到的对象，时间很短。 并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。 并发清除，回收内存空间，时间很长。 三个缺点： 对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。 无法处理浮动垃圾 因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。 会产生大量的内存碎片，不利于大对象的分配 G1收集器 G1收集器因为没有商用的就不写了; 内存分配与回收策略对象优先在Eden分配 三个参数 Xms20M:初始堆 Xmx20M:最大堆 Xmn10M:新生代堆 -XX:SurvivorRation=8: eden:from:to = 8:1:1 GC类型 Minor GC:指发生在新生代的垃圾收集动作，非常频繁，速度较快。 Major GC:指发生在老年代的GC，出现Major GC，经常会伴随一次Minor GC，同时Minor GC也会引起Major GC，一般在GC日志中统称为GC，不频繁。 Full GC:指发生在老年代和新生代的GC，速度很慢，需要Stop The World。 大对象直接进入老年代大对象就是大量连续内存空间的Java对象,典型的就是很长的字符串及数组。并且内存超过虚拟机设置大对象的值 长期存活的对象进入老年代jvm给每个对象定义一个对象年龄计数器。如果eden出生并经过第一次Minor GC后仍然存活并且能被Survivor容纳的话,将被移动到Survivor空间并将对象年龄设为1.对象在Survivor区每”熬过”一次Minor GC则年龄+1,当年龄达到一定程度(默认15岁),下一次将会被晋升老年代。 动态对象年龄判定为了更好的适应内存状况。如果在Survivor空间中相同年龄的所有对象大小的综合大于Survivor的一半,那么大于等于这个年龄的将被一起带入老年代 空间担保分配检查老年代最大可用空间是否大于新生代对象总大小，大于就尝试一次Minor GC，尽管有风险，小于的话并且设置不冒险就要Full GC]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷25]]></title>
    <url>%2F2018%2F07%2F18%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B725%2F</url>
    <content type="text"><![CDATA[Frog JumpA frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones’ positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.If the frog’s last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.Note:The number of stones is ≥ 2 and is &lt; 1,100.Each stone’s position will be a non-negative integer &lt; 231.The first stone’s position is always 0.Example 1:123456789[0,1,3,5,6,8,12,17]There are a total of 8 stones.The first stone at the 0th unit, second stone at the 1st unit,third stone at the 3rd unit, and so on...The last stone at the 17th unit.Return true. The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone. Example 2:123[0,1,2,3,4,8,9,11]Return false. There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large. 123456789101112131415161718192021222324class Solution &#123; public boolean canCross(int[] stones) &#123; int n = stones.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; if (i&gt;3 &amp;&amp; stones[i]&gt;2*stones[i-1])&#123; return false; &#125; set.add(stones[i]); &#125; return canReach(0,0, stones[n-1], set); &#125; public boolean canReach(int pos, int step, int last, Set&lt;Integer&gt; set) &#123; if (pos == last)&#123; return true; &#125; for (int i = step+1; i &gt;= step-1 ; i--)&#123; if (i&gt;0 &amp;&amp; set.contains(pos+i) &amp;&amp; canReach(pos+i,i,last,set))&#123; return true; &#125; &#125; return false; &#125;&#125; 这道题有点怪，不像是动态规划，因为是自底向上的，也不带备忘录，只能说想动态规划的递归解法，我感觉可以称为纯DFS解法。这道题给我的理解是，递归的地方要从有确定性的地方发散出去，还有就是递归函数的参数表要考虑清楚，这边其实也没必要保存step的数组，因为之和前后两个有关，可以发散出去。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷24]]></title>
    <url>%2F2018%2F07%2F17%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B724%2F</url>
    <content type="text"><![CDATA[Maximum Length of Repeated SubarrayGiven two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.Example 1:1234Input:A: [1,2,3,2,1]B: [3,2,1,4,7]Output: 3 Explanation:The repeated subarray with maximum length is [3, 2, 1].Note: 1&lt;= len(A), len(B) &lt;= 1000 0&lt;= A[i], B[i] &lt; 100 1234567891011121314151617181920public class Solution &#123; public int findLength(int[] A, int[] B) &#123; int max = 0; int m = A.length; int n = B.length; int dp[] = new int[m+1]; for (int i = 0; i &lt; m; i++) &#123; for (int j = n; j &gt;= 1; j--) &#123; if (A[i] == B[j-1])&#123; dp[j] = dp[j-1] +1; max = Math.max(max,dp[j]); &#125; else&#123; dp[j] = 0; &#125; &#125; &#125; return max; &#125;&#125; 这道题难得不是逻辑，难得是把第二个for循环倒过来减少了复杂度，一般的想法是用m*n的存储复杂度，单实际上光m或者n就可以了，二维数组可以保持详细的信息，但是如果不涉及其他操作的话可以不要，最大值的数据还是存在着的。这里详细的解释如下：123456789101112public int findLength(int[] A, int[] B) &#123; int n = A.length, m = B.length, max = 0; int[][] dp = new int[n+1][m+1]; for(int i = 1; i &lt;= n; i++) for(int j = 1; j&lt;= m; j++) &#123; if (A[i-1] == B[j-1]) &#123; dp[i][j] = dp[i-1][j-1] + 1; max = Math.max(max, dp[i][j]); &#125; &#125; return max;&#125; If you look at the only line that updates/changes array dp’s value:dp[i][j] = dp[i-1][j-1] + 1;The value of dp[i][j] depends only on the value of dp[i-1][j-1]. If we replace the 2D array with 1D array, dp[j-1] should hold the value of dp[i-1][j-1] in the 2D version. If we loop from 1 -&gt; m, we calculate dp[j-1] before dp[j], dp[j-1] is actually the value of dp[i][j-1] in the 2D version. if we do dp[j] = dp[j-1] + 1, it is actually dp[i][j] = dp[i][j-1] + 1, not dp[i][j] = dp[i-1][j-1] + 1 in the 2D version. But if we loop backwards, that is from m -&gt; 1, dp[j] is calculated before dp[j-1] which still holds the value of dp[i-1][j-1] in the 2D version. After dp[j] is calculated, we don’t need dp[i-1][j-1] any more. It can be used to calculate value of dp[i][j-1]. Another note is, you must set dp[j] = 0 if A[i-1] != B[j-1]. Because, remember we reuse dp[j] to hold the value of dp[i][j]. If it is not reset, it still holds the value of dp[i-1][j] which may not be zero. Hope that will help. - tips:要是见到dp[i][j] = dp[i-1][j-1] + 1;就有机会缩减空间复杂度]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷23]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B723%2F</url>
    <content type="text"><![CDATA[这道题和昨天的一样，用的是带备忘录的自顶向下的动态规划解法，这类题目一般比较难理解。 Burst BalloonsGiven n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] nums[i] nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.Find the maximum coins you can collect by bursting the balloons wisely.Note:You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100Example:1234Input: [3,1,5,8]Output: 167 Explanation: nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int maxCoins(int[] nums) &#123; int n = nums.length; Integer[][] dp = new Integer[n][n]; return maxCoins(nums, 0,n-1,dp); &#125; private int maxCoins(int[] nums, int start, int end, Integer[][] dp) &#123; int res = 0; int n = nums.length; /* * 设置两边的边界条件 * */ int left = start == 0 ? 1 : nums[start-1]; int right = end == n-1 ? 1 : nums[end+1]; /* * 最底层的返回，结束条件 * */ if (start&gt;end)&#123; return 0; &#125; /* * 备忘录 * */ if (dp[start][end] != null)&#123; return dp[start][end]; &#125; /* * 核心的状态转移方程 * */ for (int i = start; i &lt;= end; i++) &#123; res = Math.max(res,left*nums[i]*right+maxCoins(nums,start,i-1,dp)+maxCoins(nums,i+1,end,dp)); &#125; dp[start][end] = res; return res; &#125;&#125; 带备忘录的自顶向下的动态规划注意几点： 备忘录的数组 底部返回数据 核心的状态转移方程这道题难的是理解，其实做完后还是有点不能理解，看来解释后发现要从逆向去理解，从最后状态去逆推。但是超过2层我就无法理解了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷22]]></title>
    <url>%2F2018%2F07%2F15%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B722%2F</url>
    <content type="text"><![CDATA[Best Time to Buy and Sell Stock with CooldownSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)Example:123Input: [1,2,3,0,2]Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] 123456789101112131415161718class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) return 0; int max = 0, n = prices.length; int[] sell = new int[n]; int[] cooldown = new int[n]; for (int i = 1; i &lt; n; i++) &#123; cooldown[i] = Math.max(cooldown[i - 1], sell[i - 1]); for (int j = 0; j &lt; i; j++) &#123; if (j == 0) sell[i] = Math.max(sell[i], prices[i] - prices[j]); else sell[i] = Math.max(sell[i], cooldown[j - 1] + prices[i] - prices[j]); &#125; max = Math.max(max, cooldown[i]); max = Math.max(max, sell[i]); &#125; return max; &#125;&#125; 1234567891011121314151617class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) return 0; int max = 0, n = prices.length; int[] sell = new int[n]; int[] cooldown = new int[n]; int diff = -prices[0]; for (int i = 1; i &lt; n; i++) &#123; cooldown[i] = Math.max(cooldown[i - 1], sell[i - 1]); sell[i] = Math.max(sell[i], prices[i] + diff); diff = Math.max(diff, cooldown[i - 1] - prices[i]); max = Math.max(max, cooldown[i]); max = Math.max(max, sell[i]); &#125; return max; &#125;&#125; 12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) return 0; int max = 0, n = prices.length; int cooldown = 0; int sell = 0; int diff = -prices[0]; for (int i = 1; i &lt; n; i++) &#123; int temp = cooldown; cooldown = Math.max(temp,sell); sell = Math.max(sell,prices[i] + diff); diff = Math.max(diff, temp - prices[i]); max = Math.max(max,cooldown); max = Math.max(max,sell); &#125; return max; &#125;&#125; 之前总结出的动态规划转移方程的两点: 走棋盘（之前2次状态的相加） 硬币加一（之前的状态加1比较）这次出的这道自己又没有做出来，是状态间max比较的，我称之为max型，参考了一个很好的解法，一步步写了3个解法，最后击败了100%是的全球用户。解法一第一个程序最好理解，维护了sell[]和cooldown[]两个数组，不需要buy[]数组，因为最后肯定是要卖掉的。 转移方程1：cooldown[i] = Math.max(cooldown[i - 1], sell[i - 1]) 转移方程2：sell[i] = Math.max(sell[i], cooldown[j - 1] + prices[i] - prices[j]);解法二解法二在一的基础上去掉了第二个for循环，因为第二个for循环找的是cooldown[j - 1] - prices[j]，这个式子可以单独提出来，在第一个循环里面找，还有就是对于特殊情况从头找起的设置，即初始化diff为-prices[0]。解法三在解法二的基础上还可以再优化，因为用到的比较的变量只涉及cooldown的i与i-1前后，而sell更是只有自身的大小比较，故去掉sell的数组。cooldown也可以去掉数组，只留下一个变量，在循环中加一个临时变量temp可以解决前后比较的问题。 tips:若是涉及到i和i-1和i-2的话，用pre和curr两个变量即可（），因为等号前后的变量本省就代表了i和i-1的状态12345money[i] = Math.max(nums[i]+money[i-2],money[i-1]);int tmp = curr;curr = Math.max(prev + n, curr);prev = tmp;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷21]]></title>
    <url>%2F2018%2F07%2F14%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B721%2F</url>
    <content type="text"><![CDATA[真的是做的欲仙欲死，估计做了有2个小时。Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.Note:The same word in the dictionary may be reused multiple times in the segmentation.You may assume the dictionary does not contain duplicate words.Example 1:12345678Input:s = "catsanddog"wordDict = ["cat", "cats", "and", "sand", "dog"]Output:[ "cats and dog", "cat sand dog"] Example 2:12345678910Input:s = "pineapplepenapple"wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]Output:[ "pine apple pen apple", "pineapple pen apple", "pine applepen apple"]Explanation: Note that you are allowed to reuse a dictionary word. Example 3:12345Input:s = "catsandog"wordDict = ["cats", "dog", "sand", "and", "cat"]Output:[] 12345678910111213141516171819202122class Solution &#123; public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123; return dfs(s, wordDict, new HashMap&lt;Integer, List&lt;String&gt;&gt;(), 0); &#125; private List&lt;String&gt; dfs(String s, List&lt;String&gt; dict, Map&lt;Integer, List&lt;String&gt;&gt; map, int start) &#123; if (map.containsKey(start)) return map.get(start); List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (s.length() == start)&#123; res.add(""); return res; &#125; for (String word : dict) &#123; if (s.startsWith(word, start)) &#123; List&lt;String&gt; sublist = dfs(s, dict, map, start+word.length()); for(String n : sublist) res.add(word+(n.length() == 0 ? "":" ")+n); &#125; &#125; map.put(start, res); return res; &#125;&#125; 感受到了hard的为威力了，之前做Word Break的时候用dp的效果很好，想当然的觉得Word Break II也适合用dp做，但是学习了别人的方法AC之后，效果不好，看来前面的几个算法，都是用dfs做的，自己也尝试了一下排名第二的DFS，不得不说，理解就花了半小时多，最后大概看懂后，自己写了一遍，发现其中的细节和技巧很妙，希望自己以后有朝一日也能自己写出这样的代码。主要有三个return要解释一下： 第一个是剪枝用的 第二个是判断DFS结束用的 第三个是正常DFS寻找过程中用的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷20]]></title>
    <url>%2F2018%2F07%2F14%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B720%2F</url>
    <content type="text"><![CDATA[Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.Note:The same word in the dictionary may be reused multiple times in the segmentation.You may assume the dictionary does not contain duplicate words.Example 1:123Input: s = "leetcode", wordDict = ["leet", "code"]Output: trueExplanation: Return true because "leetcode" can be segmented as "leet code". Example 2:1234Input: s = "applepenapple", wordDict = ["apple", "pen"]Output: trueExplanation: Return true because "applepenapple" can be segmented as "apple pen apple". Note that you are allowed to reuse a dictionary word. Example 3:12Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]Output: false 123456789101112131415161718class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; if (s == null || s.length() == 0) return false; int n = s.length(); boolean[] dp = new boolean[n]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; String sub = s.substring(j,i+1); if (wordDict.contains(sub) &amp;&amp; (j==0 || dp[j-1]))&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[n-1]; &#125;&#125; 1234567891011121314151617181920212223class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; if (s == null || s.length() == 0) return false; int n = s.length(); boolean[] dp = new boolean[n+1]; dp[0] = true; int longestLen = 0; for (String word : wordDict) &#123; if (word.length() &gt; longestLen) &#123; longestLen = word.length(); &#125; &#125; for (int i = 0; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= longestLen; j++) &#123; if (i&gt;=j &amp;&amp; dp[i-j]==true &amp;&amp; wordDict.contains(s.substring(i-j,i)))&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[n]; &#125;&#125; 脑子有点断路，这道题看了其他人的方案做出来的，不过还是自己是看懂了，然后自己写出来，这道题有一个关键点，就是在每次在确定下一个单词算是否存在时要检测上一个单词是否存在，关键是j==0 || dp[j-1]这句话。不过提交后发现效率不是最高的，看了比较高的方案后知道，在两次for循环的时候，第二个for循环还可以优化，具体原因是因为worddict的单词长度一般是小于s的长度的，所以做一下限定，找出单词表worddict单词长度的最大值作为上限。最后在LeetCode上打败了99.6%的全球用户（斜眼笑）。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷19]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B719%2F</url>
    <content type="text"><![CDATA[Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.Example 1:123Input: n = 12Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2:123Input: n = 13Output: 2Explanation: 13 = 4 + 9. 123456789101112131415161718192021222324252627class Solution &#123; public int numSquares(int n) &#123; int maxSquare = 1; int lastSquare = 1; int[] res = new int[n+1]; res[0] = 0; for (int i = 1; i &lt; n+1; i++) &#123; if (isPerfectSquare(i) == true)&#123; res[i] = 1; lastSquare = maxSquare; maxSquare = i; &#125; else&#123; res[i] = Math.min(res[i-maxSquare]+1, res[i-lastSquare]+1); &#125; &#125; return res[n]; &#125; public static boolean isPerfectSquare(int num) &#123; int i = 1; while (num &gt; 0) &#123; num -= i; i += 2; &#125; return num == 0; &#125;&#125; 1234567891011121314public class Solution &#123; public int numSquares(int n) &#123; int[] res = new int[n+1]; res[0] = 0; for (int i = 1; i &lt; n+1; i++) &#123; int min = Integer.MAX_VALUE; for (int j = 1; j &lt;= Math.sqrt(i); j++) &#123; min = Math.min(res[i-j*j]+1,min); &#125; res[i] = min; &#125; return res[n]; &#125;&#125; 上面的是自己写的，对于平方数的判断额外使用了一个静态函数，有点傻，而且没有解决多种平方数情况下的最小值问题。第二种方法是参考了网上的做法，巧妙的解决了平方数的问题，而且设立了min变量用来存储同一个i减去不同完美平方数后的最小值问题（比如12-9与12-4还是12-4的值更小）。这道题后面还可以用BFS等方法做，之后留意。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷18]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B718%2F</url>
    <content type="text"><![CDATA[心累，这道题其实用到的思想之前都有用到过，这次一结合再加一点创新就做了很久没做出来。A message containing letters from A-Z is being encoded to numbers using the following mapping:1234'A' -&gt; 1'B' -&gt; 2...'Z' -&gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it.Example 1:12Input: "12"Output: 2 Explanation: It could be decoded as “AB” (1 2) or “L” (12).Example 2:12Input: "226"Output: 3 Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6).12345678910111213141516171819class Solution &#123; public int numDecodings(String s) &#123; int n = s.length(); int pre = 1; int now = s.charAt(n-1) == '0' ? 0 : 1; int curr = now; for (int i = n-2; i &gt;= 0; i--) &#123; if (s.charAt(i) == '0')&#123; curr = 0; &#125; else&#123; curr = Integer.parseInt(s.substring(i,i+2))&lt;27 ? pre+now:now; &#125; pre = now; now = curr;//这边有点不懂 &#125; return curr; &#125;&#125; 三个要点： 状态转移方程和走棋盘是一样的 只涉及前面两个状态数据时，不需要数组 遇到0就要重新开始计数 三个知识点： s.charAt(n)函数定位string中的单个字符 s.substring(i,i+2)函数定位子串中的范围，左开右闭 Integer.parseInt()String转int函数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM框架概览]]></title>
    <url>%2F2018%2F07%2F11%2FJVM%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[之前看JVM的书有点吃力，最近在看《深入分析java web》感觉里面讲JVM的知识虽然简略，但是容易理解，所以准备将看书过程中的几个要点进行整理概况。 JVM体系结构和工作方式啥是JVM计算机系统可以分为一下几个部分(指令集，计算单元，寻址方式，存储器定义，存储单元)，其中最主要的是指令集。Java和实体机一样有一套自己的指令集，称为JVM字节码指令集。 JVM体系结构详解 类加载器：三大加载器 执行引擎：Hotspot基于栈，Dalvik基于寄存器 内存区：线程共享(方法区+堆)，非共享（栈+PC寄存器），本地方法 本地方法调用：调用C/C++ JVM工作机制为啥选择基于栈 要设计成与平台无关的，保证寄存器很少也能执行Java代码； 为了指令的紧凑型 物理内存和虚拟内存32位总线最多单次读取4GB的内存。虚拟内存使得多项进程共享物理内存，注意是空间是上共享，逻辑还是隔离的。 内核空间与用户空间这种从内核空间到用户空间的数据复制很费时，虽然保住了程序运行的安全性和稳定性，但是也牺牲了一部分效率。 哪些组件需要内存 堆：-Xms（初始），-Xmx（最大），-Xms（） 线程：每个线程创建时JVM都会为它创建一个堆栈，堆栈的大小根据不同的JVM实现而不同，通常在256KB~ 756KB之间。 类和类加载器：任何系统类(如java.lang.String)或通过应用程序类加载器加载的任何应用程序类都不能在运行时释放。 NIO：分配的内存使用的是本机内存而不是Java堆上的内存 JNI：JNI也会增加Java运行时的本机内存占用 Java内存结构 PC寄存器：保存当前正常执行的程序的内存地址 栈：由于Java栈是与Java 线程对应起来的，这个数据不是线程共享的，所以我们不用关心数据一致性问题，也不会存在同步锁的问题 堆：堆是被所有Java线程所共享的，所以对它的访问需要注意同步问题 方法区：JVM方法区是用于存儲炎結枸信息的地方（常量池、域、方法数据、方法体、构造函数，包括类中的专用方法、实例初始化、接口初始化） 本地方法区：为JVM运行Native方法准备的空间 运行时常量池：它是方法区的部分，所以它的存储也受方法区的规范约束 Java内存分配详解 栈：栈中主要存放一些基本类型的变量数据( int、short、long、byte、float、 double、boolean、char)和对象句柄(引用)。存取速度比堆要快，仅次于寄存器，栈数据可以共享。缺点是，存在栈中的数据大小与生存期必须是确定的，这也导致缺乏了其灵活性。 堆：堆的效率非常低。但是堆的优点在于，编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长时间，因此，用堆保存数据时会得到更大的灵活性。Java内存回收策略 静态内存分配和回收动态内存分配和回收]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷17]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B717%2F</url>
    <content type="text"><![CDATA[Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.Example 1:12Input: [2,3,-2,4]Output: 6 Explanation: [2,3] has the largest product 6.Example 2:12Input: [-2,0,-1]Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.12345678910111213141516171819class Solution &#123; public int maxProduct(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; int n = nums.length; int[] maxdp = new int[n+1]; int[] mindp = new int[n+1]; int maxVal = Integer.MIN_VALUE; maxdp[0] = 1; mindp[0] = 1; for (int i = 1; i &lt; n+1; i++) &#123; maxdp[i] = Math.max(maxdp[i-1]*nums[i-1], Math.max(mindp[i-1]*nums[i-1], nums[i-1])); mindp[i] = Math.min(mindp[i-1]*nums[i-1], Math.min(maxdp[i-1]*nums[i-1], nums[i-1])); maxVal = Math.max(maxVal, maxdp[i]); &#125; return maxVal; &#125;&#125; 不是很难的动态规划题，考察对于题目的分析，这边主要考察三点： 之前已经保存的正数的最大值乘以一个正数是最大； 之前已经保存的负数的最小值乘以一个负数变成最大； 考虑到0的存在，使得单个值成为最大值或者0之后的某一串值变成最大值；这道题自己在考虑的时候要对于各种情况考虑周全。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷16]]></title>
    <url>%2F2018%2F07%2F09%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B716%2F</url>
    <content type="text"><![CDATA[非常经典的最长上升子序列的题目，现在做起来还是有点吃力的。之后还要再多看几次。Given an unsorted array of integers, find the length of longest increasing subsequence.Example:123Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Note:There may be more than one LIS combination, it is only necessary for you to return the length.Your algorithm should run in O(n2) complexity.Follow up: Could you improve it to O(n log n) time complexity?12345678910111213141516171819202122class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int len = nums.length; int[] tail = new int[len]; int size = 0; for (int num:nums) &#123; int i = 0,j = size; while(i!=j)&#123; int m = i + (j-i)/2; if (num&gt;tail[m])&#123; i = m+1; &#125; else&#123; j = m; &#125; &#125; tail[i] = num; if (size == i) size++; &#125; return size; &#125;&#125; 复杂度O(nlogn)就提示我们要一次循环加一次二分搜索了，问题是中间状态数据的保留，这边有两个：size表示现有最长的长度，当做返回的数据，另外一个是tail数组，表示的是现有最合适的子序列的数据。总体来说这道题有一定的难度，之后要再看看才行。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷15]]></title>
    <url>%2F2018%2F07%2F08%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B715%2F</url>
    <content type="text"><![CDATA[今天这道比昨天的难了一点。You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.Example 1:123Input: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2:12Input: coins = [2], amount = 3Output: -1 12345678910111213141516171819class Solution &#123; public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount+1]; for (int i = 1; i &lt;= amount; i++) &#123; dp[i] = Integer.MAX_VALUE;//这个值在前后相减时不会出现 for (int coin:coins)&#123; if (coin&lt;=i &amp;&amp; dp[i-coin] != Integer.MAX_VALUE)&#123; dp[i] = Math.min(dp[i-coin]+1, dp[i]); &#125; &#125; &#125; if (dp[amount] == Integer.MAX_VALUE)&#123; return -1; &#125; else&#123; return dp[amount]; &#125; &#125;&#125; 还是动态规划题，难点在于要确保这个硬币的值可能很大，故在初始化的时候要选定合适的值，这边选择Integer.MAX_VALUE或者Integer.MAX_VALUE-1都行，因为硬币至少面额为1，所以其实选择Integer.MAX_VALUE-1最合适。 12345678910111213141516class Solution &#123; public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount+1]; int max = amount+1; Arrays.fill(dp,max); dp[0] = 0; for (int coin:coins)&#123; for (int i = coin; i &lt;= amount; i++) &#123; dp[i] = Math.min(dp[i-coin]+1,dp[i]); &#125; &#125; return dp[amount]&gt;amount?-1:dp[amount]; &#125;&#125; 做了coinchange2后，发现此类背包问题还是用coin循环在外，amount循环在内，不仅循环次数减少了，还避免了原有方案需要判断不能到达点的标记。总体代码精简而且效率提高。教训：原来的思路要死需要打补丁，那想想能不能从全局上修改逻辑，使得不需要打补丁。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷14]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B714%2F</url>
    <content type="text"><![CDATA[可喜可贺，终于是第一道完全自己做出来的LeetCode题了，而且花的时间也不多，算法复杂度也可以。看来的确得每天多练练呀。A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).How many possible unique paths are there?Example 1:1234567Input: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down2. Right -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Right 123456789101112131415161718class Solution &#123; public int uniquePaths(int m, int n) &#123; int[][] sum = new int[m][n]; for (int i = 0; i &lt; n; i++) &#123; sum[0][i] = 1; &#125; for (int i = 0; i &lt; m; i++) &#123; sum[i][0] = 1; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; sum[i][j] = sum[i-1][j]+sum[i][j-1]; &#125; &#125; return sum[m-1][n-1]; &#125;&#125; 这道棋盘题就是维护一个二维数组sum[][]，然后初始化横竖第一排，最后根据sum[i][j] = sum[i-1][j]+sum[i][j-1]依次生成即可。典型的动态规划思想。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷13]]></title>
    <url>%2F2018%2F07%2F06%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B713%2F</url>
    <content type="text"><![CDATA[不管了，先做一波动态规划的题练练思路。 Jump GameGiven an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.Determine if you are able to reach the last index.Example 1:123Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:1234Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximumjump length is 0, which makes it impossible to reach the last index. `javapublic class Solution { public boolean canJump(int[] nums) { int curr = nums.length; for (int i = curr-2; i &gt;= 0; i–) { if (nums[i] == 0){ int jump = 1; while(nums[i] &lt; jump){ i–; jump++; if(i&lt;0){ return false; } } } } return true; } }`借鉴了大神的思想，反向思维，如果过不了，问题一定是出在有个位置是0，而且0之前的数字都跳不过0的位置，由于第一只值不为0，那么遍历nums.length-2个即可，再次基础上进行反向推导，判断之前的nums[]能不能跳过step步数。这道题的这个解法是启发了我，那就算“反过来推导”：对于许多题目而言，其要求的结论本身就隐藏了推论，不管这个推论是充分的还是必要的，都很可能对解题有帮助。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷12]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B712%2F</url>
    <content type="text"><![CDATA[Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.Example:123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. java public class Solution { public int maxSubArray(int[] nums) { int sum = nums[0]; int sum_array = nums[0]; for (int i = 0; i &lt; nums.length; i++) { int num = nums[i]; sum = Math.max(sum+num, num); sum_array = Math.max(sum_array,sum); } return sum_array; } } 还是动态规划的思路，设置两个变量记录数值，第一个记录连续累加的最大值与当前新的值的大小，如果前面一连串加起来还没有侯后面单个大，那肯定抛弃前面所有的了，第二个数组用来存储之前的连续序列的最大值，记录最大的即可，简单的动态规划只用max比较前后就行。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java JVM学习笔记1]]></title>
    <url>%2F2018%2F07%2F05%2FJava-JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[光看书找不到重点，针对题目来学习一下《深入了理解Java虚拟机》。 以下哪个不属于JVM堆内存中的区域？ Java堆分为：新生代（一般是一个Eden区，两个Survivor区），老年代（old区） 常量池属于 PermGen（方法区） 方法区和Java堆都是线程共享的 JVM内存可简单分为三个区？ 堆区（heap）：用于存放所有对象，是线程共享的（注：数组也属于对象）（用GC处理） 栈区（stack）：用于存放基本数据类型的数据和对象的引用，是线程私有的（分为：虚拟机栈和本地方法栈） 方法区（method）：用于存放类信息、常量、静态变量、编译后的字节码等，是线程共享的（也被称为非堆，即 None-Heap）（用帧栈处理） 内存分配与回收策略 对象优先在Eden分配 大对象直接进入老年代 长期存活的对象进入老年代 动态对象年龄判定 java的垃圾收集机制主要针对新生代和老年代的内存进行回收，不同的垃圾收集算法针对不同的区域。所以java的垃圾收集算法使用的是分代回收。一般java的对象首先进入新生代的Eden区域，当进行GC的时候会回收新生代的区域，新生代一般采用复制收集算法，将活着的对象复制到survivor区域中，如果survivor区域装在不下，就查看老年代是否有足够的空间装下新生代中的对象，如果能装下就装下，否则老年代就执行FULL GC回收自己，老年代还是装不下，就会抛出OUtOfMemory的异常]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷11]]></title>
    <url>%2F2018%2F07%2F04%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B711%2F</url>
    <content type="text"><![CDATA[真的是惰怠，16周之后就再也没刷过题了，说好的每日一刷呢？今天不要脸更新下去吧。。。You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.Example 1:1234Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2:1234Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. 1234567891011121314151617public int rob(int[] nums) &#123; int length = nums.length; int[] money = new int[length]; if (length == 0)&#123; return 0; &#125; if (length &lt; 2)&#123; return nums[0]; &#125; money[0] = nums[0]; money[1] = Math.max(nums[0],nums[1]); for (int i = 2; i &lt; money.length; i++) &#123; money[i] = Math.max(nums[i]+money[i-2],money[i-1]); &#125; return money[length-1];&#125;先贴上我自己的做法，思路都是按照之前的python版本来的，比较简陋，但是核心思想是对的，动态规划就是先找出状态转移方程，然后记录中间变量。不过我的写法在特殊情况的判别上很繁琐，效率也不高。 123456789public int rob(int[] nums) &#123; int prev = 0, curr = 0; for (int n : nums) &#123; int tmp = curr; curr = Math.max(prev + n, curr); prev = tmp; &#125; return curr;&#125; 这个是LeetCode上的高效算法，改进的地方就是取消了数组的方式，因为之前的转移方程设计的比较对象其实是money[i-2]和money[i-1]，两个的话可以用curr和prev变量代替，这是个不错的思路。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷10]]></title>
    <url>%2F2018%2F06%2F12%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B710%2F</url>
    <content type="text"><![CDATA[You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?Note: Given n will be a positive integer.Example 1:12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2:123456Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 1234567891011class Solution &#123; public int climbStairs(int n) &#123; ArrayList&lt;Integer&gt; arrayList= new ArrayList&lt;Integer&gt;(); arrayList.add(0, 1); arrayList.add(1, 1); for (int i = 2; i &lt;= n; i++) &#123; arrayList.add(i, arrayList.get(i-1)+arrayList.get(i-2)); &#125; return arrayList.get(n); &#125;&#125; 这道题是最基础的动态规划题，动态规划题的关键点在于两个方面：第一点是找出状态转移方程，第二点是记录中间数据。所以动态规划是典型的牺牲存储换取时间的一种方式。该题可以理解为n步的方法可以考虑为n-1步的方法再走一步加上n-2的方法再走2步。凑巧就是斐波那契数列，自己做的方法用了arraylist用于动态扩展数组，其实没必要，因为已经知道了n个，只要用大小为n个的数组记录即可。下面再贴一个效率高一点的：1234567891011121314class Solution &#123; public int climbStairs(int n) &#123; int[] sol = new int[n]; if (n == 0) return 0; sol[0] = 1; if (n == 1) return 1; sol[1] = 2; if (n == 2) return 2; for (int i = 2; i &lt; n; i++) &#123; sol[i] = sol[i-1] + sol[i-2]; &#125; return sol[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷9]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B79%2F</url>
    <content type="text"><![CDATA[Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.Note: For the purpose of this problem, we define empty string as valid palindrome.Example 1:12Input: "A man, a plan, a canal: Panama"Output: true Example 2:12Input: "race a car"Output: false 123456789101112class Solution &#123; public boolean isPalindrome(String s) &#123; String test = s.replaceAll("[^a-z^A-Z^0-9]", "").toLowerCase(); char[] arr = test.toCharArray(); for (int i = 0; i &lt; arr.length/2; i++) &#123; if(arr[i] != arr[arr.length-i-1])&#123; return false; &#125; &#125; return true; &#125;&#125; 思路不难，先对字符串进行处理留下大小写和数字，然后大小写统一一下，然后收尾比较即可，我这边用的是string的正则表达式处理的方法，然后用toLowerCase()函数统一变成小写。但是这样效率较低。下边展示一下效率较高的用法：123456789101112131415161718192021222324252627282930313233public class Solution &#123; public boolean isPalindrome(String s)&#123; if(s == null||s.length() == 0)&#123; //null和0的判断是不是重复了？ return false; &#125; int i = 0; int j = s.length()-1; while(i&lt;j)&#123; char lc = s.charAt(i); char rc = s.charAt(j); if ((lc&lt;65||lc&gt;90)&amp;&amp;(lc&lt;97||lc&gt;122)&amp;&amp;(lc&lt;48||lc&gt;57))&#123; i++; continue; &#125; if ((rc&lt;65||rc&gt;90)&amp;&amp;(rc&lt;97||rc&gt;122)&amp;&amp;(rc&lt;48||rc&gt;57))&#123; j--; continue; &#125; if (lc!=rc)&#123; if (lc&gt;=65 &amp;&amp; lc&lt;=90)&#123; return (lc -'A') == (rc -'a'); &#125; if (lc&gt;=97 &amp;&amp; lc&lt;=122)&#123; return (lc -'a') == (rc -'A'); &#125; return false; &#125; i++; j--; &#125; return true; &#125;&#125; 总体思路相同，但是用了人工写判断函数的方法，使得效率提高，还有一点，charAt()函数指向的值会随着里面i和j的变化自动变化。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷8]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B78%2F</url>
    <content type="text"><![CDATA[Given two strings s and t , write a function to determine if t is an anagram of s.Example 1:12Input: s = "anagram", t = "nagaram"Output: true Example 2:12Input: s = "rat", t = "car"Output: false 12345678910111213141516171819202122232425class Solution &#123; public boolean isAnagram(String s, String t) &#123; HashMap&lt;Character, Integer&gt; maps = new LinkedHashMap&lt;Character, Integer&gt;(); HashMap&lt;Character, Integer&gt; mapt = new LinkedHashMap&lt;Character, Integer&gt;(); char[] arrs = s.toCharArray(); char[] arrt = t.toCharArray(); for(char c : arrs)&#123; if(maps.containsKey(c))&#123; maps.put(c,maps.get(c)+1); &#125; else&#123; maps.put(c,1); &#125; &#125; for(char c : arrt)&#123; if(mapt.containsKey(c))&#123; mapt.put(c,mapt.get(c)+1); &#125; else&#123; mapt.put(c,1); &#125; &#125; return (maps.equals(mapt))? true:false; &#125;&#125; 昨天虽然做了类似的题目，但是还有惯性思维用了hashmap，不过也好，算是回顾了下它的用法，这道题逻辑没啥好说的，统计每个字符出现的次数然后进行比较，关键在于如何做到高效。事实证明hashmap对于这种小体量的数据效果不行，不如原始的数组进行记录。接下来看一个用数组记录的案列：1234567891011121314151617class Solution &#123; public boolean isAnagram(String s, String t) &#123; int[] chardci = new int[26]; for(char c : s.toCharArray())&#123; chardci[c-'a']++; &#125; for(char c : t.toCharArray())&#123; chardci[c-'a']--; &#125; for(int i : chardci)&#123; if(i!=0)&#123; return false; &#125; &#125; return true; &#125;&#125; 这里巧妙的只运用了一个数组进行记录，第一次++，第二次–，如果相同刚好数组全部为0。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷7]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B77%2F</url>
    <content type="text"><![CDATA[Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. Examples:12345s = "leetcode"return 0.s = "loveleetcode",return 2. 1234567891011121314151617181920class Solution &#123; public int firstUniqChar(String s) &#123; HashMap&lt;Character, Integer&gt; map = new LinkedHashMap&lt;Character, Integer&gt;(); for(char c : s.toCharArray())&#123; if(map.containsKey(c))&#123; map.put(c,map.get(c)+1); &#125; else&#123; map.put(c,1); &#125; &#125; for(char key : map.keySet())&#123; int val = map.get(key); if(val == 1)&#123; return s.indexOf(key); &#125; &#125; return -1; &#125;&#125; 这道题很是简单，由于之前python版本用了字典，这里本能用了hashmap。不过不熟悉hashmap的用法，比如put(),get(),containsKey()，之后找个方法快速找到java api用法很有必要，这次还第一次尝试的for循环的简介写法，这个和python的 for c in s是一个道理，用起来方便。不过提交后发现，效率很低才打败了18%的用户，看了看排名高的做法，发现其实道理一样，只是由于数据少不需要用map，只是建立了一个数组来存值，下面贴一个：12345678910111213class Solution &#123; public int firstUniqChar(String s) &#123; int[]alp = new int[26]; char[]arr = s.toCharArray(); for(char c : arr)&#123; alp[c-'a']++; &#125; for(int i = 0; i &lt; arr.length;i++)&#123; if(alp[arr[i]-'a'] == 1) return i; &#125; return -1; &#125;&#125; 这个解法就秒在[c-‘a’]，使得字符数组变成了0-25的数字便于索引。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷6]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B76%2F</url>
    <content type="text"><![CDATA[Write a function that takes a string as input and returns the string reversed. Example:Given s = “hello”, return “olleh”.123456789101112class Solution &#123; public String reverseString(String s) &#123; char[] word = s.toCharArray(); int n = s.length(); for(int i=0;i&lt;n/2;i++)&#123; char temp = word[i]; word[i] = word[n-1-i]; word[n-1-i] = temp; &#125; return new String(word); &#125;&#125; java的string是不可以修改的，这点和python不太一样，所以在对string字符串进行修改的时候需要先把它转换成字符数组，然后再new一个string回去，除此之外这道题没啥其他可讲的了，while和for的差别不大，还有就是string的长度是length()，i数组的是length。 Given a 32-bit signed integer, reverse digits of an integer. Example 1:12Input: 123Output: 321 12345678910111213class Solution &#123; public int reverse(int x) &#123; long result = 0; while(x!=0)&#123; result = result*10+x%10; if(result &gt; Integer.MAX_VALUE) return 0; if(result &lt; Integer.MIN_VALUE) return 0; x = x/10; &#125; return (int)result; &#125;&#125; 这道题和上一道题是配套的，不过这一道是数字，考点是怎么几个：正负，上下限，如何取每一位的数，对于0的处理。实际解决过程中重要的是想到result = result*10+x%10;这个式子，一举解决了以上的三个问题，上下限的问题解决方法是先设置一个long的结果，保证数据范围够大，然后用java自建的Integer.MAX_VALUE和Integer.MIN_VALUE进行判断。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷5]]></title>
    <url>%2F2018%2F06%2F07%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B75%2F</url>
    <content type="text"><![CDATA[You are given an n x n 2D matrix representing an image.Rotate the image by 90 degrees (clockwise).Note:You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.Example:12345678910111213Given input matrix = [ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] 1234567891011121314151617181920212223class Solution &#123; public void rotate(int[][] matrix) &#123; int len = matrix.length; for(int i = 0; i &lt; len; i++)&#123; for(int j = i+1; j &lt; len; j++)&#123; int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125; for(int i = 0; i &lt; len; i++)&#123; reverse(matrix[i]); &#125; &#125; public static void reverse(int[] array)&#123; for(int i=0;i&lt;array.length/2;i++)&#123; int temp = array[i]; array[i] = array[array.length-1-i]; array[array.length-1-i] = temp; &#125; &#125;&#125; 这道题难得是自己做出来的一道题，虽然方法并不是最好的，主要思想是将转换的过程分成两步，第一步是斜对角线元素替换，第二部是将每一行中的数组逆序，其中逆序操作还是参考了网上的方法（基本功还是不扎实），不过看了LeetCode上其他人的做法后发现，我的这个解决方法复杂度还是高了，主要是区别在i和j的右边界上。下面是复杂度较小的一个：123456789101112public class Solution &#123;public void rotate(int[][] matrix) &#123; int n=matrix.length; for (int i=0; i&lt;n/2; i++) for (int j=i; j&lt;n-i-1; j++) &#123; int tmp=matrix[i][j]; matrix[i][j]=matrix[n-j-1][i]; matrix[n-j-1][i]=matrix[n-i-1][n-j-1]; matrix[n-i-1][n-j-1]=matrix[j][n-i-1]; matrix[j][n-i-1]=tmp; &#125; &#125; 其他人虽然有不同做法，但是减低复杂度的本质就都在于“i&lt;n/2”，于此同时j的循环次数也减低了，但是缺点在于其置换的逻辑变难了，需要画图理解一下。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷4]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B74%2F</url>
    <content type="text"><![CDATA[Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.1234567891011121314151617class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for(int i = 0; i &lt; 9; i++)&#123; Set&lt;Character&gt; rows = new HashSet&lt;&gt;(); Set&lt;Character&gt; cols = new HashSet&lt;&gt;(); Set&lt;Character&gt; blocks = new HashSet&lt;&gt;(); int row = 3*(i/3); int col = 3*(i%3); for(int j = 0; j &lt; 9; j++)&#123; if(board[i][j]!='.'&amp;&amp; !rows.add(board[i][j])) return false; if(board[j][i]!='.'&amp;&amp; !cols.add(board[j][i])) return false; if(board[row+j/3][col+j%3]!='.'&amp;&amp; !blocks.add(board[row+j/3][col+j%3])) return false; &#125; &#125; return true; &#125;&#125; 这道题目比之前的记道题目明显难了很多，看了一下python的做法，利用了Python的自建函数，过于简洁也过于高深了，java的解决方法也有许多，我挑了一种我觉得兼顾了可理解和效率的一种方式，基本思想是对于每一列，每一行，每一个3乘3区块都维护一个HashSet的列表（hashset的好处是可以检验加进来的数据是不是重复了，如果重复了就会对add()函数return false，这个也是作为判断函数的一个关键点。第二个难点在于对于每一个区块内的数据位置进行定位，一开始我想不出来，后来看到了答案的做法能，首先是对于i进行分别乘和模运算，然后这样可以找到每个3*3区块的左上角的位置，然后具体的位置再依靠j的相关运算来进行。 总之，这道题具有一定的难度，借此学习到了hashset的一些简单用法，还有就是对于二维数组的定位。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷1]]></title>
    <url>%2F2018%2F06%2F05%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B71%2F</url>
    <content type="text"><![CDATA[记录一下java刷LeetCode的思路，巩固一下基础。 Rotate Array（easy）Given an array, rotate the array to the right by k steps, where k is non-negative.Example 1: Input: [1,2,3,4,5,6,7] and k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4] 123456789101112131415161718192021class Solution &#123; public void rotate(int[] nums, int k) &#123; if(nums == null || nums.length &lt; 2)&#123; return; &#125; k = k % nums.length; reverse(nums,0,nums.length - k - 1); reverse(nums,nums.length - k, nums.length - 1); reverse(nums,0,nums.length-1); &#125; private void reverse(int[] nums, int i, int j)&#123; int temp = 0; while (i&lt;j)&#123; temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; j--; &#125; &#125;&#125; 这道题之前用python做的时候利用了python数组的简便性，所以很快解决了，但是用java做的时候发现一下子难以下手，思考了之后没啥思路，于是看了一个比较简单易懂的解法实现了一下。解题思路是for example, nums = [1,2,3,4,5,6,7] and k = 3, first we reverse [1,2,3,4], it becomes[4,3,2,1]; then we reverse[5,6,7], it becomes[7,6,5], finally we reverse the array as a whole, it becomes[4,3,2,1,7,6,5] —&gt; [5,6,7,1,2,3,4].即利用基础的置换函数，进行三次置换，最后得到结果。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷2]]></title>
    <url>%2F2018%2F06%2F05%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B72%2F</url>
    <content type="text"><![CDATA[Intersection of Two Arrays II（easy）Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1’s size is small compared to nums2’s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? 123456789101112131415161718192021222324252627class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; int p1 = 0; int p2 = 0; int lenth1 = nums1.length; int lenth2 = nums2.length; int[] result = new int[Math.min(lenth1,lenth2)]; //生成数组不熟练,Math函数java不熟练 int counter = 0; Arrays.sort(nums1); Arrays.sort(nums2); while(p1&lt;lenth1 &amp;&amp; p2&lt;lenth2)&#123; if (nums1[p1] == nums2[p2])&#123; result[counter] = nums1[p1]; //没有背出来 p1++; p2++; counter++; &#125; else if(nums1[p1] &gt; nums2[p2])&#123; p2++; &#125; else&#123; p1++; &#125; &#125; return Arrays.copyOfRange(result, 0, counter); // Arrays类函数不熟练 &#125;&#125; 这道题之前python是用字典做的，在java里面可以用类似的HashMap做，而且理论上用HashMap的算法复杂度更低 (O(N))，但是查询了网上的回答，发现还是朴素一点的查询方法(nlogn)更快，而且这种方法更加容易理解，所以就先用这种方法默写的一次，过程中发现对于java的数组和Arrays类的函数使用不熟练。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一刷3]]></title>
    <url>%2F2018%2F06%2F05%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B73%2F</url>
    <content type="text"><![CDATA[Plus One(easy)Given a non-empty array of digits representing a non-negative integer, plus one to the integer.The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.You may assume the integer does not contain any leading zero, except the number 0 itself.Example 1: Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123. 123456789101112131415class Solution &#123; public int[] plusOne(int[] digits) &#123; int len = digits.length; for(int i = len-1;i&gt;=0;i--)&#123; if(digits[i]&lt;9)&#123; digits[i]++; return digits; &#125; digits[i] = 0; &#125; int[] newdigits = new int[len+1]; newdigits[0] = 1; return newdigits; &#125;&#125; 这是一道进位加一的题，难点在于设计满10进1，这个解法的巧妙点在于return函数的位置写在了判断语句之中，这样如果不进位刚好，进位了的话，不满足条件置0，然后根据循环找到上一位加一，最后考虑到特殊情况，当出现“99999”这样的情况时，需要增加一位数据长度，然后首位置1即可（其余默认为0）。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软技能]]></title>
    <url>%2F2018%2F05%2F30%2F%E8%BD%AF%E6%8A%80%E8%83%BD%2F</url>
    <content type="text"><![CDATA[哎，写字又丑又慢，准备慢慢的把读书笔记记到博客中来。最近清恰好在网上看到了一本《软技能》的书，大概是讲程序员的职业规划的，自己对此也一直有所困惑，故将一些书中的要点在博客进行记录。 拥有商业心态 专注于你正在提供的服务 想方设法提升服务 思考有哪些特定类型的客户 集中精力成为一位专家 追踪你的目标 定期核对自己的目标 反思长期短期的成果 与人相处 谈话时试着从对方的角度思考问题 不要直截了当的提出建议，从对方的心态来提 找到需想要的工作 突破常规，想办法与公司内部人员建立联系 面试的时候证明自己是无需督促也能自发做好事情的员工 雇员VS独立咨询师VS创业 雇员好处：稳定，轻松，带薪休假，保险 弊端：缺少自由，收入封顶 咨询好处：自由，不断有新的项目，赚钱潜力大 弊端：自己找业务，打理一切开销，为许多老板服务 创业好处：完全自由，做自己想做的，赚钱潜力巨大，没有老板 弊端：风险巨大，完全靠自己，需要很多技能，需要长时间工作 怎么选？ 先从雇员做起 不要怕专业化，虽然失去了一些机会，但是也能获得特定的潜在客户 有些是某些公司内部的特定技能，要小心这类技能换公司就没有用了 最好的状态是学富五车但是仍然有技能让自己卓尔不群 大公司VS中公司VS创业公司 尽量不选小公司，除非喜欢快节奏的工作环境，或者希望构建伟大的产品，否则风险太大 中等公司比大公司还要稳定，适合缓慢稳健的做事风格，但是常常这类公司厌恶风险 大公司有大量的规章流程，要遵守公司的做事方式，有各种培训等成长机会，真正的大公司技术更新很快，但是容易隐藏于芸芸众生之中，最后就是往往有办公室政治 想要晋升？承担责任如果没有就去主要寻找，去那些没有人愿意涉足的领域，另外一种是成为团队中的导师，帮助新人成长，树立起“及时雨”的称号 不受重视的项目 帮助新人 及时更新文档 承担起没人愿意做的 引人注目不要默默无闻啊 每天记录自己活动的日志 提供演讲或培训 发表意见 保证“曝光度” 自学不断增加自己的知识，相信学习也是一种复利 获取一些有用的证书 不要只学软件开发，学会领导力，商科管理等知识 不要忘记分享自己学到的知识，可以记录在博客上 关于政治 尽量避开，脚踏实地 成为专业人士专业人士引人注目，始终如一 专业人士VS外行 遵守原则 专注于正确完成工作 不怕承认错误 持续稳定 勇于承担责任 坚守正道 可能遇到当前的决策进行是正确的，也符合客户的利益，但是会危及自己的职业 评估需要完成的工作，进行优先级排序 追求品质 不断的扣细节 不断的完善 待续]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>IT类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记5]]></title>
    <url>%2F2018%2F05%2F18%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%2F</url>
    <content type="text"><![CDATA[还是要补充基础知识啊 反射泛型简单泛型类1234567891011121314public class Pair&lt;T&gt; &#123; private T first; private T second; public Pair() &#123; first = null; second = null; &#125; public Pair(T first, T second) &#123; this.first = first; this.second = second; &#125; public T getFirst() &#123; return first; &#125; public T getSecond() &#123; return second; &#125; public void setFirst(T newValue) &#123; first = newValue; &#125; public void setSecond(T newValue) &#123; second = newValue; &#125;&#125; 这样的话12Pair&lt;String&gt;()Pair&lt;String&gt;(String,String) 泛型类可以看做是普通类的工厂 泛型方法1234567class Array&#123; public static &lt;T&gt; T getmid(T...a) &#123; return null; &#125;&#125; 1.泛型方法可以定义在普通类中，也可以在泛型类中 泛型变量的限定1234public static &lt;T extends Comparable&gt; T getmid(T...a) &#123; return null; &#125; 泛型代码和虚拟机约束和局限性泛型类型的继承规则多线程枚举内部类原因1.内部类方法可以访问该类定义所在的作用域中的数据，包括私有数据2.内部类可以对同一个包中的其他类预隐藏起来3.定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷 特性1.内部类既可以访问自己的数据域，也可以访问外围类对象的数据域2.outerclass.this代表正规的外部引用3.outerobject.new innerclass(construction parameters)4.局部内部类：可以在方法中定义内部类（不能用public或者private进行声明，对外部世界完全隐藏）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记4]]></title>
    <url>%2F2018%2F05%2F14%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[包使用包名的主要作用是确保类名的唯一性，而且从编译器的角度来看，嵌套的包之间没有任何的关系 类的导入1.一个类可以使用所属包中的所有类，以及其他包中的公有类2.*号只能导入一个包 静态导入import语句不仅仅导入类，还可以导入静态域和静态方法 将类放到包中想要把包放到包中，就必须将包的名字放在源文件的开头 包作用域没有指定public或者private的话，这个部分（类，方法，变量）可以被同一个包的所有方法访问 异常、断言、日志和调试异常1.Exception主要分为两类，一类程序错误导致的日常属于RuntimeException;另外一类是程序本身没有错误，但是由于IO这类错误导致的异常2.try catch final进行异常处理3.catch字句还可以抛出异常（有其特殊的优点）4.可以捕获多个异常5.子类可以抛出更加特定的异常6.异常链可以好好看之前的程序 异常技巧1.异常处理不能代替简单的测试2.不要过分的细化异常3.利用异常层次结构4.不要压制异常5.在检测错误时，“苛刻”要比放任更好6.不要羞于传递异常 使用断言1.断言主要用在测试阶段，当代码发布的时候，这些插入的语句会被自动移走 记录日志1.不要将所有日志记录到一个全局日记记录器中，要有层次 对象构造重载1.方法名和参数类型叫做方法的签名，返回类型不算2.允许重载任何方法，不止构造函数3.构造函数没有显示赋值的话会有默认值（0，null，false）4.类如果没有构造函数，系统才会提供一个默认的构造函数5.显式域初始化不一定是常量6.构造器的第一个语句用this()，则意思是调用另外一个构造函数7.参数名中两种方式(更加喜欢第二种)：123456789public Employee(String aName, double aSalary)&#123; name = aName; salary = aSalary;&#125;public Employee(String name, double salary)&#123; this.name = name; this.salary = salary;&#125; 8.初始化块优先于构造函数执行9.初始化数据域的三种方式（构造函数里，声明中，构造快）10.类加载顺序静态代码块(包括静态初始化块，静态属性，但不包括静态方法)-&gt;非静态代码块(包括非静态初始化块，非静态属性)-&gt;构造函数 继承类，超类，子类1.所有的继承都是公用继承2.在覆盖的时候，希望调用父类的公有方法访问父类的私有变量，则可以用super关键字1234public double getSalary()&#123; double baseSalary = super.getSalary(); return baseSalary + bonus;&#125; 3.子类的构造函数如果没有显式的调用超类的构造器，则将自动调用超类的无参构造函数4.this有两个用途：一是引用隐式参数，二是调用该类其他的构造函数5.super有两个用途：一是调用超类的方法，二是调用超类的构造器 多态1.子类的每个对象也是超类的对象2.子类数组的引用可以转化为超类数组的引用 动态绑定1.先看对象的声明类型和方法名，在看调用时的参数类型2.用了private，static，final方法或者构造器，称为静态绑定 final类和方法阻止继承1.final方法可以独立存在，final类中只有方法自动变成final方法（参数不是） 强制类型转换1.只能在继承层次内进行类型转换2.在将超类转换成子类之前，应该使用instanceof进行检查 抽象类1.抽象类，可以没有抽象方法，可以有具体数据和方法2.只要有抽象方法，那就一定是抽象类3.抽象类不能被实体化4.抽象方法没有方法体（这个小玩意{}） 受保护访问1.最好将域标记为private,将方法标记为public 2.仅对本类可见（private），对所有类可见（public），对本包和所有子类可见（protect），对本包可见（默认）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot学习笔记8]]></title>
    <url>%2F2018%2F05%2F13%2FSpring-boot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08%2F</url>
    <content type="text"><![CDATA[小知识1.由于在pc端上修改了host文件，可以将网址sell.com直接解析为127.0.0.1，但是在手机上不能改host，如何访问到pc上的开发环境呢？可以用代理的方式，使用charles软件，手机连接到和pc同一个网段后使用代理就行。（前提是开启内网穿透，让外网可以访问到本机）2.在paycontroller里面返回的是网页而不是json字符串，所以使用注解@Controller而不是@RestController3.使用外部的资源的话，在maven的依赖里面添加即可，自动下载，还可以指明版本号4.微信支付有一个异步通知的设置，要设置异步通知的网址接受并处理（TODO）5.支付端的代码推荐写到后端，可以重复利用6.想要实现后端生成动态的html文本的话，需要动态输入参数，使用Freemarker,java文件返回ModelandView类就行123456789101112131415161718public ModelAndView create(@RequestParam("orderId") String orderId, @RequestParam("returnUrl") String returnUrl, Map&lt;String, Object&gt; map )&#123; //1.查询订单 OrderDTO orderDTO = orderService.findOne(orderId); if(orderDTO == null)&#123; throw new SellException(ResultEnum.ORDER_NOT_EXIST); &#125; //2.发起支付 PayResponse payResponse = payService.create(orderDTO); map.put("payResponse", payResponse); map.put("returnUrl", returnUrl); return new ModelAndView("pay/create",map); &#125; 相应的create.ftl文件内容为：12345678910111213141516171819202122232425262728&lt;script&gt; function onBridgeReady()&#123; WeixinJSBridge.invoke( 'getBrandWCPayRequest', &#123; "appId":"$&#123;payResponse.appId&#125;", //公众号名称，由商户传入 "timeStamp":"$&#123;payResponse.timeStamp&#125;", //时间戳，自1970年以来的秒数 "nonceStr":"$&#123;payResponse.nonceStr&#125;", //随机串 "package":"$&#123;payResponse.packAge&#125;", "signType":"MD5", //微信签名方式： "paySign":"$&#123;payResponse.paySign&#125;" //微信签名 &#125;, function(res)&#123;// if(res.err_msg == "get_brand_wcpay_request:ok" ) &#123;&#125; // 使用以上方式判断前端返回,微信团队郑重提示：res.err_msg将在用户支付成功后返回 ok，但并不保证它绝对可靠。 location.href = "$&#123;returnUrl&#125;"; &#125; ); &#125; if (typeof WeixinJSBridge == "undefined")&#123; if( document.addEventListener )&#123; document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false); &#125;else if (document.attachEvent)&#123; document.attachEvent('WeixinJSBridgeReady', onBridgeReady); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady); &#125; &#125;else&#123; onBridgeReady(); &#125;&lt;/script&gt; 7.在对账的时候，可以出现金额由于数据类型不同出错的情况，为此特意写了一个工具类MathUtil（判断精度到小数点后面两位）：1234567891011121314151617package com.imooc.sell.utils;/** * Created by Citrix on 2018/5/10. */public class MathUtil &#123; private static final Double Money_Range = 0.01; public static Boolean equals(Double num1, Double num2) &#123; Double result = Math.abs(num1 - num2); if (result &lt; Money_Range) &#123; return true; &#125; return false; &#125;&#125; 8.处理微信发给来的异步通知信息，处理成功微信端就不发了：123456789101112/** * 异步回调 */@PostMapping("/notify")public ModelAndView notify(@RequestBody String notifyData) &#123; payService.notify(notifyData); //返回给微信处理结果 return new ModelAndView("pay/success");&#125; 9.在原来的基础上，增加退款逻辑，在OrderServiceImpl里面写cancel函数，paid函数，finish函数（finish和paid的区别再看看）10.数据库中存的是上架下架等的状态码，而在网页端的时候的时候需要是msg格式的，所以需要写一个根据枚举里面code找到msg的方法EnumUtil：1234567891011121314151617package com.imooc.sell.utils;import com.imooc.sell.enums.CodeEnum;/** * Created by Citrix on 2018/5/11. */public class EnumUtil &#123; public static &lt;T extends CodeEnum&gt; T getByCode(Integer code, Class&lt;T&gt; enumClass) &#123; for (T each: enumClass.getEnumConstants()) &#123; if (code.equals(each.getCode())) &#123; return each; &#125; &#125; return null; &#125;&#125; 11.有时候需要某些数据返回到前端json的时候自动省略（这些个函数主要用于生成前端页面），则可以加注解@JsonIgnore 小技巧1.为了控制台输出的数据格式直观，写了一个工具类JsonUtil，作用就是将数据变成json格式打印2.使用网站ibootstrap生成简单的前端页面代码 小问题1.虽然获取openid可以用测试账号，但是支付的开发必须使用服务号的功能，奈何太贵，这不过就不测试开发了2.微信支付有个预支付参数（prepayid）之后如果有需要再看看3.Java语法里面Map的使用4.微信退款的操作需要额外的证书，这边先不尝试5.微信的退款通知也放放]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot学习笔记7]]></title>
    <url>%2F2018%2F05%2F08%2FSpring-boot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07%2F</url>
    <content type="text"><![CDATA[今天暂停一下跟着视频学习的进程，好好回顾一下程序的逻辑。 获取yml配置文件里的变量比如我在yml配置的微信关公众号的信息如下：123wechat: mpAppid: wxf98e335974fbfa76 mpAppSecret: 7aee54b6a921a28f8f53c03590d05b20 在1234567891011121314151617181920212223242526272829303132333435package com.imooc.sell.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Map;/** * Created by Citrix on 2018/5/7. */@Data@Component//泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注@ConfigurationProperties(prefix = "wechat")//prefix后面跟着 的就是在yml文件里配置的字段名public class WechatAccountConfig &#123; private String mpAppId; private String mpAppSecret; /** * 商户号 */ private String mchId; /** * 商户密钥 */ private String mchKey; /** * 商户证书路径 */ private String keyPath;&#125; 主要注解理解1.@Service用于标注业务层组件 2.@Controller用于标注控制层组件（如struts中的action） 3.@Repository用于标注数据访问组件，即DAO组件(我的学习例子DAO里没有，出现在配置文件里) 4.@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 OrderService的create逻辑梳理这部分在学习的时候就觉得业务逻辑复杂度较高，现在来一步步理解。首先对于数据库的字段设计相应的类DAO,但是其业务逻辑导致DAO不能完全胜任工作（order的list之类，就不细讲了），故再设计DTO1.首先判断下单的产品还有没有（productInfo的ProductId）2.都在的话，找到单价，并且求订单总价(用到了lambda，productInfo的ProductPrice)3.将订单的id和订单详情的id记下来(都是随机数加时间戳)4.在订单详情中将产品信息的内容复制过去（BeanUtils.copyProperties(productInfo,orderDetail)）5.在订单中写入id，orderDTO的内容（买家的信息），订单总价，订单的支付状态和下单状态6.订单（orderMaster）和订单详情（orderDetail）存到数据库中7.扣库存，将调用productService进行decreaseStock操作 关于Page和List首先分析下面这段Page有关的代码：1234567public Page&lt;OrderDTO&gt; findList(String buyerOpenid, Pageable pageable) &#123; Page&lt;OrderMaster&gt; orderMasterPage = orderMasterRepository.findByBuyerOpenid(buyerOpenid, pageable); List&lt;OrderDTO&gt; orderDTOList = OrderMaster2OrderDTOConverter.convert(orderMasterPage.getContent()); //??? return new PageImpl&lt;&gt;(orderDTOList, pageable, orderMasterPage.getTotalElements()); &#125; 获取用户的OpenID重定向原理]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot学习笔记6]]></title>
    <url>%2F2018%2F05%2F07%2FSpring-boot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06%2F</url>
    <content type="text"><![CDATA[周末两天把最硬核的买家端DAO-Service(单元测试)-Controller部分完成了，干货非常多，但是也有很多业务逻辑方面的代码需要再好好理解。 小问题1.在OrderServiceImpl有CollectionUtils.isEmpty(orderDetailList)还不是很理解其语法2.PageIml，getContent()以及Page类3.@Valid注解和BindingResult4.HashMap以及map的使用12Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put("orderId", createResult.getOrderId()); 小技巧1.cmd+.可以在IDEA里将括号收起来2.IDEA注释写/TODO可以显示高亮和跳转，方便后期修改3.在postman里面可以把json的数据放进去自动生成key-value字段4.IDEA里面如果出现删除线说明方法被弃用了，点进去可以看到修改后的方法 小知识1.由于经常写DAO-&gt;DTO,索性写一个转换函数converter：123456789101112131415161718192021222324252627package com.imooc.sell.converter;import com.imooc.sell.dataobject.OrderMaster;import com.imooc.sell.dto.OrderDTO;import org.springframework.beans.BeanUtils;import java.util.List;import java.util.stream.Collectors;/** * Created by Citrix on 2018/5/6. */public class OrderMaster2OrderDTOConverter &#123; //单个参数的函数 public static OrderDTO convert(OrderMaster orderMaster) &#123; OrderDTO orderDTO = new OrderDTO(); BeanUtils.copyProperties(orderMaster, orderDTO); return orderDTO; &#125; //列表参数的一个函数 public static List&lt;OrderDTO&gt; convert(List&lt;OrderMaster&gt; orderMasterList) &#123; return orderMasterList.stream().map(e -&gt; convert(e) ).collect(Collectors.toList()); &#125;&#125; 2.对于前端传过来的表单设立专门的Form类：1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.imooc.sell.form;import lombok.Data;import javax.validation.constraints.NotEmpty;/** * 表单验证模块，涉及到前端过来的表单验证 * Created by Citrix on 2018/5/6. */@Datapublic class OrderForm &#123; /** * 买家姓名 */ @NotEmpty(message = "姓名必填") private String name; /** * 买家手机号 */ @NotEmpty(message = "手机号必填") private String phone; /** * 买家地址 */ @NotEmpty(message = "地址必填") private String address; /** * 买家微信openid */ @NotEmpty(message = "openid必填") private String openid; /** * 这个是麻烦的地方 * 购物车 */ @NotEmpty(message = "购物车不能为空") private String items;&#125; 3.在自定义异常中添加message字段，扩展异常处理的多样性4.BeanUtil的方法需要两个对象的类内变量名字相同5.使用了Google的Gson格式，在maven里面添加依赖，然后gson在项目中的应用主要在OrderForm2OrderDTOConverter里面（还待研究）:12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.imooc.sell.converter;import com.google.gson.Gson;import com.google.gson.reflect.TypeToken;import com.imooc.sell.dataobject.OrderDetail;import com.imooc.sell.dto.OrderDTO;import com.imooc.sell.enums.ResultEnum;import com.imooc.sell.exception.SellException;import com.imooc.sell.form.OrderForm;import lombok.extern.slf4j.Slf4j;import java.util.ArrayList;import java.util.List;/** * Created by Citrix on 2018/5/6. */@Slf4jpublic class OrderForm2OrderDTOConverter &#123; public static OrderDTO convert(OrderForm orderForm) &#123; Gson gson = new Gson(); OrderDTO orderDTO = new OrderDTO(); orderDTO.setBuyerName(orderForm.getName()); orderDTO.setBuyerPhone(orderForm.getPhone()); orderDTO.setBuyerAddress(orderForm.getAddress()); orderDTO.setBuyerOpenid(orderForm.getOpenid()); List&lt;OrderDetail&gt; orderDetailList = new ArrayList&lt;&gt;(); /*防止出错*/ try &#123; /*这边是难点*/ orderDetailList = gson.fromJson(orderForm.getItems(), new TypeToken&lt;List&lt;OrderDetail&gt;&gt;() &#123; &#125;.getType()); &#125; catch (Exception e) &#123; /*经常配合log使用*/ log.error("【对象转换】错误, string=&#123;&#125;", orderForm.getItems()); throw new SellException(ResultEnum.PARAM_ERROR); &#125; orderDTO.setOrderDetailList(orderDetailList); return orderDTO; &#125;&#125; 6.如果想要做到返回字段为Null就不传的效果的话，全局可以在.yml配置文件里添加：12jackson: default-property-inclusion: non_null 局部的话，在相应的类里面（比如OrderDTO）添加注解@JsonInclude(JsonInclude.Include.NON_NULL)]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot学习笔记5]]></title>
    <url>%2F2018%2F05%2F06%2FSpring-boot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%2F</url>
    <content type="text"><![CDATA[记录在spring boot学习中遇到的知识和难点 小知识1.lombok的Data,Getter,Setter的区别就是，Data包含（Getter&amp;Setter）2.在使用BigDecimal的时候他的计算方法都是有函数的（multiply（）而不是*）3.数据库对象DAO在实际的与前端通信的过程中不能直接拿来用，因为往往会设计数据库中没有的字段，比如我这个项目中，使用的DTO比DAO多了1private List&lt;OrderDetail&gt; orderDetailList ; 这个字段需要在后端处理的时候用到，但又不是DAO的基本字段4.随机数生成方法（六位）：123456public static synchronized String getUniqueKey()&#123; Random random = new Random(); Integer number = random.nextInt(900000)+100000;//生成六位随机数 return System.currentTimeMillis()+String.valueOf(number);//int转string&#125; 5.synchronized字段是为了防止多线程的时候随机数重复 小技巧1.cmd+shift+u:切换大小写 小问题1.BeanUtil的使用不会2.Lambda表达式的使用不会]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot学习笔记4]]></title>
    <url>%2F2018%2F05%2F03%2FSpring-boot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[spring中jpa操作createTime对应于数据库的中的create_time,这个是固定的，jpa操作的时候会自动进行名字的转化，不能写错，负责就会造成数据库操作出错。 getset方法太麻烦怎么办1.在pom.xml添加lombok2.idea添加插件lombok3.在DAO类中添加注解@Data就可以取消getset以及tostring之类的方法了 单元测试1.注意要使用Assert断言来确认数据的正确性。2.@Transactional注解可以报使得测试的数据不会对数据库造成影响（只是测试一下嘛）3.遇到了这样的语法，应该是数组的初始化吧1List&lt;Integer&gt; list = Arrays.asList(2,3,4); 梳理一下流程第一个数据的设计顺序是，先设计DAO（数据库对象），然后设计Service模块（注意接口与接口实现的分离），最后设计controller模块，其中还有很重要的是一定要先进行单元测试。 Service服务写成接口（并且实现接口与接口实现分离）拿CategoryService举个栗子🌰:1234567891011121314151617181920package com.imooc.sell.service;import com.imooc.sell.dataobject.ProductCategory;import java.util.List;/** * 类目接口 * Created by Citrix on 2018/5/3. */public interface CategoryService &#123; ProductCategory findOne(Integer categoryId);//id查找一个 List&lt;ProductCategory&gt; findAll();//查找全部 List&lt;ProductCategory&gt; findByCategoryTypeIn(List&lt;Integer&gt; categoryTypeList);//根据商品种类找 ProductCategory save(ProductCategory productCategory);//保存&#125; 具体的实现虽然不麻烦，只是重载之前ProductCategoryRepository的Jpa函数，但是还是这样比较清晰：12345678910111213141516171819202122232425262728293031323334353637383940package com.imooc.sell.service.impl;import com.imooc.sell.dataobject.ProductCategory;import com.imooc.sell.repository.ProductCategoryRepository;import com.imooc.sell.service.CategoryService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * 类目接口具体实现 * Created by Citrix on 2018/5/3. */@Servicepublic class CategoryServiceImpl implements CategoryService&#123; @Autowired private ProductCategoryRepository repository; @Override public ProductCategory findOne(Integer categoryId) &#123; return repository.findById(categoryId).get();//这边本来是自带的findOne函数，不过在spring更新之后变成了findById而且还得加get()函数 &#125; @Override public List&lt;ProductCategory&gt; findAll() &#123; return repository.findAll(); &#125; @Override public List&lt;ProductCategory&gt; findByCategoryTypeIn(List&lt;Integer&gt; categoryTypeList) &#123; return repository.findByCategoryTypeIn(categoryTypeList); &#125; @Override public ProductCategory save(ProductCategory productCategory) &#123; return repository.save(productCategory); &#125;&#125; 小技巧1.cmd+shift+enter在IDEA中可以直接跳转到下一行，方便coding2.Mac上的ctrl+N（我改变按键映射）可以快速使用IDEA提供的getset之类的自动生成函数 小问题1.第一次遇到用BigDecimal类型的变量，作用是精确计算，具体使用方式暂且留着2.在单元测试ProductServiceImplTest遇到了Page以及PageRequest的类，先留着3.项目之后打成JAR包部署的时候会自带项目名称，在.yml文件中添加123server: servlet: context-path: /sell 4.遇到了lambda表达式，之后学习Java8语法的时候格外注意5.用到了beanutil的方法，但不是很懂12BeanUtils.copyProperties(productInfo,productInfoVO);//用到了bean的方法productInfoVOList.add(productInfoVO); 又一次使用枚举为了程序的清晰性和可维护性，将程序中使用的一些状态码写成枚举的类型：12345678910111213141516171819202122package com.imooc.sell.enums;import lombok.Getter;/** * Created by Citrix on 2018/5/4. */@Getter//也是lombak的好东西public enum ProductStatusEnum &#123; //枚举数据类型 UP(0,"在架"), DOWN(1,"下架") ; //变量 private Integer code; private String message; //构造函数 ProductStatusEnum(Integer code, String message) &#123; this.code = code; this.message = message; &#125;&#125; 回顾@RestController是@ResponseBody和@Controller的组合注解，目的是返回json格式 Json格式设计1GET /sell/buyer/product/list 参数 1无 返回 1234567891011121314151617181920212223242526272829303132&#123; "code": 0, "msg": "成功", "data": [ &#123; "name": "热榜", "type": 1, "foods": [ &#123; "id": "123456", "name": "皮蛋粥", "price": 1.2, "description": "好吃的皮蛋粥", "icon": "http://xxx.com", &#125; ] &#125;, &#123; "name": "好吃的", "type": 2, "foods": [ &#123; "id": "123457", "name": "慕斯蛋糕", "price": 10.9, "description": "美味爽口", "icon": "http://xxx.com", &#125; ] &#125; ]&#125; 比较复杂，在程序中分成了三层类实现（ResultVO+ProductVO+ProductInfoVO）：1234567891011121314151617package com.imooc.sell.VO;import lombok.Data;/** * Created by Citrix on 2018/5/4. */@Datapublic class ResultVO&lt;T&gt; &#123; /*错误码*/ private Integer code; /*提示信息*/ private String msg; /*具体内容*/ private T data;&#125; 123456789101112131415161718192021package com.imooc.sell.VO;import com.fasterxml.jackson.annotation.JsonProperty;import lombok.Data;import java.util.List;/** * 商品（包含类目） * Created by Citrix on 2018/5/4. */@Datapublic class ProductVO &#123; @JsonProperty("name") private String categoryName; @JsonProperty("type") private Integer categoryType; @JsonProperty("foods") private List&lt;ProductInfoVO&gt; productVOList;&#125; 1234567891011121314151617181920212223242526272829package com.imooc.sell.VO;import com.fasterxml.jackson.annotation.JsonProperty;import lombok.Data;import java.math.BigDecimal;/** * 商品详情 * Created by Citrix on 2018/5/4. */@Datapublic class ProductInfoVO &#123; @JsonProperty("id") private String productId; @JsonProperty("name") private String productName; @JsonProperty("price") private BigDecimal productPrice; @JsonProperty("description") private String productDescription; @JsonProperty("icon") private String productIcon;&#125; 其中的@JsonProperty(“XXX”)注解作用是，后端的变量和到时候传到前端的变量名字不一样，因为如果全按照之前的json格式在定义本地变量，必然造成变量名重复和混乱，还有一点，可以发现传回带前端的数据少于后端的数据，实际情况大多数也是，有些数据比如（库存）不会轻易的让别人知道。 返回数据统一化为了避免在返回给前端的过程中重复写（定义变量,set一些，save一些，return之类），将其写成一个类，并且写好三个函数（带参success，无参success，带参error）123456789101112131415161718192021222324252627package com.imooc.sell.utils;import com.imooc.sell.VO.ResultVO;/** * Created by Citrix on 2018/5/4. */public class ResultVOUtil &#123; public static ResultVO success(Object object)&#123; ResultVO resultVO = new ResultVO(); resultVO.setData(object); resultVO.setCode(0); resultVO.setMsg("成功"); return resultVO; &#125; public static ResultVO success()&#123; return success(null); &#125; public static ResultVO error(Integer code, String msg)&#123; ResultVO resultVO = new ResultVO(); resultVO.setCode(code); resultVO.setMsg(msg); return resultVO; &#125;&#125;]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot学习笔记3]]></title>
    <url>%2F2018%2F05%2F03%2FSpring-boot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[之前按照spring boot的视频依葫芦画瓢，虽然知道了大体框架，但是很多细节方面的问题都被带过了，现在回顾一下。 框架整个工程可以分为4个模块1.java主程序2.test单元测试模块3.资源模块（.yml用于配置数据库)4.maven的pom.xml模块（用于添加依赖） 数据库操作这个工程用到的是spring boot的jpa功能，在实际的代码中不出现sql语句，而是采用传递变量的方式。需要自定义一个接口文件（extends JpaRepository），在这个文件中代码很少，有许多默认的数据库操作函数，当然也可以自定义自己的操作函数：12345678910package com.citrix.girl.repository;import com.citrix.girl.domain.Girl;import org.springframework.data.jpa.repository.JpaRepository;import java.util.List;public interface GirlResponsitory extends JpaRepository&lt;Girl,Integer&gt;&#123;// 通过年龄来查询 public List&lt;Girl&gt; findByAge(Integer age);&#125; 数据库的对象本次项目中的数据库对象是girl的属性，将其写成girl的类，定义里面的参数（与数据库中对于）有id,cupsize,age,money,然后再类里面写好必要的get set方法，再写一个tostring方法便于打印带控制台。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.citrix.girl.domain;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.validation.constraints.Min;import javax.validation.constraints.NotNull;//注解表示类对于数据库中的表@Entitypublic class Girl &#123; @Id//表示表中的id @GeneratedValue//表示id是默认升序的 private Integer id; private String cupSize; @Min(value = 18,message = "未成年少女禁止入门")//对age的最小值进行限定 private Integer age; @NotNull(message = "金额必填")//对金额的有无进行限定 private Double money; public Girl() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getCupSize() &#123; return cupSize; &#125; public void setCupSize(String cupSize) &#123; this.cupSize = cupSize; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override//因为重写了父类的方法 public String toString() &#123; return "Girl&#123;" + "id=" + id + ", cupSize='" + cupSize + '\'' + ", age=" + age + ", money=" + money + '&#125;'; &#125;&#125; 异常管理首先，传统的异常只能接受string选项，功能受限，我们先定义自己的异常函数，主要是加入了异常代码：12345678910111213141516package com.citrix.girl.exception;import com.citrix.girl.enums.ResultEnum;//继承的是runtime的exception因为spring不会对一般的exception进行回滚public class GirlException extends RuntimeException&#123; private Integer code; public GirlException(ResultEnum resultEnum) &#123; super(resultEnum.getMsg());//super是指父类的 this.code = resultEnum.getCode(); &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125;&#125; 这里我们对异常的种类进行了枚举限定，因为这样会显得比较有有序：1234567891011121314151617181920212223242526272829303132333435package com.citrix.girl.enums;/** * Created by Citrix on 2018/4/29. *///作用是限制自定义异常的错误码随便使用public enum ResultEnum &#123; UNKONW_ERROR(-1,"未知错误"), SUCCESS(0,"成功"), PRIMARY_SCHOOL(100,"还在上小学"), MIDDLE_SCHOOL(101,"还在上初中"), ;//枚举的显示表现 private Integer code; private String msg; //枚举的构造函数 ResultEnum(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; //基本的getset方法 public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 做好异常的自定义之后，开始设计异常处理函数：1234567891011121314151617181920212223242526272829package com.citrix.girl.handle;import com.citrix.girl.domain.Girl;import com.citrix.girl.domain.Result;import com.citrix.girl.exception.GirlException;import com.citrix.girl.util.ResultUtil;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;@ControllerAdvicepublic class ExceptionHandle &#123; private final static org.slf4j.Logger logger = LoggerFactory.getLogger(ExceptionHandle.class); @ExceptionHandler(value = Exception.class)//异常处理注解 @ResponseBody// //捕获异常的方法 public Result handle(Exception e) &#123; //如果这个异常是在我自定义异常范围内的 if (e instanceof GirlException) &#123; GirlException girlException = (GirlException) e; return ResultUtil.error(girlException.getCode(), girlException.getMessage()); &#125; else &#123; //显示未知错误异常 logger.error("【系统异常】&#123;&#125;",e); return ResultUtil.error(-1, "未知错误"); &#125; &#125;&#125; 最后，为了对前端数据的统一性，将正确信息和异常信息进行统一格式的处理：1234567891011121314151617181920212223242526package com.citrix.girl.util;import javax.xml.transform.Result;public class ResultUtil &#123; //正确操作的话 public static com.citrix.girl.domain.Result success(Object object)&#123; com.citrix.girl.domain.Result result = new com.citrix.girl.domain.Result(); result.setCode(0); result.setMsg("成功"); result.setData(object); return result; &#125; public static com.citrix.girl.domain.Result success()&#123; return success(null); &#125; //出错的话，将错误信息的msg进行返回 public static com.citrix.girl.domain.Result error(Integer code,String msg)&#123; com.citrix.girl.domain.Result result = new com.citrix.girl.domain.Result(); result.setCode(code); result.setMsg(msg); return result; &#125;&#125; 其中的result也是对于返回数据进行了类的封装，为的是对前端来说更加统一：12345678910111213141516171819202122232425262728293031323334package com.citrix.girl.domain;//这边的&lt;T&gt;还是不是很理解，实际使用的时候感觉T是一个类 public class Result&lt;T&gt; &#123; //错误码 private Integer code; //提示信息 private String msg; //具体的内容 private T data; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 日志123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.citrix.girl.aspect;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.*;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.ServletRequest;import javax.servlet.http.HttpServletRequest;@Aspect@Componentpublic class HttpAspect &#123; private final static org.slf4j.Logger logger = LoggerFactory.getLogger(HttpAspect.class); //这边是切面操作，是自定义的，还不是很懂，大概是执行GirlController时会监测 @Pointcut("execution(public * com.citrix.girl.controller.GirlController.*(..))") public void log()&#123; &#125; //注解含义是在接受请求后进行处理之前，进行日志记录，"log()"是指之前与切面注解绑定的函数，这样就省得每次写，也是切面的好处 @Before("log()") public void doBefore(JoinPoint joinPoint)&#123; ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); //url logger.info("url=&#123;&#125;",request.getRequestURL()); //method logger.info("method=&#123;&#125;",request.getMethod()); //ip logger.info("ip=&#123;&#125;",request.getRemoteAddr()); //类方法 logger.info("class_method=&#123;&#125;",joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName()); //参数 logger.info("args=&#123;&#125;",joinPoint.getArgs()); &#125; //注解含义是在接受请求后进行处理之后，进行日志记录 @After("log()") public void doAfter()&#123; logger.info("22222222"); &#125; //注解含义是在返回给前端之后进行的操作 @AfterReturning(returning = "object",pointcut = "log()") public void doAfterReturning(Object object)&#123; logger.info("response=&#123;&#125;",object.toString()); &#125;&#125;]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编写习惯]]></title>
    <url>%2F2018%2F05%2F02%2FJava%E7%BC%96%E5%86%99%E4%B9%A0%E6%83%AF%2F</url>
    <content type="text"><![CDATA[写好单词写好变量大小写:变量小写，方法小写，类名大写长度:单子个字字母的变量只能在3/5内解决含义:少用temp,it,do等没有意义的词；界面组件用匈牙利命名法（btnSayHello） 使用中间变量经常使用的一个写起来比较长的变量，写成中间变量。 写好常量不要从天上掉下了一个数:1.常量用final,static2.字符串常量如BorderLayout.CENTER3.从配置中获取4.使用java.util.Properties类的load() 写好语句简单语句写好赋值语句 分支语句使用括号 循环语句变量局部化 使用卫语句写好函数使用卫语句降低层次还有try-catch的正确使用，lambda表达式的使用 语句不要太多将一段语句提出来，形成新的函数 层次不要太多将内部语句提出来，形成新的函数 改变算法如果太复杂了，说明思路不够清晰 写好类和对象对象的功能是独立的1.高聚合、低耦合2.不要太多的成员 处理好对象之间的关系1.继承与实现接口2.关联：使用构造方法和普通方法3.更复杂的：使用设计模式 定律写简单程序代码永远不要写两遍]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java编写习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记3]]></title>
    <url>%2F2018%2F04%2F30%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[之前在慕课网上学完《Spring Boot进阶之Web进阶》和《2小时学会Spring Boot》中间遇到了不少java语法上的问题，不过当时就先跳过了，现在把之前不会的知识点进补充学习。 对象与类Java在面向对象上比C++做的更加彻底，下面来介绍一下。 类之间的关系1.依赖（uses-a）: 一个类的方法操作另外一个类的对象2.聚合（has-a）:类A的对象包含类B的对象3.继承（is-a）:表示特殊与一般关系的 对象与对象变量1.一个对象变量并没有实际包含一个对象，而仅仅是引用一个对象（C++中指针生成对象的感觉）12Date birthday;//javaDate* birthday;//C++ 2.指针没有初始化的话，会直接报错，而不是产生随机数，不必担心内存管理问题3.必须使用clone方法获得对象的完整拷贝 用户自定义类1.一个源文件，只有有一个公有类，但是可以有任意的私有类2.建议类内变量设为private，方法（一般）设为public 构造函数1.构造器没有返回值2.构造器总是伴随着new操作仪器调用3.在方法中不要命名与实例域（类中前面定义的）同名的变量 隐式参数与显式参数在每一个方法中，关键字this表示隐式参数1234public void abc(double d)&#123; double e = this.g * d; this.g += e;&#125; 有些程序员喜欢这个风格，因为可以讲局部变量和实例域明显的区分开来。Java程序的方法定义都是在类内部，但这表示他们是内联方法。 静态域和静态方法1.实例域定义为final，构建对象时必须初始化这样的域2.域定义为static的话，每个类只有只有一个这样的域，而每个对象的所有实例域都有自己的拷贝3.静态变量使用的少，静态常量使用的多，比如π4.静态方法是一种不能对对象进行操作的方法，即没有this参数5.静态方法可以访问吱自身类中的静态域6.可以使用对象来调用静态方法，但是建议使用类名，而不是对象 方法参数1.Java程序设计对对象引用是值传递2.一个方法不能修修改一个基本数据类型的参数3.一个方法可以改变一个对象参数的状态4.一个方法不能让对象参数引用一个新的对象 类设计技巧1.一定要保证数据私有2.一定要对数据初始化.3.不要在类中使用过多的基本类型4.不是所有的域都需要独立的域访问器和域更改器5.将职责过多的类进行分解6.类名和方法名要能体现他们的职责 接口Java中，接口不是类，而是对类的一组需求描述。 接口的特性比如下面的Flyable接口就定义了三个方法：12345678public interface Runner &#123;void run();&#125;public interface Swimmer &#123;void swim();&#125;public interface Flyable &#123; abstract void fly(); void land(); void takeoff();&#125; 1.接口的所有方法都自动属于public2.接口不能实例化，而且也不能在接口内实现方法3.实现接口的时候一定要声明为public为了让类实现接口，通常需要以下两个步骤：1.对类声明为实现给定的接口2.对接口中的所有方法进行定义3.用关键词implements12345678910111213abstract class Animal &#123; int age; abstract public void eat();&#125;class Person extends Animal implements Runner,Swimmer,Flyable &#123; public void run() &#123; System.out.println("run"); &#125; public void swim() &#123; System.out.println("swim"); &#125; public void eat() &#123; System.out.println("eat"); &#125; public void fly() &#123; System.out.println("fly");&#125; public void land()&#123; System.out.println("land");&#125; public void takeoff()&#123; System.out.println("takeoff");&#125;&#125; 接口与抽象类接口与抽象类有点相似，为什么不直接用抽象类？比如：123456abstract class Comparable&#123; public abstract int compareTo(Object)&#125;class Employee extends Comparable&#123; public int compareTo(Object other)&#123;...&#125;&#125; 因为抽象类有个问题，每个类只能拓展与一个类，下面的例子：1234class Employee extends Comparable，Person //errorclass Employee extends Comparable implements Person //ok&#125; 实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。 泛型泛型总体来说有点像C++的模板，作用是对于不同的参数类型实现相同的方法，但是本质上Java的泛型和C++的模板还是很不一样的。 定义简单的泛型类12345678910111213141516171819202122232425262728293031323334import java.util.*;class GenericTreeClass &#123; public static void main(String[] args)&#123; TNode&lt;String&gt; t = new TNode&lt;&gt;("Roo"); t.add("Left"); t.add("Middle"); t.add("Right"); t.getChild(0).add("aaa"); t.getChild(0).add("bbb"); t.traverse(); &#125;&#125;class TNode&lt;T&gt;&#123; private T value; private ArrayList&lt;TNode&lt;T&gt;&gt; children = new ArrayList&lt;&gt;(); TNode(T v) &#123; this.value = v; &#125; public T getValue() &#123; return this.value; &#125; public void add(T v) &#123; TNode&lt;T&gt; child = new TNode&lt;&gt;(v); this.children.add(child); &#125; public TNode&lt;T&gt; getChild(int i) &#123; if ((i &lt; 0) || (i &gt; this.children.size())) return null; return (TNode&lt;T&gt;)this.children.get(i); &#125; public void traverse() &#123; System.out.println(this.value); for (TNode child : this.children) child.traverse(); &#125;&#125; 泛型方法泛型方法既可以定义在普通类中，也可以定义在泛型类中，要放在函数的前面。12345678910111213141516171819202122import java.util.*;class GenericMethod &#123; public static void main(String[] args)&#123; Date date = BeanUtil.&lt;Date&gt;getInstance("java.util.Date"); System.out.println(date); &#125;&#125;class BeanUtil&#123; public static &lt;T&gt; T getInstance( String clzName )&#123; try &#123; Class c = Class.forName(clzName); return (T) c.newInstance(); &#125; catch (ClassNotFoundException ex)&#123;&#125; catch (InstantiationException ex)&#123;&#125; catch (IllegalAccessException ex)&#123;&#125; return null; &#125;&#125; 类型变量的限定1.使用？1reverse(List&lt;?&gt; list) 2.使用extends1addAll(Collection&lt;? extends E&gt; col) 3.使用super1fill(List&lt;? super T&gt;list,T obj) 总体来说，泛型是比较高级的机制，有点难，之后有需求再详细学习。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot学习笔记2]]></title>
    <url>%2F2018%2F04%2F27%2FSpring-boot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[慕课网上的《2小时学会Spring Boot》学习结束,后半段主要讲了spring通过jpa操作Mysql数据库的操作，用到了测试软件postman（亲测很好用，界面又好看），在mac端安装了MySQL数据库，使用mac端的Navicat Premium作为数据库的workbench（这个老师虽然讲得好，但是用的例子略显猥琐，我这边虽然照着他也用了这个例子，可是这并不是我的本意/(ㄒoㄒ)/~~）。 spring-data-jpaJPA全称Java Persistence API.JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。 利用JPA创建MySQL数据库pom.xml加入JPA和MySQL的依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 配置JPA和数据库12345678910111213spring: profiles: active: a datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/dbgirl username: root password: 你猜 jpa: hibernate: ddl-auto: update show-sql: true 创建与数据表对应的实体类Person这边就不贴代码了，我懒。 创建接口GirlResponsitory接口继承自JpaRepository，在之后控制部分都要用到GirlResponsitory。其中findByAge函数是自定义的用来根据年龄找出女生数组的函数。 12345public interface GirlResponsitory extends JpaRepository&lt;Girl,Integer&gt;&#123;// 通过年龄来查询 public List&lt;Girl&gt; findByAge(Integer age);&#125; 创建控制器GirlController这个是核心的操作数据库逻辑的文件，具体不解释了，看代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.citrix.girl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import javax.persistence.criteria.CriteriaBuilder;import javax.sql.rowset.serial.SerialStruct;import java.util.List;@RestControllerpublic class GirlController &#123; @Autowired private GirlResponsitory girlResponsitory; @Autowired private GirlService girlService; /* * 查询女生列表 * @return * */ @GetMapping(value = "/girls") public List&lt;Girl&gt; girlList()&#123; return girlResponsitory.findAll(); &#125; /* * 添加一个女生 * */ @PostMapping(value = "/girls") public Girl girlAdd(@RequestParam("cupSize") String cupSize, @RequestParam("age") Integer age) &#123; Girl girl = new Girl(); girl.setCupSize(cupSize); girl.setAge(age); return girlResponsitory.save(girl); &#125; /* * 查询一个女生 * */ @GetMapping(value = "/girls/&#123;id&#125;") public Girl girlFindOne(@PathVariable("id") Integer id)&#123; return girlResponsitory.findById(id).get(); &#125; /* * 更新一个女生 * */ @PutMapping(value = "/girls/&#123;id&#125;") public Girl girlUpdate(@PathVariable("id") Integer id, @RequestParam("cupSize") String cupSize, @RequestParam("age") Integer age )&#123; Girl girl = new Girl(); girl.setId(id); girl.setCupSize(cupSize); girl.setAge(age); return girlResponsitory.save(girl); &#125; /* * 删除一个女生 * */ @DeleteMapping(value = "/girls/&#123;id&#125;") public void girlDelete(@PathVariable("id") Integer id)&#123; girlResponsitory.deleteById(id); &#125; /* * 根据年龄来查找女生列表 * */ @GetMapping(value = "/girls/age/&#123;age&#125;") public List&lt;Girl&gt; girlListByAge(@PathVariable("age") Integer age)&#123; return girlResponsitory.findByAge(age); &#125; /* *添加两个女生，相应的处理在GirlService里面 * */ @PostMapping(value = "/girls/two") public void girlTwo()&#123; girlService.insertTwo(); &#125;&#125; 创建服务GirlService添加Service方法的事务注解@Transactional，该方法遇到错误即可自动回滚，代码如下：12345678910111213141516171819202122232425package com.citrix.girl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import javax.transaction.Transactional;@Servicepublic class GirlService &#123; @Autowired private GirlResponsitory girlResponsitory; @Transactional public void insertTwo()&#123; Girl girlA = new Girl(); girlA.setCupSize("A"); girlA.setAge(18); girlResponsitory.save(girlA); Girl girlB = new Girl(); girlB.setCupSize("B"); girlB.setAge(19); girlResponsitory.save(girlB); &#125;&#125; 其中@Transactional注解配合@Service可以使得，两条数据要嘛同时插入，要不同时不插入。]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot学习笔记]]></title>
    <url>%2F2018%2F04%2F26%2FSpring-boot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[跟着慕课网上的《2小时学会Spring Boot》学习，发现讲解比较简单，适合像我这样的初学者学习，记录一下每个章节学到的知识点，主要以学习springboot框架为主. Controller的使用请求部分1.@Controller:处理HTTP请求2.@RestController:spring4之后新加的注解，原来返回json需要@RequestBody+@Controller3.@RequestMapping:配置url映射 如果单独使用@Controller的话，需要配合模板使用，首先在pom.xml配置spring的thymeleaf，然后再resources目录下建立相应的templates文件夹，再在这个文件夹下写一个index.html，这种方法带来的性能损耗较大，实际开发中前后端分离，不会这样做的，后端提供接口和json格式的数据就行。 @RequestMapping可以将请求映射到多个url下，实际代码如下:1@RequestMapping(value = &#123;"/hello"，"/hi"&#125;,method = RequestMethod.GET) 就使得下面的url内容一致。12http://127.0.0.1:8080/hellohttp://127.0.0.1:8080/hi 还有就是可以在整体在前面加一个“hello”字段，然后下面再加“say”字段，如下：123456789101112@RestController@RequestMapping("hello")public class HelloController &#123; @Autowired private GirlProperties girlProperties; @RequestMapping(value = "/say",method = RequestMethod.GET) public String say()&#123; return girlProperties.getCupSize(); &#125;&#125; 参数部分1.@PathVariable:获取url的数据2.@RequestParam:获取请求参数的值3.@GetMapping:组合注解 使用以下的代码:1234@RequestMapping(value = "/say/&#123;id&#125;",method = RequestMethod.GET)public String say(@PathVariable("id") Integer id)&#123; return "id" + id;&#125; 就可以获取到下面url中100的这个值。1http://127.0.0.1:8080/hello/say/100 使用以下的代码:1234@RequestMapping(value = "/say",method = RequestMethod.GET)public String say(@RequestParam(value = "id",required = false,defaultValue = "0") Integer myid)&#123; return "id" + myid; &#125; 就可以获取到下面url中100的这个值。1http://127.0.0.1:8080/hello/say/?id=100 而且由于@RequestParam设置的默认参数，就算是下面这样：1http://127.0.0.1:8080/hello/say/?id= 也能显示id0。由于下面代码效果等价，但是第二种写法更加短小，所以推荐使用第二种写法。12@RequestMapping(value = "/say",method = RequestMethod.GET)@GetMapping(value = "/say")]]></content>
      <categories>
        <category>Spring boot</category>
      </categories>
      <tags>
        <tag>Spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记2]]></title>
    <url>%2F2018%2F04%2F25%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[这次将书中第三章的其余内容进行扫尾工作，主要是详细介绍数组为主。 数组之前在做LeetCode的时候，就发现大量涉及到字符串和数组的操作，所以在此主要介绍一下Java中的数组操作。在声明数组的之后需要初始化才可以使用，例如：12int[] a;int[] a = new int[100]; 第一句只有声明，第二句使用new之后才真正创造出了数组。注意:一旦创建了数组，就不能改变它的大小，如果想改的话用数组列表（array list）。 for each循环Java里面有一种和python中（for word in words）类似的很好用的循环语句。Java中的用法是如下： 1for each word in words 这种写法更加简洁且不易出错。 数组初始化以及匿名函数 12int[] a = &#123;1,2,3,4,5&#125;;int[] a = new int[100]; 第一种方法不需要new，直接赋值即可；第二种方法需要。 数组拷贝 12int[] a = b;a[5] = 12; 这样a,b两个变量引用同一个数组，相当于其指针指向的数据区是一样的。如果希望拷贝到一个新的数组而不是公用一个数组的时候，可以使用array类的copyto方法，例如： 1int[] a = Arrays.copyOf(a,a.length); 数组排序Array类中有sort方法，如下： 12int[] a = new int[100];Arrays.sort(a); 方法使用了快速排序算法。 多维数组没啥好说的，和其它语言类似，不过想要快速打印二维数组的数据元素列表的话，有个函数如下： 1System.out.println(Arrays.deepToString(a)); 控制流程&amp;大数值1.不能在嵌套层的两个块中声明同名的变量2.case分支语句的末尾没有break语句，会执行下一个case分支语句，这种情况非常危险3.Java额外提供了一种带标签的break语句，用于跳出多重嵌套的循环语句 4.与C++不同，Java没有提供运算符重载功能]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记1]]></title>
    <url>%2F2018%2F04%2F24%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[正好最近完成了蒋老师的DES课程小作业，也是第一次用Java语言配合Intellij IDEA完成开发，中间遇到了一些问题，当时就在网上找找原因解决了，不过又想着最近在看《Java核心技术》，索性借此系统梳理一下知识点。 字符串首当其冲的问题就是各种数据类型和字符串了，其中short,int,byte,double,char之类和C++类似，需要注意其字节长度。但是string的使用还是挺不一样的，在此说明一下。 首先，每个使用双括号括起来的字符串都是string类的一个实例，例如：12String e = "";String greeting = "Hello"; 子串String类的substring方法可以从一个较大的字符串中提取一个子串。例如：12String e = "";String greeting.substring(0,3); 注意其提取范围是左开右闭，其长度很有容易计算，就是3-0=3。 拼接Java语言允许使用+号连接字符串，这个很方便，例如：123String a = "qian";String b = "citrix";String name = a + b; 不过+号左边是字符串，右边是变量，则变量会被转换成字符串，例如：12int a = 24;String age = "age:" + a; 不可变字符串String类没有提供修改字符串的方法，这是个很不方便的特性，尤其是想简单的在string末尾价格字符的时候。虽然可以通过前面子串和拼接组合的方式膈应的完成。但是其也有优点，那就是编译器可以让字符串共享（我还不是很理解）。总而言之，Java的设计者觉得共享带来的高效远大于提取，拼接字符串带来的低效。 检测字符串是否相等可以使用equals方法检测两个字符串是否相等(可以是字符串和变量比)。例如：12s.equals(t);"hello".equals(greeting); 不区分大小写的话，可以使用：1"hello".equalsIgnoreCase(greeting); 但是注意,一定不能使用==运算符，这个运算符只能够确定两个字符是不是放在同一个位置上。（实际上只有字符串常量是共享的，而+和substring产生的结果不是）。 空串与NULL串空串””是长度为0的字符串，而NULL串没有对象与该变量关联。 构建字符串如果需要用许多小段的字符串拼接成一个大字符串，一直用用连接的方式效率很低，此时，可以先建立一个空的字符串构建器:1StringBuilder builder = new StringBuilder(); 每次需要添加一部分内容的时候，就使用append方法。1builder.append(ch); 构建完成时调用toString方法，就可以得到一个string对象。1String completed = builder.toString(); 数据类型&amp;变量&amp;运算符这些知识内容基本和C++重叠，就稍微记录一下Java不同的地方和注意点。1.Java对大小写不敏感2.建议使用骆驼命名法（CamelCase）3.很少情况下使用float4.逐一命名每一个变量可以提高代码可读性5.声明变量后必须使用赋值语句对变量进行显式初始化6.变量的声明尽可能靠近它第一次被使用的地方7.使用关键字final指示常量，表明智能被赋值一次8.&gt;&gt;&gt;运算符用0填充高位，&gt;&gt;用符号位填充，没有&lt;&lt;&lt;运算符9.数值类型转换会将精度低的自动变成精度高的类型10.希望变量在有限集合里面的话可以使用枚举类型enum]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
