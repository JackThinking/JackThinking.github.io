<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Citrix&#39;s Blog</title>
  
  <subtitle>All work and no play make Citrix a dull boy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-20T12:39:12.555Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Citrix Qian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每周总结2</title>
    <link href="http://yoursite.com/2018/10/15/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%932/"/>
    <id>http://yoursite.com/2018/10/15/每周总结2/</id>
    <published>2018-10-15T03:16:09.000Z</published>
    <updated>2018-10-20T12:39:12.555Z</updated>
    
    <content type="html"><![CDATA[<p>昨天做了到利用HashMap的Sum类型题，感觉其思路挺有意思的，联想到LeetCode第一题Two Sum的高效解法也是用的HashMap，所以在此归纳总结下这类题目的深层次理解。</p><h1 id="Two-sum-1-——（无序数组）"><a href="#Two-sum-1-——（无序数组）" class="headerlink" title="Two sum(1)——（无序数组）"></a>Two sum(1)——（无序数组）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hm.containsKey(target - nums[i])) &#123;</span><br><span class="line">                index[<span class="number">1</span>] = i;</span><br><span class="line">                index[<span class="number">0</span>] = hm.get(target - nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hm.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始我的想法是很粗暴的，就是想每两个值加起来和target比较一下，但是实际上这效率太低，实际使用可以在之后的数数组中找是否有target-i的数，没有的话用一个map记录每个值和其序号，便于后面的寻找。</p><h1 id="Two-Sum-II-167-——（排序数组）"><a href="#Two-Sum-II-167-——（排序数组）" class="headerlink" title="Two Sum II(167)——（排序数组）"></a>Two Sum II(167)——（排序数组）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (numbers[l] + numbers[r] != target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[l] + numbers[r] &gt; target) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用其有序性，设立两个标志从左右加，将其和与target比较即可。</p><h1 id="Two-Sum-IV-653-——（TODO）"><a href="#Two-Sum-IV-653-——（TODO）" class="headerlink" title="Two Sum IV(653)——（TODO）"></a>Two Sum IV(653)——（TODO）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, list);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = list.get(l) + list.get(r);</span><br><span class="line">            <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; k) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BST的中序遍历是有序的，问题就简化为上一小题了，但是这种方法并不高效，之后可以改进。</p><h1 id="Subarray-Sum-Equals-K-560"><a href="#Subarray-Sum-Equals-K-560" class="headerlink" title="Subarray Sum Equals K(560)"></a>Subarray Sum Equals K(560)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashmap.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(sum-k))&#123;</span><br><span class="line">                count+= hashmap.get(sum-k);</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap.put(sum, hashmap.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题提供了一个新思路，如果我想遍历长度的5的各种可能性，我改怎么办？比如我想试试1,2,3,4,5；{1,2}{2,3}{3,4}等等直到{1,2,3,4,5}；这道题的告诉我们可以用sum[j]-sum[i]的方式，并将其值存在map里面，map的存的是sum[i]即按序累加的值，当sum[j]-sum[i]的时候，就可以出现各种子情况了。</p><h1 id="Combination-Sum-39-——（DEBUG）"><a href="#Combination-Sum-39-——（DEBUG）" class="headerlink" title="Combination Sum(39)——（DEBUG）"></a>Combination Sum(39)——（DEBUG）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        helper(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),candidates,<span class="number">0</span>,target);<span class="comment">//new出来的不要具体说明的嘛?</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> remain)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remain == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));<span class="comment">//为什么不直接add list呢？</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (remain&lt;candidates[i])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                helper(list,candidates,i,remain-candidates[i]);</span><br><span class="line">                list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题利用了dfs的思路，而且同样使用了sum题基本思路，把本来加起来的sum变成remain(target-nums[i])，这样在不断的dfs的时候，remain的值不断变化。这道题还要注意到的是数据可以重复利用，所以其start的值不需要每层加1；最后要注意的是dfs到底部发现不满足的话要把最靠近底部的值给弹出去；add(list)的时候要用new出来的，负责list的内容会是最终状态，这个之后debug再理解。</p><h1 id="Path-Sum-112"><a href="#Path-Sum-112" class="headerlink" title="Path Sum(112)"></a>Path Sum(112)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, sum, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp += root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; temp == sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left, sum, temp) || helper(root.right, sum, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathSum的第一题简单，都是老套路，dfs的时候把remain或者sum值放在函数里面传递。</p><h1 id="Path-Sum-II-113"><a href="#Path-Sum-II-113" class="headerlink" title="Path Sum II(113)"></a>Path Sum II(113)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, sum, <span class="number">0</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> num, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(root.val);</span><br><span class="line">            num += root.val;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; num == sum) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">                temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                helper(root.left, sum, num, temp);</span><br><span class="line">                helper(root.right, sum, num, temp);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题融合了PathSum的性质和CombinationSum的要求，就是把数组找出来，这样我们需要在dfs函数上加一个temp的list来记录当前遍历的数组内容，再设一个全局list变量来作为return的ans，其他思路照旧。</p><h1 id="Path-Sum-III-437-——（DEBUG）"><a href="#Path-Sum-III-437-——（DEBUG）" class="headerlink" title="Path Sum III(437)——（DEBUG）"></a>Path Sum III(437)——（DEBUG）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        helper(root, sum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> tempSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tempSum += root.val;</span><br><span class="line">        res += map.getOrDefault(tempSum - sum, <span class="number">0</span>);<span class="comment">//??????</span></span><br><span class="line">        map.put(tempSum, map.getOrDefault(tempSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        helper(root.left, sum, tempSum);</span><br><span class="line">        helper(root.right, sum, tempSum);</span><br><span class="line">        map.put(tempSum, map.get(tempSum) - <span class="number">1</span>);<span class="comment">//?????????</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前两道pathsum都是说好从根节点到子节点的，这到题就没说了，这样按照之前的思路，我们需要一个map来记录；最后照旧，需要在dfs后把尾部弹出，不过这里还不是很理解，要再看看。</p><h1 id="Target-Sum-494-——（TODO）"><a href="#Target-Sum-494-——（TODO）" class="headerlink" title="Target Sum(494)——（TODO）"></a>Target Sum(494)——（TODO）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        helper(nums, <span class="number">1</span>, S - nums[<span class="number">0</span>]);</span><br><span class="line">        helper(nums, <span class="number">1</span>, S + nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(nums, index + <span class="number">1</span>, target - nums[index]);</span><br><span class="line">        helper(nums, index + <span class="number">1</span>, target + nums[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种dfs中的方式，一种是存sum的累加值，一种是放taregt-nums[i]的值，两种方式的详细区别之后在看看。明天改成sum的形式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天做了到利用HashMap的Sum类型题，感觉其思路挺有意思的，联想到LeetCode第一题Two Sum的高效解法也是用的HashMap，所以在此归纳总结下这类题目的深层次理解。&lt;/p&gt;
&lt;h1 id=&quot;Two-sum-1-——（无序数组）&quot;&gt;&lt;a href=&quot;#Two
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Two Sum" scheme="http://yoursite.com/tags/Two-Sum/"/>
    
  </entry>
  
  <entry>
    <title>每周总结1</title>
    <link href="http://yoursite.com/2018/10/14/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%931/"/>
    <id>http://yoursite.com/2018/10/14/每周总结1/</id>
    <published>2018-10-14T07:15:09.000Z</published>
    <updated>2018-10-18T03:02:53.925Z</updated>
    
    <content type="html"><![CDATA[<p>之前的每日算法更新结束，文章多了后，hexo编译好慢，而且每天写的话有点浪费时间，算法题还是每天在做，之后改成总结更新类的方式。</p><h1 id="TreeNode-easy系列题"><a href="#TreeNode-easy系列题" class="headerlink" title="TreeNode-easy系列题"></a>TreeNode-easy系列题</h1><ol><li>Maximum Depth of Binary Tree（树的深度）</li><li>Validate Binary Search Tree（二叉搜索树的判定）</li><li>Symmetric Tree（对称树-学到了helper的双遍历）</li><li>Binary Tree Level Order Traversal（根据树的深度来找同一层的点，helper函数需要加入level属性）</li><li>Convert Sorted Array to Binary Search Tree（有序数组变成二叉搜索树-中序遍历的特点-需要在helper函数里面不断的找中点，然后左右递归，边界条件要注意）</li></ol><h1 id="TreeNode-middle系列题"><a href="#TreeNode-middle系列题" class="headerlink" title="TreeNode-middle系列题"></a>TreeNode-middle系列题</h1><ol><li>Binary Tree Inorder Traversal（树的中序遍历）</li><li>Binary Tree Zigzag Level Order Traversal（Z形level遍历，在原有easy的基础上对add函数做一下小处理，在末端加入，有点trick的感觉）</li><li>Construct Binary Tree from Preorder and Inorder Traversal（根据先序中序遍历结果进行重新排列，有点难度，搞清楚就是先序的节点作为中序数组的分界点）</li><li>Populating Next Right Pointers in Each Node（给树增加右向指针，可以好好理解BFS和DFS的区别）</li><li>Kth Smallest Element in a BST（根据二叉搜索树的特点统计每个节点左右两边的节点个数，依据个数来找出index的node）</li><li>Number of I slands（可以说是比较经典的二维图遍历了，用dfs的思路进行遍历，找到后变0，这样之后再遇到就不会对下一个图产生误导了）</li></ol><h1 id="TreeNode-hard系列题"><a href="#TreeNode-hard系列题" class="headerlink" title="TreeNode-hard系列题"></a>TreeNode-hard系列题</h1><ol><li>Word Ladder（很难，从首到尾BFS将相差1个字的单词从原有数组去掉，加入到该level的数组中）</li><li>Surrounded Regions（二维数组，去掉被包围的点，这道题是逆向思维，从4条边缘进行dfs,将遇到的点给值，然后再遍历的时候，如果没有被给值就直接变成X）</li><li>Lowest Common Ancestor of a Binary Tree（这道题还是要在看一下YouTube视频理解一下，是一道经典题）</li><li>Binary Tree Maximum Path Sum（二叉树上的最大路径，基于DFS，需要识别负数，return的时候有点技巧）</li><li>Friend Circles（朋友圈，也是用dfs，不过要理解visited的含义）</li><li>Course Schedule（拓扑搜索，用一个set和dp的数组来解决）</li><li>Course Schedule II（用一个stack和一个set可以解决）</li><li>Longest Increasing Path in a Matrix（二维数据的找最大上升序列，需要一个visited数组作数据记录）</li><li>Alien Dictionary</li><li>Count of Smaller Numbers After Self（其实这道题换个角度理解就是一个个进行二分插入，统计插入位置的index，进index进行记录）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前的每日算法更新结束，文章多了后，hexo编译好慢，而且每天写的话有点浪费时间，算法题还是每天在做，之后改成总结更新类的方式。&lt;/p&gt;
&lt;h1 id=&quot;TreeNode-easy系列题&quot;&gt;&lt;a href=&quot;#TreeNode-easy系列题&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Treenode" scheme="http://yoursite.com/tags/Treenode/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷68</title>
    <link href="http://yoursite.com/2018/09/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B768/"/>
    <id>http://yoursite.com/2018/09/25/每日一刷68/</id>
    <published>2018-09-25T12:56:33.000Z</published>
    <updated>2018-09-25T13:15:10.156Z</updated>
    
    <content type="html"><![CDATA[<p>简单的5到tree综合总结（104、98、101、102、108）<br>代码就不贴了，暂时就说说感想：</p><ul><li>tree的题基本都是可以用递归做的，可以用来巩固递归的知识</li><li>tree的遍历基本知识：先中后序遍历，层次遍历及递归与非递归实现</li><li>tree的树高，对称判断，建树等基本操作的递归实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单的5到tree综合总结（104、98、101、102、108）&lt;br&gt;代码就不贴了，暂时就说说感想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tree的题基本都是可以用递归做的，可以用来巩固递归的知识&lt;/li&gt;
&lt;li&gt;tree的遍历基本知识：先中后序遍历，层次遍历及递归与非递归
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Treenode" scheme="http://yoursite.com/tags/Treenode/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷67</title>
    <link href="http://yoursite.com/2018/09/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B767/"/>
    <id>http://yoursite.com/2018/09/09/每日一刷67/</id>
    <published>2018-09-09T11:50:55.000Z</published>
    <updated>2018-09-25T12:57:38.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="241-Different-Ways-to-Add-Parentheses"><a href="#241-Different-Ways-to-Add-Parentheses" class="headerlink" title="241. Different Ways to Add Parentheses"></a>241. Different Ways to Add Parentheses</h1><p>iven a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.<br><strong>Example 1:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"2-1-1"</span></span><br><span class="line">Output: [<span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">Explanation: </span><br><span class="line">((<span class="number">2</span><span class="number">-1</span>)<span class="number">-1</span>) = <span class="number">0</span> </span><br><span class="line">(<span class="number">2</span>-(<span class="number">1</span><span class="number">-1</span>)) = <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"2*3-4*5"</span></span><br><span class="line">Output: [<span class="number">-34</span>, <span class="number">-14</span>, <span class="number">-10</span>, <span class="number">-10</span>, <span class="number">10</span>]</span><br><span class="line">Explanation: </span><br><span class="line">(<span class="number">2</span>*(<span class="number">3</span>-(<span class="number">4</span>*<span class="number">5</span>))) = <span class="number">-34</span> </span><br><span class="line">((<span class="number">2</span>*<span class="number">3</span>)-(<span class="number">4</span>*<span class="number">5</span>)) = <span class="number">-14</span> </span><br><span class="line">((<span class="number">2</span>*(<span class="number">3</span><span class="number">-4</span>))*<span class="number">5</span>) = <span class="number">-10</span> </span><br><span class="line">(<span class="number">2</span>*((<span class="number">3</span><span class="number">-4</span>)*<span class="number">5</span>)) = <span class="number">-10</span> </span><br><span class="line">(((<span class="number">2</span>*<span class="number">3</span>)<span class="number">-4</span>)*<span class="number">5</span>) = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; operaters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        split(input,nums,operaters);<span class="comment">//以后有想法就先把函数写出来再说</span></span><br><span class="line">        <span class="keyword">return</span> calculate(nums, operaters, <span class="number">0</span>, nums.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(String input, List&lt;Integer&gt; nums, List&lt;String&gt; operaters)</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();<span class="comment">//不需要预先设置长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> character = input.charAt(i);<span class="comment">//charAt充当遍历器</span></span><br><span class="line">            <span class="keyword">if</span> (character == <span class="string">'+'</span> || character == <span class="string">'-'</span> || character == <span class="string">'*'</span>)&#123;</span><br><span class="line">                nums.add(Integer.valueOf(sb.toString()));<span class="comment">//是错位的加法</span></span><br><span class="line">                sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                operaters.add(character+<span class="string">""</span>);<span class="comment">//只是为了char 2 string,一定要是双引号</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(character);<span class="comment">//这么感觉有点蠢，之后再看看</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.add(Integer.valueOf(sb.toString()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">calculate</span><span class="params">(List&lt;Integer&gt; nums, List&lt;String&gt; operaters, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//这个是要返回的结果呀</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 写结束条件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (start == end)&#123;</span><br><span class="line">            res.add(nums.get(start));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 一般处理情况</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; left = calculate(nums, operaters, start, i);</span><br><span class="line">            List&lt;Integer&gt; right = calculate(nums, operaters, i+<span class="number">1</span>, end);</span><br><span class="line">            mergelist(left, right, res, operaters.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergelist</span><span class="params">(List&lt;Integer&gt; left, List&lt;Integer&gt; right, List&lt;Integer&gt; res, String operator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; right.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = operate(left.get(i), right.get(j), operator);</span><br><span class="line">                res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String operator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (operator)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                <span class="keyword">return</span> i+j;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                <span class="keyword">return</span> i-j;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                <span class="keyword">return</span> i*j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数字符合种类合集</p><ul><li>分治的思想</li><li>程序较为复杂，自己还hold不住</li><li>对于string字符串中数据的提取很不熟练</li><li>对于switch基本函数的运用</li><li>对于stringbuilder的运用</li><li>递归的基本思想实践能力不行</li><li>程序的逻辑性分析大体倒是对了</li><li>最近事情多，不能静下心来思考很伤</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;241-Different-Ways-to-Add-Parentheses&quot;&gt;&lt;a href=&quot;#241-Different-Ways-to-Add-Parentheses&quot; class=&quot;headerlink&quot; title=&quot;241. Different Way
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷66</title>
    <link href="http://yoursite.com/2018/09/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B766/"/>
    <id>http://yoursite.com/2018/09/05/每日一刷66/</id>
    <published>2018-09-05T07:40:57.000Z</published>
    <updated>2018-09-24T14:03:00.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a>138. Copy List with Random Pointer</h1><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * class RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode next, random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;RandomListNode,RandomListNode&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 节点意义复制到map中</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        RandomListNode point = head;</span><br><span class="line">        <span class="keyword">while</span>(point!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(point,<span class="keyword">new</span> RandomListNode(point.label));</span><br><span class="line">            point = point.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 指针重新指向开头的地方</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        point = head;</span><br><span class="line">        <span class="keyword">while</span>(point!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.get(point).next = map.get(point.next);</span><br><span class="line">            map.get(point).random = map.get(point.random);</span><br><span class="line">            point = point.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带随机指针链表的深拷贝:</p><ul><li>做的不明所以</li><li>步骤能能够理解，但是效率不高，之后可以再改进</li><li>最近一周实在是效率低下，装机也要适可而止，不能影响到日常生活</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;138-Copy-List-with-Random-Pointer&quot;&gt;&lt;a href=&quot;#138-Copy-List-with-Random-Pointer&quot; class=&quot;headerlink&quot; title=&quot;138. Copy List with Random
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷65</title>
    <link href="http://yoursite.com/2018/09/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B765/"/>
    <id>http://yoursite.com/2018/09/04/每日一刷65/</id>
    <published>2018-09-04T08:25:30.000Z</published>
    <updated>2018-09-24T14:03:00.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h1><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><p><strong>Example</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortByPartition(lists, <span class="number">0</span>, lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">sortByPartition</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 递归先确定结束条件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (start == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 经典的分治理念，切半，递归递归，合并</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        ListNode left = sortByPartition(lists, start, mid);</span><br><span class="line">        ListNode right = sortByPartition(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> merge(left,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 同样是递归，先要确定结束条件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 链表合并总是要有连接的过程的，这边需要额外注意</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (left.val&lt;right.val)&#123;</span><br><span class="line">            left.next = merge(left.next,right);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right.next = merge(left,right.next);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常经典非常好的题-多链表按序合并</p><ul><li>可以使用优先级队列（但是这样使用了内建函数）</li><li><p>最后参考的方法是分治，其有着有一定的规律，比如先中分，俩边递归，然后合并</p></li><li><p>链表合并的递归函数还是蛮经典的，之后要会默写</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;23-Merge-k-Sorted-Lists&quot;&gt;&lt;a href=&quot;#23-Merge-k-Sorted-Lists&quot; class=&quot;headerlink&quot; title=&quot;23. Merge k Sorted Lists&quot;&gt;&lt;/a&gt;23. Merge k Sort
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷64</title>
    <link href="http://yoursite.com/2018/08/31/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B764/"/>
    <id>http://yoursite.com/2018/08/31/每日一刷64/</id>
    <published>2018-08-31T07:40:10.000Z</published>
    <updated>2018-09-24T14:03:00.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a>148. Sort List</h1><p>Sort a linked list in O(n log n) time using constant space complexity.</p><p><strong>Example 1:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">-1</span>-&gt;<span class="number">5</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">0</span></span><br><span class="line">Output: <span class="number">-1</span>-&gt;<span class="number">0</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 链表合并的递归方式，妙的很，理解上需要从最后一步反推，链表的连接像是倒着连一样</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode h1, ListNode h2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> h2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> h1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h1.val&lt;h2.val)&#123;</span><br><span class="line">            h1.next = merge(h1.next,h2);</span><br><span class="line">            <span class="keyword">return</span> h1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            h2.next = merge(h1,h2.next);</span><br><span class="line">            <span class="keyword">return</span> h2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 同样是递归，原理是归并排序的原理，先分开排序再进行合并，具体原理再多理解一下</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 归并的第一步：确定最后的返回条件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 快慢指针达到二分的效果</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        ListNode slow = head, fast = head, pre = head;<span class="comment">//pre存储slow指针的上一个节点，用于分割</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 由于有快指针，循环条件要以快的那个为准，而且要有两种情况，以防跳到null</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * x.next进行分割；不同于slow = slow.next是指针滑动</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 归并的一般推演逻辑</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        ListNode h1 = sortList(head);</span><br><span class="line">        ListNode h2 = sortList(slow);</span><br><span class="line">        <span class="keyword">return</span> merge(h1,h2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        ListNode.print(solution.sortList(ListNode.createTestData(<span class="string">"[2,1,3,5]"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表排序题：</p><ul><li>用到的排序原理是归并</li><li>不知道为啥不用其他排序算法</li><li>各种排序算法优劣学习</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;148-Sort-List&quot;&gt;&lt;a href=&quot;#148-Sort-List&quot; class=&quot;headerlink&quot; title=&quot;148. Sort List&quot;&gt;&lt;/a&gt;148. Sort List&lt;/h1&gt;&lt;p&gt;Sort a linked list in O(
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷63</title>
    <link href="http://yoursite.com/2018/08/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B763/"/>
    <id>http://yoursite.com/2018/08/30/每日一刷63/</id>
    <published>2018-08-30T13:35:10.000Z</published>
    <updated>2018-09-24T14:03:00.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a>61. Rotate List</h1><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.<br><strong>Example 1:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: <span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">2</span> steps to the right: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL, k = <span class="number">4</span></span><br><span class="line">Output: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">2</span> steps to the right: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">0</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">3</span> steps to the right: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">4</span> steps to the right: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head, pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = head;</span><br><span class="line">        k %= count;</span><br><span class="line">        <span class="keyword">int</span> left = count-k;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>旋转链表题：</p><ul><li>先连成环；再走到起点；把终点断开</li><li>连成环是一种新的基本思想</li><li>如果需要使用某一位置之前的一个指针时，可以在while循环里用pre=cur来记录，然后让cur自增</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;61-Rotate-List&quot;&gt;&lt;a href=&quot;#61-Rotate-List&quot; class=&quot;headerlink&quot; title=&quot;61. Rotate List&quot;&gt;&lt;/a&gt;61. Rotate List&lt;/h1&gt;&lt;p&gt;Given a linked list,
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷62</title>
    <link href="http://yoursite.com/2018/08/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B762/"/>
    <id>http://yoursite.com/2018/08/29/每日一刷62/</id>
    <published>2018-08-29T11:52:59.000Z</published>
    <updated>2018-09-24T14:03:00.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a>160. Intersection of Two Linked Lists</h1><p>Write a program to find the node at which the intersection of two singly linked lists begins.<br>For example, the following two linked lists:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure></p><p>begin to intersect at node c1.<br><strong>Notes</strong>:</p><ul><li>If the two linked lists have no intersection at all, return null.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pointA = headA;</span><br><span class="line">        ListNode pointB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pointA!=pointB)&#123;</span><br><span class="line">            pointA = pointA == <span class="keyword">null</span> ? headB : pointA.next;</span><br><span class="line">            pointB = pointB == <span class="keyword">null</span> ? headA : pointB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pointA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找公共起始点：</p><ul><li>核心问题是两条链路长度不一样怎么办？</li><li>我的写法是写计数两个指针到null的值，然后让其中一个先走几步，但是显然有点蠢</li><li>答案的方法很妙，如果两者长度相同，不会超时额外操作；如果不用的话根据x+y=y+x的原理，走完自己这里的链路再走对方的链路，总长度一定一样，一定能找到</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;160-Intersection-of-Two-Linked-Lists&quot;&gt;&lt;a href=&quot;#160-Intersection-of-Two-Linked-Lists&quot; class=&quot;headerlink&quot; title=&quot;160. Intersection of
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷61</title>
    <link href="http://yoursite.com/2018/08/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B761/"/>
    <id>http://yoursite.com/2018/08/29/每日一刷61/</id>
    <published>2018-08-29T08:34:31.000Z</published>
    <updated>2018-09-24T14:03:00.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a>92. Reverse Linked List II</h1><p>Reverse a linked list from position m to n. Do it in one-pass.</p><p><strong>Note:</strong> 1 ≤ m ≤ n ≤ length of list.</p><p><strong>Example</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, m = <span class="number">2</span>, n = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode start = pre.next;</span><br><span class="line">        ListNode then = start.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-m ; i++) &#123;</span><br><span class="line">            start.next = then.next;</span><br><span class="line">            then.next = pre.next;</span><br><span class="line">            pre.next = then;</span><br><span class="line">            then = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表指定区间反转：</p><ul><li>自己的方法没有顾忌到结尾的反转</li><li>对于链表指针的熟悉使用</li><li>这道题是有点绕的</li><li>x.next = y.next（链路重置）</li><li>x = x.next; (指针移动，不影响原来的链路)</li><li>x.next = y（建立链路链接）</li><li>x = y.next（同理）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;92-Reverse-Linked-List-II&quot;&gt;&lt;a href=&quot;#92-Reverse-Linked-List-II&quot; class=&quot;headerlink&quot; title=&quot;92. Reverse Linked List II&quot;&gt;&lt;/a&gt;92. Revers
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷60</title>
    <link href="http://yoursite.com/2018/08/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B760/"/>
    <id>http://yoursite.com/2018/08/28/每日一刷60/</id>
    <published>2018-08-28T11:54:08.000Z</published>
    <updated>2018-09-24T14:03:00.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328. Odd Even Linked List"></a>328. Odd Even Linked List</h1><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p><p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p><p><strong>Example 1:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">4</span>-&gt;<span class="number">7</span>-&gt;NULL</span><br><span class="line">Output: <span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span>-&gt;<span class="number">1</span>-&gt;<span class="number">5</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong></p><ul><li>The relative order inside both the even and odd groups should remain as it was in the input.</li><li>The first node is considered odd, the second node even and so on …</li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode odd = head, even = head.next, evenhead = even;<span class="comment">//指针定位</span></span><br><span class="line">            <span class="keyword">while</span>(even!=<span class="keyword">null</span>&amp;&amp;even.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                odd.next = odd.next.next;<span class="comment">//编织链表</span></span><br><span class="line">                even.next = even.next.next;</span><br><span class="line">                odd = odd.next;<span class="comment">//链表向后拓展</span></span><br><span class="line">                even = even.next;</span><br><span class="line">            &#125;</span><br><span class="line">            odd.next = evenhead;<span class="comment">//evenhead保存even头部位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>链表奇偶改造：</p><ul><li>道理不难</li><li>没有必要新建链表保存数据</li><li>基本功不扎实</li><li>有<code>.next.next</code>形式时七while条件往往是<code>(even!=null&amp;&amp;even.next!=null)</code></li><li>两个指针时，考虑奇偶情况，以位置靠后的那个为准，一般是偶数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;328-Odd-Even-Linked-List&quot;&gt;&lt;a href=&quot;#328-Odd-Even-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;328. Odd Even Linked List&quot;&gt;&lt;/a&gt;328. Odd Even
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷59</title>
    <link href="http://yoursite.com/2018/08/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B759/"/>
    <id>http://yoursite.com/2018/08/25/每日一刷59/</id>
    <published>2018-08-25T07:55:37.000Z</published>
    <updated>2018-09-24T14:03:00.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="445-Add-Two-Numbers-II"><a href="#445-Add-Two-Numbers-II" class="headerlink" title="445. Add Two Numbers II"></a>445. Add Two Numbers II</h1><p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Follow up</strong>:<br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p><p><strong>Example</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: (<span class="number">7</span> -&gt; <span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">Output: <span class="number">7</span> -&gt; <span class="number">8</span> -&gt; <span class="number">0</span> -&gt; <span class="number">7</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s1.add(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s2.add(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(! s1.empty() || !s2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (! s1.empty())&#123;</span><br><span class="line">                temp += s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (! s2.empty())&#123;</span><br><span class="line">                temp += s2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            head.val = temp%<span class="number">10</span>;</span><br><span class="line">            ListNode tempnode = <span class="keyword">new</span> ListNode(temp/<span class="number">10</span>);<span class="comment">//考虑最后一步</span></span><br><span class="line">            tempnode.next = head;<span class="comment">//指向反转</span></span><br><span class="line">            head = tempnode;<span class="comment">//指向反转</span></span><br><span class="line">            temp = temp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.val == <span class="number">0</span> ? head.next:head;<span class="comment">//同样为了考虑最后一步</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表加法的升级版，顺序反过来了：</p><ul><li>思路一致</li><li>不准反转</li><li>使用堆栈</li><li>由于链路指向反过来了，细节上需要注意</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;445-Add-Two-Numbers-II&quot;&gt;&lt;a href=&quot;#445-Add-Two-Numbers-II&quot; class=&quot;headerlink&quot; title=&quot;445. Add Two Numbers II&quot;&gt;&lt;/a&gt;445. Add Two Number
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷58</title>
    <link href="http://yoursite.com/2018/08/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B758/"/>
    <id>http://yoursite.com/2018/08/25/每日一刷58/</id>
    <published>2018-08-25T06:45:50.000Z</published>
    <updated>2018-09-24T14:03:00.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h1><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">Output: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//新建链表头，当做返回值</span></span><br><span class="line">        ListNode point = result;<span class="comment">//设立指针</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位标志位</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//和标志位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry != <span class="number">0</span>)&#123;</span><br><span class="line">            sum = (l1 != <span class="keyword">null</span>?l1.val:<span class="number">0</span>) + (l2 != <span class="keyword">null</span>? l2.val : <span class="number">0</span>) + carry;<span class="comment">//计算和</span></span><br><span class="line">            carry = sum/<span class="number">10</span>;<span class="comment">//计算进位</span></span><br><span class="line">            ListNode temp = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);<span class="comment">//新建临时节点，用于连接</span></span><br><span class="line">            point.next = temp;<span class="comment">//建立连接</span></span><br><span class="line">            point = point.next;<span class="comment">//i++</span></span><br><span class="line">            <span class="keyword">if</span> (l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表的加法进位题：</p><ul><li>自己对于链表的概念是对的</li><li>具体思路见注释</li><li>还有提升空间见下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">       ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode point = result;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || temp != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode tempnode = <span class="keyword">new</span> ListNode(temp%<span class="number">10</span>);</span><br><span class="line">            point.next = tempnode;</span><br><span class="line">            point = point.next;</span><br><span class="line">            temp = temp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化如下：</p><ul><li>由于sum,carry,和取余值有顺序，所以一个temp按照顺序来就可以了</li><li>先当做sum</li><li>再当做取余</li><li>最后做进位</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-Add-Two-Numbers&quot;&gt;&lt;a href=&quot;#2-Add-Two-Numbers&quot; class=&quot;headerlink&quot; title=&quot;2. Add Two Numbers&quot;&gt;&lt;/a&gt;2. Add Two Numbers&lt;/h1&gt;&lt;p&gt;You are 
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷57</title>
    <link href="http://yoursite.com/2018/08/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B757/"/>
    <id>http://yoursite.com/2018/08/24/每日一刷57/</id>
    <published>2018-08-24T06:41:22.000Z</published>
    <updated>2018-09-24T14:03:00.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. Linked List Cycle II</h1><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p><strong>Note</strong>: Do not modify the linked list.</p><p>Follow up:<br>Can you solve it without using extra space?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!= <span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fast == slow)&#123;</span><br><span class="line">                ListNode slow2 = head;</span><br><span class="line">                <span class="keyword">while</span>(slow!=slow2)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    slow2 = slow2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断回环找到起始点：</p><ul><li>快慢指针</li><li>加入数学分析（A+B=N -&gt; A=N-B）根据这个找到A的值</li><li>N的值可以从图上分析得到</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;142-Linked-List-Cycle-II&quot;&gt;&lt;a href=&quot;#142-Linked-List-Cycle-II&quot; class=&quot;headerlink&quot; title=&quot;142. Linked List Cycle II&quot;&gt;&lt;/a&gt;142. Linked L
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷56</title>
    <link href="http://yoursite.com/2018/08/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B756/"/>
    <id>http://yoursite.com/2018/08/24/每日一刷56/</id>
    <published>2018-08-24T06:40:18.000Z</published>
    <updated>2018-09-24T14:03:00.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h1><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:<br>Can you solve it without using extra space?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!= <span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fast == slow)&#123;</span><br><span class="line">                ListNode slow2 = head;</span><br><span class="line">                <span class="keyword">while</span>(slow!=slow2)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    slow2 = slow2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断回环：</p><ul><li>快慢指针（要是有机会，总是能再相见）</li><li>找不到起始点的</li><li>对于while循环的判断条件要细细考虑</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;141-Linked-List-Cycle&quot;&gt;&lt;a href=&quot;#141-Linked-List-Cycle&quot; class=&quot;headerlink&quot; title=&quot;141. Linked List Cycle&quot;&gt;&lt;/a&gt;141. Linked List Cycle
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷55</title>
    <link href="http://yoursite.com/2018/08/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B755/"/>
    <id>http://yoursite.com/2018/08/23/每日一刷55/</id>
    <published>2018-08-23T11:52:03.000Z</published>
    <updated>2018-09-24T14:03:00.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a>234. Palindrome Linked List</h1><p>Given a singly linked list, determine if it is a palindrome.</p><p><strong>Example 1</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">Output: <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p><strong>Example 2</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p><strong>Follow up</strong>:<br>Could you do it in O(n) time and O(1) space?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode point = head;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(point!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s.push(point.val);</span><br><span class="line">            point = point.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val!=s.pop())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先想到的是堆栈法：</p><ul><li>先全部压如栈，再一个个弹出来比较</li><li>显然效率不高，遍历了两次</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;<span class="comment">//这个地方不要可以，可以少遍历一个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = reverse(slow);</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (slow.val!=fast.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode point = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            point.next = result;</span><br><span class="line">            result = point;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是效率较高的快慢指针法：</p><ul><li>总体应该是遍历1.5次（不确定）</li><li>利用快慢指针先对半分，然后把后半部分逆序，与前半部分一一比较</li><li>对于逆序的<code>head = head.next;point.next = result;</code>有顺序要求，head得先操作跑掉，否则point的操作影响了head</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;234-Palindrome-Linked-List&quot;&gt;&lt;a href=&quot;#234-Palindrome-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;234. Palindrome Linked List&quot;&gt;&lt;/a&gt;234. Pa
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷54</title>
    <link href="http://yoursite.com/2018/08/23/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B754/"/>
    <id>http://yoursite.com/2018/08/23/每日一刷54/</id>
    <published>2018-08-23T11:48:00.000Z</published>
    <updated>2018-09-24T14:03:00.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h1><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//(方便头部的边界问题)</span></span><br><span class="line">        ListNode point = result;<span class="comment">//（point相当于i）</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                point.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                point.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            point = point.next;<span class="comment">//（相当于i++）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            point.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            point.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;<span class="comment">//去掉头部，就可以吃了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并两个表：</p><ul><li>思路容易</li><li>确定规范（见注释）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;21-Merge-Two-Sorted-Lists&quot;&gt;&lt;a href=&quot;#21-Merge-Two-Sorted-Lists&quot; class=&quot;headerlink&quot; title=&quot;21. Merge Two Sorted Lists&quot;&gt;&lt;/a&gt;21. Merge 
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷53</title>
    <link href="http://yoursite.com/2018/08/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B753/"/>
    <id>http://yoursite.com/2018/08/22/每日一刷53/</id>
    <published>2018-08-22T12:36:16.000Z</published>
    <updated>2018-09-24T14:03:00.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h1><p>Reverse a singly linked list.</p><p><strong>Example</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">Output: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure></p><p><strong>Follow up</strong>:<br>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newhead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode tempnode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            tempnode = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            tempnode.next = newhead;</span><br><span class="line">            newhead = tempnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代法：</p><ul><li>head = head.next加上while(head!= null)作为迭代循环器</li><li>中间节点tempnode用来指选节点</li><li>新链表newhead一步步完成逆序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseListInt(head,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseListInt</span><span class="params">(ListNode head, ListNode newHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tempnode = <span class="keyword">null</span>;</span><br><span class="line">        tempnode = head;</span><br><span class="line">        head = head.next;</span><br><span class="line">        tempnode.next = newHead;</span><br><span class="line">        <span class="keyword">return</span>  reverseListInt(head,tempnode);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>回溯法：</p><ul><li>核心函数相同</li><li>将迭代的结束条件单独拎出来</li><li>用递归替代迭代的遍历</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;206-Reverse-Linked-List&quot;&gt;&lt;a href=&quot;#206-Reverse-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;206. Reverse Linked List&quot;&gt;&lt;/a&gt;206. Reverse Lin
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷52</title>
    <link href="http://yoursite.com/2018/08/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B752/"/>
    <id>http://yoursite.com/2018/08/19/每日一刷52/</id>
    <published>2018-08-19T12:24:31.000Z</published>
    <updated>2018-09-24T14:03:00.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h1><p>Given a linked list, remove the n-th node from the end of list and return its head.</p><p><strong>Example:</strong></p><p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p><p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br><strong>Note:</strong><br>Given n will always be valid.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode slow = start,fast = start;<span class="comment">//同时指向start，slow,fast操作的时候会影响到start</span></span><br><span class="line">        start.next = head;<span class="comment">//把头指向head</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 先派fast先走两步，fast在这里只是充当探底，找到倒数第二个数的作用</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 一起走两步</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 关键的操作，跳过slow后面的那个</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        slow.next = slow.next.next;<span class="comment">//但是为什么要设置一个头呢，是不是因为怕影响原始的你的node呢</span></span><br><span class="line">        <span class="keyword">return</span> start.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照python版本的写的，说实话，<del>觉得没必要加上虚拟第一个节点</del>，加上第一个节点可以避免第一个head的node造成的逻辑错误，下面的方法就是不需要的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode tmp=head,pre=head;</span><br><span class="line">        <span class="keyword">while</span>(n--!=<span class="number">0</span>)&#123;</span><br><span class="line">            tmp=tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="keyword">null</span>) <span class="keyword">return</span> head.next;<span class="comment">//list contains n ele</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(tmp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">            tmp=tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next=pre.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这一种的方法的话需要额外加一个判断，判断是不是删除第一个节点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;19-Remove-Nth-Node-From-End-of-List&quot;&gt;&lt;a href=&quot;#19-Remove-Nth-Node-From-End-of-List&quot; class=&quot;headerlink&quot; title=&quot;19. Remove Nth Node Fr
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷51</title>
    <link href="http://yoursite.com/2018/08/19/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B751/"/>
    <id>http://yoursite.com/2018/08/19/每日一刷51/</id>
    <published>2018-08-19T12:20:20.000Z</published>
    <updated>2018-09-24T14:03:00.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="237. Delete Node in a Linked List"></a>237. Delete Node in a Linked List</h1><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p><p>Given linked list – head = [4,5,1,9], which looks like following:</p><p>4 -&gt; 5 -&gt; 1 -&gt; 9</p><p><strong>Example 1</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">5</span></span><br><span class="line">Output: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">Explanation: You are given the second node <span class="keyword">with</span> value <span class="number">5</span>, the linked list</span><br><span class="line">should become <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9</span> after calling your <span class="function"><span class="keyword">function</span>.</span></span><br></pre></td></tr></table></figure></p><p><strong>Example 2</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">1</span></span><br><span class="line">Output: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">Explanation: You are given the third node <span class="keyword">with</span> value <span class="number">1</span>, the linked list</span><br><span class="line">should become <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">9</span> after calling your <span class="function"><span class="keyword">function</span>.</span></span><br></pre></td></tr></table></figure></p><p><strong>Note</strong>:</p><ul><li>The linked list will have at least two elements.</li><li>All of the nodes’ values will be unique.</li><li>The given node will not be the tail and it will always be a valid node of the linked list.</li><li>Do not return anything from your function.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;<span class="comment">//没有删除节点，而是把后面的节点转移到改节点上</span></span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接表的删除，没啥好说的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;237-Delete-Node-in-a-Linked-List&quot;&gt;&lt;a href=&quot;#237-Delete-Node-in-a-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;237. Delete Node in a Linked
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
</feed>
