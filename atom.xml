<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Citrix&#39;s Blog</title>
  
  <subtitle>All work and no play make Citrix a dull boy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-01T12:43:44.568Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Citrix Qian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>春招总结1</title>
    <link href="http://yoursite.com/2019/04/01/%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%931/"/>
    <id>http://yoursite.com/2019/04/01/春招总结1/</id>
    <published>2019-04-01T11:20:36.000Z</published>
    <updated>2019-04-01T12:43:44.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网易互娱基础平台开发二面记录"><a href="#网易互娱基础平台开发二面记录" class="headerlink" title="网易互娱基础平台开发二面记录"></a>网易互娱基础平台开发二面记录</h1><p>之前约了4月1号下午3点的网易互娱视频面试，也是我的第一次视频面试，表现的有点紧张，在此记录回顾一下。</p><p>面试主要是问了一道基础的二分搜索的算法题以及项目的一些细节，最后还问了关于岗位的一些看法和个人的兴趣。总的来说，这次表现的不是很满意，尤其是手撕代码的环节，还是暴露了自己的编程缺陷。今天着重复现一下。</p><h2 id="第一阶段：写一个最常规的二分搜索"><a href="#第一阶段：写一个最常规的二分搜索" class="headerlink" title="第一阶段：写一个最常规的二分搜索"></a>第一阶段：写一个最常规的二分搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &lt; value) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; value) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想还好，这个我平时有练过，然后3分钟写完，解释给了面试官，结果面试官马上看到缺点，说那你这个数组要是重复的数字多怎么办呢？我只要第一个target的下标。</p><h2 id="第二阶段：二分查找返回target-可能有重复-第一次出现的下标"><a href="#第二阶段：二分查找返回target-可能有重复-第一次出现的下标" class="headerlink" title="第二阶段：二分查找返回target(可能有重复)第一次出现的下标"></a>第二阶段：二分查找返回target(可能有重复)第一次出现的下标</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt; value) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; value) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> sumVal = array[mid];</span><br><span class="line">                <span class="keyword">while</span> (array[mid - <span class="number">1</span>] == sumVal) &#123;</span><br><span class="line">                    mid--;<span class="comment">//找到左边边界</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想了想还好，这道题我也遇到过，不就是找到target之后再往回找嘛，然后马上改了版代码。结果写完被面试官一顿嫌弃，首先<code>int sumVal = array[mid]</code>是不是有点多余（我去，我个脑残，不就是target嘛），然后输入1怎么办（我的测试用例第一个是1，且前面没有了，故报错），然后我又改了改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt; value) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; value) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">                <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; array[left - <span class="number">1</span>] == value) &#123;</span><br><span class="line">                    left--;<span class="comment">//找到左边边界</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下里面试官又说，你这时间复杂度分析一下，我看了看暂时不知道怎么说，然后面试官提醒说，你考虑下最差情况，中间重复的数字很多。（哦哦哦，我去，那岂不是就是遍历了，最差复杂度O(N)啊）。然后让我想想有没有复杂更低的方法。</p><h2 id="第三阶段：二分查找返回target-可能有重复-第一次出现的下标-性能提升"><a href="#第三阶段：二分查找返回target-可能有重复-第一次出现的下标-性能提升" class="headerlink" title="第三阶段：二分查找返回target(可能有重复)第一次出现的下标(性能提升)"></a>第三阶段：二分查找返回target(可能有重复)第一次出现的下标(性能提升)</h2><p>自己说实话觉得上一版已经没啥问题了，结果遇到这么一遭，后来硬着头皮又写了一版。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt; value) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; value) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> newLeft = left;</span><br><span class="line">                <span class="keyword">int</span> newRight = mid;</span><br><span class="line">                <span class="keyword">while</span>(newLeft&lt;=newRight)&#123;</span><br><span class="line">                    <span class="keyword">int</span> newMid = newLeft + (newRight-newLeft)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (array[newMid]==target)&#123;</span><br><span class="line">                        <span class="keyword">return</span> newMid;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完我自己都觉得尴尬，面试官说思路不对，二分里面再来个二分并不能解决问题，同时代码还是写错了，当时自己慌的不行，看着这代码自己也觉得难堪。后来看我还是没啥思路，面试官就放弃了。之后面试官提示说在判断条件里稍微改改就行了，面试完后自己去网上查了下，最后发现的确是这样，附上代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchWithRepeat</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &lt; value) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[left] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思想是当<code>array[mid] &lt; value</code>时，说明在右边；但是如果<code>array[mid] &gt;= value</code>就统一保持右边界为mid，因为不关心后面的target，只关心第一个target，用这种方式去向左逼近，直到left到达right，循环结束后将left的值与target比较，最终得到下标。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>这次面试暴露了之前写代码的几个问题：</li><li>不主动思考能不能进一步改进，浅尝辄止；</li><li>对于边界的掌控能力差；</li><li>面试紧张，显得不自信；</li><li>自我介绍时间短；</li><li>项目介绍有点冗杂；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网易互娱基础平台开发二面记录&quot;&gt;&lt;a href=&quot;#网易互娱基础平台开发二面记录&quot; class=&quot;headerlink&quot; title=&quot;网易互娱基础平台开发二面记录&quot;&gt;&lt;/a&gt;网易互娱基础平台开发二面记录&lt;/h1&gt;&lt;p&gt;之前约了4月1号下午3点的网易互娱视频面试，
      
    
    </summary>
    
      <category term="春招" scheme="http://yoursite.com/categories/%E6%98%A5%E6%8B%9B/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>每周总结6</title>
    <link href="http://yoursite.com/2018/11/26/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%936/"/>
    <id>http://yoursite.com/2018/11/26/每周总结6/</id>
    <published>2018-11-26T11:58:07.000Z</published>
    <updated>2018-12-27T12:04:37.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array-and-Strings-easy系列题"><a href="#Array-and-Strings-easy系列题" class="headerlink" title="Array and Strings easy系列题"></a>Array and Strings easy系列题</h1><ol><li>Remove Duplicates from Sorted Array(首先想到放到set里面；然后想到自己写的需要判断是否重复，重复了几个；后面想到由于是有序的，判断发生了几次前后不同即可-&gt;解决)</li><li>Best Time to Buy and Sell Stock II(首先想到了贪心的方法，即累加所有差值-&gt;解决)</li><li>Rotate Array(首先想到循环K次，每次循环一个，把尾巴暂存，其他书集体后移一位；答案的方法用了三次数组逆排序，数组逆排序的代码要会背-&gt;解决)</li><li>Contains Duplicate(首先想到排序后判断前后是否相同，但是这就没啥意义了；然后想到用map或者set的性质，不过这也是偷懒；看到一种解决方法是用桶，求出最大最小值后建立桶数组，然后再遍历数组，要是重复了，桶的false会变成true，虽然时间控制在常数内，但是空间复杂度太高-&gt;解决)</li><li>Single Number(首先想到了上一题，只是个不同的问法；但是考虑到只有一个出现了1次，其他都是两次，感觉会有简单方法；问题是那句不用任何的额外空间，我想不到什么点子；答案的一个方法非常有意思，由于无法用额外的空间，所以让数组前后不断的异或，由于出现两次的数异或之后会被消除，所以只剩下了那个出现了一次的数-&gt;解决)</li><li>Intersection of Two Arrays II(取两个数组的交集，无序的版本自己没有任何想法；参考答案的解法是先把数组进行排序，然后用两个指针while循环进行比较-&gt;解决；另外一种答案的解法是用hashmap存储比较，感觉不舒服的解法)</li><li>Plus One(关于进位的基本题；考验进位标志位和边界9的处理；虽然基本但是值得注意)</li><li>Move Zeroes(把0移到最后，同时保持非0部分有序；想到的第一种自然的解法是，遇到0暂存，后面全部前移一位，0放到最后；偷懒一点先排序，然后把0移到最后；答案的方法是建立一个新的索引，不等于0的时候才向前进，然后直接在原数组上覆盖，由于原数组有0的存在，指针移动位置总是大于等于新的索引指针的-&gt;解决)</li><li>Two Sum(老朋友了；首先想到的就是hashmap存储，存数找target-nums[i]-&gt;解决)</li><li>Valid Sudoku(9*9数独，行列9宫格都不能重复；自己一开始想到这题要干嘛；答案其实就是两个for循环内，用除法取余等方式一起把三个判断调节一起解决了，基本的数据类型是set-&gt;解决)</li><li>Rotate Image(旋转矩阵，看上去挺可怕的；首先想到的是按行变列，但是题目要求in-order，不能新增一个矩阵来操作；然后我想到swap()函数，但是没有多想；答案的解决方法也是建立在swap之上的，先将对角线进行互换，然后将每一行进行reverse，可见swap,reverse这些都是基本的数组字符串操作)</li><li>Reverse String(反转数组真的是好基本啊；由于string的不可变性质，所以得先换成char数组，改完后强行改回来-&gt;解决)</li><li>Reverse Integer(首先想到的是需要考虑负数和0的特殊情况；答案用除法和取余的方式巧妙的解决了，但还是要注意int的上下限问题-&gt;解决)</li><li>First Unique Character in a String(返回第一个非重复字符的index，首先想到了数组里面XOR的骚操作；然后想到了用map来记录出现的次数，然后遍历map找到第一个值为1的键即可；答案的方式思想和map一样，只不过实现更加的高效，使用char[26]的小型字典来统计出现次数然后遍历找到值为1的，其时间复杂度为O(n)</li><li>Valid Anagram(首先想到的利用上一题的小型字典，第一次加，第二次减，第三次找0)</li><li>Valid Palindrome(判断字符串对称，首先想到去掉干扰因素比如空格和标点符号，然后首尾指针移动判断，同时考虑奇偶数;实际解决思想一样，不过是用半个fori循环，直接比较首尾，还剩去了奇偶数的考虑-&gt;解决)</li><li>String to Integer (atoi)(TODO)</li><li>Implement strStr()(字符串匹配，相当的经典了；TODO；再多考虑一下当needle为空的时候如何)</li><li>Count and Say(首先会让人觉得有点难，然后想一下就是判断最大连续字符个数同时还要指出是哪一个字符的问题；TODO)</li><li>Longest Common Prefix(最长公共序列，又是一道经典题；TODO)<h1 id="Array-and-Strings-middle系列题"><a href="#Array-and-Strings-middle系列题" class="headerlink" title="Array and Strings middle系列题"></a>Array and Strings middle系列题</h1><h2 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a>3Sum</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || (i &gt;= <span class="number">1</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">int</span> lo = i + <span class="number">1</span>, hi = nums.length - <span class="number">1</span>, sum = <span class="number">0</span> - nums[i];</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[lo] + nums[hi] == sum) &#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + <span class="number">1</span>]) &#123;</span><br><span class="line">                            lo++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="number">1</span>]) &#123;</span><br><span class="line">                            hi--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lo++;</span><br><span class="line">                        hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo] + nums[hi] &lt; sum) &#123;</span><br><span class="line">                        lo++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        hi--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(solution.threeSum(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>首先看到3sum，的确想到了2sum。也想到了挨个把0-nums[i]当做target套用2sum的做法，但是总是没有具体成型的思路，大概看了下答案其实就懂了，关键是先做了排序，然后之后的2sum找值就是简化版的了（双指针移动），同时在一些地方做一下剪枝就大功告成了。</p><h2 id="Set-Matrix-Zeroes"><a href="#Set-Matrix-Zeroes" class="headerlink" title="Set Matrix Zeroes"></a>Set Matrix Zeroes</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span> fcol = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> frow = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span>) frow = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) fcol = <span class="keyword">true</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (frow) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcol) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的矩阵操作到是熟练的，但是这道题为了效率还是做了不少改进的，比如我在第一次做的时候感觉需要额外的数组来记录哪些行或列需要变零，但是解法巧妙的使用了第一行和第一列作为记录，然后在第二次循环中，以此为判断进行第二次变零，同时考虑到第一行或第一列自己本身也要变零的可能性，还特意设置了标志位进行补充（这边的标志位自己做的时候搞错了）。</p><h2 id="Group-Anagrams"><a href="#Group-Anagrams" class="headerlink" title="Group Anagrams"></a>Group Anagrams</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] dict = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span>&#125;;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">                k *= dict[c - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;String&gt; t;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 判断指纹是不是第一次出现以及出现的层数，用map来记录</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(k)) &#123;</span><br><span class="line">                t = res.get(map.get(k));<span class="comment">//获取层数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//新建新的template</span></span><br><span class="line">                res.add(t);<span class="comment">//添加进res里</span></span><br><span class="line">                map.put(k, res.size() - <span class="number">1</span>);<span class="comment">//在map中加入指纹</span></span><br><span class="line">            &#125;</span><br><span class="line">            t.add(str);<span class="comment">//在确定的层数插入字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题思路还比较清晰的，首先是要确定字符的指纹（即字母出现过即值相同，首先想到了微型字典的想法，但是数组之间比较效率不高，后面用了素数法，其实可以再深入考虑下hash的原理），确定了指纹之后需要判断是不是第一次出现，如果不是的话需要在第几层插入该数字。这就需要用一个map来记录指纹和指纹所在的层数了，接下去的代码就好写了，这道题告诉我需要在编程钱确定好该考虑的问题和思路。</p><h2 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a>Longest Substring Without Repeating Characters</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                j = Math.max(j, map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i), i);</span><br><span class="line">            max = Math.max(max, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然题目不难，但还是没有自己一口气写出来，自己本来是想用微型字典代替map来记录字符状态的，也不是不行，可以再尝试一次，map的方法的话还是好理解的，i,j两个指针进行滑动，i总是滑动，j的话遇到已经出现过的，就向后滑动。</p><h2 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a>Longest Palindromic Substring</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> secondMin = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= min) &#123;</span><br><span class="line">                min = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt;= secondMin) &#123;</span><br><span class="line">                secondMin = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题我以为是最长上升子序列的特殊情况题（当然，最长上升子序列太经典了），但是由于其指定了只要三个（往往三个就可以大大简化问题，想起之前那个0，1，2的移位排序了嘛），所以换种角度想，只要找到一个数比两个数大就行了，原理就是不断的维护已遍历的最小值和第二小值，然后找到一个数比他们大即可。</p><h1 id="Array-and-Strings-hard系列题（不做了，反正到时候也不一定做出来）"><a href="#Array-and-Strings-hard系列题（不做了，反正到时候也不一定做出来）" class="headerlink" title="Array and Strings hard系列题（不做了，反正到时候也不一定做出来）"></a>Array and Strings hard系列题（不做了，反正到时候也不一定做出来）</h1><p>Product of Array Except Self<br>Spiral Matrix<br>4Sum II<br>Container With Most Water<br>Game of Life<br>First Missing Positive<br>Longest Consecutive Sequence<br>Find the Duplicate Number<br>Longest Substring with At Most K Distinct Characters<br>Basic Calculator II<br>Sliding Window Maximum<br>Minimum Window Substring</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Array-and-Strings-easy系列题&quot;&gt;&lt;a href=&quot;#Array-and-Strings-easy系列题&quot; class=&quot;headerlink&quot; title=&quot;Array and Strings easy系列题&quot;&gt;&lt;/a&gt;Array and S
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Array and Strings" scheme="http://yoursite.com/tags/Array-and-Strings/"/>
    
  </entry>
  
  <entry>
    <title>每周总结5</title>
    <link href="http://yoursite.com/2018/11/26/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%935/"/>
    <id>http://yoursite.com/2018/11/26/每周总结5/</id>
    <published>2018-11-26T11:48:47.000Z</published>
    <updated>2018-12-02T12:09:18.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sorting-and-Searching-easy系列题"><a href="#Sorting-and-Searching-easy系列题" class="headerlink" title="Sorting and Searching easy系列题"></a>Sorting and Searching easy系列题</h1><ol><li>Merge Sorted Array(这个问题只真是火，链表里面有，归并排序里有，这边也有，不过这次的版本是不需要另建数据的版本，也算是有一点不一样，考虑的东西还是4个判断，只不顾过这道题的方法有个简单的技巧，值得留意)</li><li>First Bad Version(找到true和false的临界点，算是有序的一种表现，最容易想到的是二分搜索的方法)<h1 id="Sorting-and-Searching-middle系列题"><a href="#Sorting-and-Searching-middle系列题" class="headerlink" title="Sorting and Searching middle系列题"></a>Sorting and Searching middle系列题</h1><h2 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a>Sort Colors</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = n - <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= p2) &#123;<span class="comment">//这边写错了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[index] = nums[p1];<span class="comment">//这边也写错了</span></span><br><span class="line">                nums[p1] = <span class="number">0</span>;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] == <span class="number">2</span>) &#123;</span><br><span class="line">                nums[index] = nums[p2];</span><br><span class="line">                nums[p2] = <span class="number">2</span>;</span><br><span class="line">                p2--;</span><br><span class="line">                index--;<span class="comment">//这个地方没有考虑到，</span></span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>三种颜色的分类，想到的是三向切分的思想，设立中间元素，遍历的时候把小于他的都换到前面，大于他的都换到后面，等于自己的时候按兵不动。但是需要细细考虑，遍历的index与大小部分索引i,j的关系。尤其是循环截止条件和把大数交换后要对这个大数重新判断。（返回去看一下三向切分的具体实现）</p><h2 id="Top-K-Frequent-Elements"><a href="#Top-K-Frequent-Elements" class="headerlink" title="Top K Frequent Elements"></a>Top K Frequent Elements</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt;[] bucket = <span class="keyword">new</span> List[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 按照值的大小进行排序，不熟练啊卧槽，这个和桶排序是什么关系呀</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> freq = map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (bucket[freq] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bucket[freq] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            bucket[freq].add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 按照值的大小进行弹出</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length; i &gt; <span class="number">0</span> &amp;&amp; res.size() &lt; k; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.addAll(bucket[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是问出现频率最K高的数字，那首先我得统计频率，这个是跑不掉了，然后因为这道题只需要前K高的数字，所以我首先想到的是优先级队列，因为优先级队列对求最大值有着不错的效率，之后我又想到优先级队列的存在的对象得是一个键值对，因为我需要根据值（频率的大小）找到相应的键输出。<br>但是我的算法效率并不是很高，所以之后去看了高效答案，他用的是一个桶排序，每个桶是一个ArrayList（有可能几个元素出现的频率是一样的），由于桶的数组是直接按照最坏情况考虑的，所以存在着一定的冗余，但好处是可以提供有序性，最后一次按照桶的逆序和要求k的大小，将相应的值填入到res中就可以得到答案。</p><h2 id="Kth-Largest-Element-in-an-Array"><a href="#Kth-Largest-Element-in-an-Array" class="headerlink" title="Kth Largest Element in an Array"></a>Kth Largest Element in an Array</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,n-<span class="number">1</span>,n-k);</span><br><span class="line">        <span class="keyword">return</span> nums[n-k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start  + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = choosePivot(nums[mid], nums[start], nums[end]);</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = end;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (nums[j] &gt; pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] != nums[j]) &#123;</span><br><span class="line">                    swap(nums, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= i - <span class="number">1</span>)&#123;</span><br><span class="line">            quickSort(nums, start, i - <span class="number">1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            quickSort(nums, i, end, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">choosePivot</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt; a)&#123;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c &gt; b)&#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt; b)&#123;</span><br><span class="line">                <span class="keyword">return</span> b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c &gt; a)&#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于找指定大小的数字，其实就和排序差不多了，想到排序一般就快排和归并排序，快排的话还有些改进的算法（三向，去中位数哨兵等），归并的话也有些改进的算法（不用交换而是整体后移or不建立新的数组还是改用其他的）。这边我用是中位数改进快排。</p><h2 id="Find-Peak-Element"><a href="#Find-Peak-Element" class="headerlink" title="Find Peak Element"></a>Find Peak Element</h2><p>看到这题，第一个想法自然是要找的数需要进行前后比较，但是最后的答案让我有点懵逼<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&lt;nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">                left = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这道题最后的解法利用了二分搜索，但是改动了条件找到了区间峰值。TODO</p><h2 id="Search-for-a-Range-TODO"><a href="#Search-for-a-Range-TODO" class="headerlink" title="Search for a Range(TODO)"></a>Search for a Range(TODO)</h2><p>这道题是在给定有序的情况下找到目标值的范围，找到其中一个值的想法倒是容易，用二分总是能找到，问题是找到一个后需要进行前后遍历，找到边界值</p><h2 id="Merge-Intervals-TODO"><a href="#Merge-Intervals-TODO" class="headerlink" title="Merge Intervals(TODO)"></a>Merge Intervals(TODO)</h2><p>区间合并，要把重叠的子数组合并成长数组</p><h2 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 找到了就返回坐标</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 大于左边的话，说明左边序列一定是递增的</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;=nums[left])&#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 接着判断目标值是不是在递增区间之内</span></span><br><span class="line"><span class="comment">                * */</span></span><br><span class="line">                <span class="keyword">if</span> (target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span> (target&gt;nums[mid]&amp;&amp;target&lt;=nums[right])&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两段有序数组之间找到目标值（无重复），有序数组找值自然想到二分，但是要处理有个分界点的问题，此处需要加入额外的条件进行区分</p><h2 id="Search-a-2D-Matrix-II"><a href="#Search-a-2D-Matrix-II" class="headerlink" title="Search a 2D Matrix II"></a>Search a 2D Matrix II</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = matrix[row][col];</span><br><span class="line">            <span class="keyword">if</span> (num == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; target) &#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的第一题是行有序，列有序，且行列之间前后也有序，那其实就是套用二分的模板，这边的第二题则行列之间有序性去除，但是从右上角的角度去观察的话，其实会发现这是一颗变相的二叉树，依次按照二分的思想去找依旧能和找到。</p><h1 id="Sorting-and-Searching-hard系列题"><a href="#Sorting-and-Searching-hard系列题" class="headerlink" title="Sorting and Searching hard系列题"></a>Sorting and Searching hard系列题</h1><h2 id="Wiggle-Sort-II-水平不够，完全没有思路-TODO"><a href="#Wiggle-Sort-II-水平不够，完全没有思路-TODO" class="headerlink" title="Wiggle Sort II(水平不够，完全没有思路)(TODO)"></a>Wiggle Sort II(水平不够，完全没有思路)(TODO)</h2><h2 id="Kth-Smallest-Element-in-a-Sorted-Matrix-TODO"><a href="#Kth-Smallest-Element-in-a-Sorted-Matrix-TODO" class="headerlink" title="Kth Smallest Element in a Sorted Matrix(TODO)"></a>Kth Smallest Element in a Sorted Matrix(TODO)</h2><h2 id="Median-of-Two-Sorted-Arrays-TODO"><a href="#Median-of-Two-Sorted-Arrays-TODO" class="headerlink" title="Median of Two Sorted Arrays(TODO)"></a>Median of Two Sorted Arrays(TODO)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> &amp;&amp; nums2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                len2 = nums2.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                len1 = nums1.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                len1 = nums1.length;</span><br><span class="line">                len2 = nums2.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((len1+len2)%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">double</span>) (findKth(nums1, <span class="number">0</span> ,len1 , nums2, <span class="number">0</span>,len2, (len1+len2)/<span class="number">2</span>)+findKth(nums1, <span class="number">0</span> ,len1 , nums2, <span class="number">0</span>,len2, (len1+len2)/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">double</span>) (findKth(nums1, <span class="number">0</span> ,len1 , nums2, <span class="number">0</span>,len2, (len1+len2)/<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> len1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> len2, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 统一为len1更小，方便处理</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (len1&gt;len2)&#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums2, start2, len2, nums1, start1, len1, k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 循环结束条件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums2[start2+k-<span class="number">1</span>];</span><br><span class="line">        &#125; </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 额外的循环结束条件</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[start1],nums2[start2]);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 最核心的一般处理过程，包含divide</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">int</span> p1 = Math.min(len1, k/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> p2 = k - p1;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1[start1+p1-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> n2 = nums2[start2+p2-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (n1 == n2)&#123;</span><br><span class="line">            <span class="keyword">return</span> n1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n1&lt;n2)&#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, start1+p1 ,len1-p1 , nums2, start2,len2,k-p1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, start1 ,len1 , nums2, start2+p2,len2-p2,k-p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最先想到的一种方法是先进行合并（这个是考过很多次的了），合并之后马上能找到中位数，但是这个方法时间复杂度不满足要求。实际的解法还是很复杂的，自己很难想到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sorting-and-Searching-easy系列题&quot;&gt;&lt;a href=&quot;#Sorting-and-Searching-easy系列题&quot; class=&quot;headerlink&quot; title=&quot;Sorting and Searching easy系列题&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Sorting and Searching" scheme="http://yoursite.com/tags/Sorting-and-Searching/"/>
    
  </entry>
  
  <entry>
    <title>每周总结4</title>
    <link href="http://yoursite.com/2018/10/30/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%934/"/>
    <id>http://yoursite.com/2018/10/30/每周总结4/</id>
    <published>2018-10-30T12:36:42.000Z</published>
    <updated>2018-12-31T07:02:31.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ListNode-easy系列题"><a href="#ListNode-easy系列题" class="headerlink" title="ListNode-easy系列题"></a>ListNode-easy系列题</h1><ol><li>Delete Node in a Linked List(<code>node.val = node.next.val;node.next = node.next.next;</code>连接跳过即可)</li><li>Remove Nth Node From End of List(要删除尾巴指定位置的节点，首先是先找到它，快慢指针的思想在于，先让两个指针起点一下，然后快指针先走N步，然后两者一起走，当快指针走到头时，慢指针所在的位置就是我们想要的位置，这么麻烦的原因也是因为listnode没有按照序号遍历的功能，只能很原始的去找)</li><li>Reverse Linked List(一个指针一直指在新链接的头上，另外一个不断是去编制，注意编织的顺序，让head及时滑向下一个)</li><li>Merge Two Sorted Lists(合并两个有序链表，考虑4中情况，其实就是归并排序的merge子函数，没啥，递归解决)</li><li>Palindrome Linked List(思路是快慢指针进行二分，注意有快指针的话，判断条件<code>fast!=null&amp;&amp;fast.next!=null</code>，同时这道题也要注意奇偶数的判断，有一个额外的判断条件让slow越过那个奇数值)</li><li>Linked List Cycle(还是利用了快慢指针的思想，要是存在圈，快慢指针一定会相遇导致slow==fast    )<h1 id="ListNode-middle系列题"><a href="#ListNode-middle系列题" class="headerlink" title="ListNode-middle系列题"></a>ListNode-middle系列题</h1><h2 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a>Add Two Numbers</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//结果指针，表示答案，它不能滑动</span></span><br><span class="line">        ListNode point = result;<span class="comment">//苦力指针，用来滑动编制</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//进位标志位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || temp != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode tempnode = <span class="keyword">new</span> ListNode(temp%<span class="number">10</span>);<span class="comment">//取新节点</span></span><br><span class="line">            point.next = tempnode;<span class="comment">//编制</span></span><br><span class="line">            point = point.next;<span class="comment">//编制完移动</span></span><br><span class="line">            temp = temp/<span class="number">10</span>;<span class="comment">//进位标志位更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;<span class="comment">//去掉头部无用节点返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这道题第一感觉难在进位上，还有就是要考虑到两条链表不是一样长的时候的情形。对于链表的编制，往往都需要一个钉在开头的指针和一个不断编制的苦力指针（苦力指针基本上要执行node1.next=node2;node = node.next）。</p><h2 id="Odd-Even-Linked-List"><a href="#Odd-Even-Linked-List" class="headerlink" title="Odd Even Linked List"></a>Odd Even Linked List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode odd = head, even = head.next, evenhead = even;<span class="comment">//奇数偶数各一个起始位，并且保留偶数起始位，用于之后的连接</span></span><br><span class="line">            <span class="keyword">while</span>(even!=<span class="keyword">null</span>&amp;&amp;even.next!=<span class="keyword">null</span>)&#123;<span class="comment">//只要while里面涉及到了node = node.next的话，就需要进行next判断，之前我是觉得fast才需要的</span></span><br><span class="line">                odd.next = odd.next.next;<span class="comment">//奇数编制</span></span><br><span class="line">                odd = odd.next;<span class="comment">//奇数滑动</span></span><br><span class="line">                even.next = even.next.next;<span class="comment">//偶数编制</span></span><br><span class="line">                even = even.next;<span class="comment">//偶数滑动</span></span><br><span class="line">            &#125;</span><br><span class="line">            odd.next = evenhead;<span class="comment">//两条连接进行合并</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>奇偶数的分开再编制，思路简单，但是这道题没有新建一个node来表示答案，而是直接用head返回，之后要考虑下什么时候需要新建node，什么时候可以返回node。</p><h2 id="Intersection-of-Two-Linked-Lists"><a href="#Intersection-of-Two-Linked-Lists" class="headerlink" title="Intersection of Two Linked Lists"></a>Intersection of Two Linked Lists</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pointA = headA;</span><br><span class="line">        ListNode pointB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pointA!=pointB)&#123;</span><br><span class="line">            pointA = pointA == <span class="keyword">null</span> ? headB : pointA.next;</span><br><span class="line">            pointB = pointB == <span class="keyword">null</span> ? headA : pointB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pointA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题在于两条链表的长度不同的话，无法进行比较，否则只需要进行node1==node2指针比较即可，那么问题在于长度 不同，可以让链表1连上链表2；链表2连上链表1，这样长度就一样了，之后再判断就可以了。</p><h1 id="ListNode-hard系列题"><a href="#ListNode-hard系列题" class="headerlink" title="ListNode-hard系列题"></a>ListNode-hard系列题</h1><h2 id="Merge-k-Sorted-Lists"><a href="#Merge-k-Sorted-Lists" class="headerlink" title="Merge k Sorted Lists"></a>Merge k Sorted Lists</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortByPartition(lists, <span class="number">0</span>, lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">sortByPartition</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 递归先确定结束条件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (start == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 经典的分治理念，切半，递归递归，合并</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        ListNode left = sortByPartition(lists, start, mid);</span><br><span class="line">        ListNode right = sortByPartition(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> merge(left,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 同样是递归，先要确定结束条件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 链表合并总是要有连接的过程的，这边需要额外注意</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (left.val&lt;right.val)&#123;</span><br><span class="line">            left.next = merge(left.next,right);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right.next = merge(left,right.next);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不就是归并排序嘛，之前的middle难度的merge双lists算是merge的练习的话，这个就是merge sort的链表版本，区别是归并排序merge的是等长的数组，这边merge的是一条条的链表,对于链表合并的优先性，这边取的是二分法，有点不确定这和挨个合并的区别；还有一点是排序版本的么merge需要（lo,mid（是因为要判断用尽）,hi）而listnode版本的只需要（list1，list2）。</p><h2 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a>Sort List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head, pre = head;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这个相当于是二分啦</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;<span class="comment">//有fast的存在，判断的时候需要有两个判断条件</span></span><br><span class="line">            pre = slow;<span class="comment">//这个pre用来切数组，周末一定要把链表的</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode left = sortList(head);</span><br><span class="line">        ListNode right = sortList(slow);</span><br><span class="line">        <span class="keyword">return</span> merge(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">            left.next = merge(left.next, right);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.next = merge(left, right.next);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并和链表也太相配了吧，merge部分还是一样的，主要是sort部分，结合之前总结的快慢指针代替二分的方法，pre用来断开链接。</p><h2 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a>Copy List with Random Pointer</h2><p><code>`</code>java<br>public class Solution {<br>    public RandomListNode copyRandomList(RandomListNode head) {<br>        if (head == null){<br>            return null;<br>        }<br>        Map&lt;RandomListNode,RandomListNode&gt; map = new HashMap&lt;RandomListNode,RandomListNode&gt;();</p><pre><code>    /*    * 节点意义复制到map中    * */    RandomListNode point = head;    while(point!=null){        map.put(point,new RandomListNode(point.label));        point = point.next;    }    /*    * 指针重新指向开头的地方    * */    point = head;    while(point!=null){        map.get(point).next = map.get(point.next);        map.get(point).random = map.get(point.random);        point = point.next;    }    return map.get(head);}</code></pre><p>}<br><code>`</code><br>链表的深拷贝，不是很懂他的原理，之后如果遇到了再看看吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ListNode-easy系列题&quot;&gt;&lt;a href=&quot;#ListNode-easy系列题&quot; class=&quot;headerlink&quot; title=&quot;ListNode-easy系列题&quot;&gt;&lt;/a&gt;ListNode-easy系列题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Delete N
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每周总结3</title>
    <link href="http://yoursite.com/2018/10/21/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%933/"/>
    <id>http://yoursite.com/2018/10/21/每周总结3/</id>
    <published>2018-10-21T02:15:34.000Z</published>
    <updated>2018-11-21T12:02:14.935Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划专题，总结一下dp使用的特点</p><h1 id="DP-easy系列题"><a href="#DP-easy系列题" class="headerlink" title="DP-easy系列题"></a>DP-easy系列题</h1><ol><li>Climbing Stairs（走一步还是走二步，考虑可能性的话是不是大多是+？<code>sol[i] = sol[i-1] + sol[i-2]</code>）</li><li>Best Time to Buy and Sell Stock（股票问题，感觉都不算dp，在遍历的中找一个最小值，用max函数维护一个num[i]-min的值，<code>maxprofit = Math.max(maxprofit,prices[i]-min);</code>，<code>min = Math.min(min,prices[i])</code>，一个max和一个min维护的dp形式）</li><li>Maximum Subarray（最大子序列和，好题，考虑两点：如果新来的num[i]比之前的sum还要大，那新的sum系列直接从新的num开始，并且将之前的sum记录下来；<code>sum = Math.max(sum+num, num);sum_array = Math.max(sum_array,sum);</code>，两个max函数维护的dp形式，第一个是curr的sum变动，第二个是history的sum值变动）</li><li>House Robber（抢劫房子，偷或者不偷，只能选一种，是不是大多是max?则考虑最近的两个情况，<code>money[i] = Math.max(nums[i]+money[i-2],money[i-1])</code>）<h1 id="DP-middle系列题"><a href="#DP-middle系列题" class="headerlink" title="DP-middle系列题"></a>DP-middle系列题</h1></li><li>Jump Game（青蛙跳问题，感觉和easy不同的就是，这属性限制性dp，而不是发散性，限制性的dp需要最后的值符合某个要求；这道题实际做的时候使用了逆向思维，从尾巴找起，因为失败发生的情况无法是跳到了一个0的地方，然后无法继续前进，所以逆向找到0，让设置step长度为1，往回找，要是找不到一个能跨越step的num，就失败了）</li><li>Unique Paths（棋盘可能性，属于+的问题，思路简单，赋予边界初始值，然后+就完事了，<code>sum[i][j] = sum[i-1][j]+sum[i][j-1]</code>）</li><li>Coin Change（符合目标的最少硬币数，硬币，用或者不用，用的话，在之前的dp中找到减去该硬币面值的数，然+1，与不用的时候比，这里是根据硬币的可能性多次对dp进行更新，最后找到，<code>dp[i] = Math.min(dp[i-coin]+1,dp[i])</code>）</li><li>Longest Increasing Subsequence（无序数组中最长上升散序列，维护一个尾巴最小的上升数组，新来的数如果比数组都大，那就加长数组的长度，否则就更新上升数组，有必要重新写一次）<h1 id="DP-hard系列题"><a href="#DP-hard系列题" class="headerlink" title="DP-hard系列题"></a>DP-hard系列题</h1><h2 id="Maximum-Product-Subarray（TODO）"><a href="#Maximum-Product-Subarray（TODO）" class="headerlink" title="Maximum Product Subarray（TODO）"></a>Maximum Product Subarray（TODO）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] maxdp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] mindp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> maxVal = Integer.MIN_VALUE;</span><br><span class="line">        maxdp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        mindp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            maxdp[i] = Math.max(maxdp[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>], Math.max(mindp[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]));</span><br><span class="line">            mindp[i] = Math.min(mindp[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>], Math.min(maxdp[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]));</span><br><span class="line">            maxVal = Math.max(maxVal, maxdp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这道题，由于要考虑到正负数的问题，故要设立两个dp数组，考虑状态转移方程，当新来了一个数，可能的情况有三种，第一这个数很大，直接替换了直接的数组；第二这个数是正数，与之前的相乘使得max更大；第三这个数是负数与之前保存的最小负数相乘一跃变成最大。考虑完之后，可以用两个dp数组，三个方程求出最大值，这道题由于只涉及i和i-1的关系，还可以简化。</p><h2 id="Decode-Ways（）"><a href="#Decode-Ways（）" class="headerlink" title="Decode Ways（）"></a>Decode Ways（）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> now = s.charAt(n-<span class="number">1</span>) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = now;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'0'</span>)&#123;</span><br><span class="line">                curr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curr = Integer.parseInt(s.substring(i,i+<span class="number">2</span>))&lt;<span class="number">27</span> ? pre+now:now;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能性问题，转移方程一般是+，即找(i-2)+(i-1)的个数，从尾巴开始找起，以2为窗口进行搜索，遇到0则需要改变状态量重新搜索。其中pre表示i-2，now表示i-1，curr表示i，使用时不要忘记，后面需要进行更新。</p><h2 id="Best-Time-to-Buy-and-Sell-Stock-with-Cooldown（TODO）"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Cooldown（TODO）" class="headerlink" title="Best Time to Buy and Sell Stock with Cooldown（TODO）"></a>Best Time to Buy and Sell Stock with Cooldown（TODO）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> cooldown = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = cooldown;</span><br><span class="line">            cooldown = Math.max(temp,sell);</span><br><span class="line">            sell = Math.max(sell,prices[i] + diff);</span><br><span class="line">            diff = Math.max(diff, temp - prices[i]);</span><br><span class="line">            max = Math.max(Math.max(max,sell),cooldown);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来的做法实在看不懂，之后再试其他的方法，并且理解。</p><h2 id="Perfect-Squares（）"><a href="#Perfect-Squares（）" class="headerlink" title="Perfect Squares（）"></a>Perfect Squares（）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Math.sqrt(i); j++) &#123;</span><br><span class="line">                min = Math.min(res[i-j*j]+<span class="number">1</span>,min);</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质还是硬币凑数问题，思路也是一样的，先用小额度的数字去填dp数组，然后慢慢的用较大的数组去填，最小化使用数字的个数，区别就是i-j*j了，变成了减去一个平方数。</p><h2 id="Word-Break（）"><a href="#Word-Break（）" class="headerlink" title="Word Break（）"></a>Word Break（）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> longestLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word.length() &gt; longestLen) &#123;</span><br><span class="line">                longestLen = word.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= longestLen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;=j &amp;&amp; dp[i-j]==<span class="keyword">true</span> &amp;&amp; wordDict.contains(s.substring(i-j,i)))&#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题反而不是很想一道dp的题，主要还是那个判断条件，从最后一个字母倒推的话，必须有一个个的dp点为true，直到第一个数字。</p><h2 id="Word-Break-II（TODO）"><a href="#Word-Break-II（TODO）" class="headerlink" title="Word Break II（TODO）"></a>Word Break II（TODO）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, wordDict, <span class="keyword">new</span> HashMap&lt;Integer, List&lt;String&gt;&gt;(),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">dfs</span><span class="params">(String s, List&lt;String&gt; dict, Map&lt;Integer, List&lt;String&gt;&gt; map, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(start)) <span class="keyword">return</span> map.get(start);<span class="comment">//剪枝，较少不必要的寻找</span></span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            res.add(<span class="string">""</span>);<span class="comment">//??</span></span><br><span class="line">            <span class="keyword">return</span> res;<span class="comment">//结束的return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String word : dict) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.startsWith(word, start)) &#123;</span><br><span class="line">                List&lt;String&gt; sublist = dfs(s, dict, map, start + word.length());</span><br><span class="line">                <span class="keyword">for</span> (String n : sublist) &#123;</span><br><span class="line">                    res.add(word + (n.length() == <span class="number">0</span> ? <span class="string">""</span> : <span class="string">" "</span>) + n);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(start, res);</span><br><span class="line">        <span class="keyword">return</span> res;<span class="comment">//寻找过程的return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不是很能理解，放到之后去去看吧。</p><h2 id="Burst-Balloons（）"><a href="#Burst-Balloons（）" class="headerlink" title="Burst Balloons（）"></a>Burst Balloons（）</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态规划专题，总结一下dp使用的特点&lt;/p&gt;
&lt;h1 id=&quot;DP-easy系列题&quot;&gt;&lt;a href=&quot;#DP-easy系列题&quot; class=&quot;headerlink&quot; title=&quot;DP-easy系列题&quot;&gt;&lt;/a&gt;DP-easy系列题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Climbi
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>每周总结2</title>
    <link href="http://yoursite.com/2018/10/15/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%932/"/>
    <id>http://yoursite.com/2018/10/15/每周总结2/</id>
    <published>2018-10-15T03:16:09.000Z</published>
    <updated>2018-10-20T12:39:12.555Z</updated>
    
    <content type="html"><![CDATA[<p>昨天做了到利用HashMap的Sum类型题，感觉其思路挺有意思的，联想到LeetCode第一题Two Sum的高效解法也是用的HashMap，所以在此归纳总结下这类题目的深层次理解。</p><h1 id="Two-sum-1-——（无序数组）"><a href="#Two-sum-1-——（无序数组）" class="headerlink" title="Two sum(1)——（无序数组）"></a>Two sum(1)——（无序数组）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hm.containsKey(target - nums[i])) &#123;</span><br><span class="line">                index[<span class="number">1</span>] = i;</span><br><span class="line">                index[<span class="number">0</span>] = hm.get(target - nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hm.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始我的想法是很粗暴的，就是想每两个值加起来和target比较一下，但是实际上这效率太低，实际使用可以在之后的数数组中找是否有target-i的数，没有的话用一个map记录每个值和其序号，便于后面的寻找。</p><h1 id="Two-Sum-II-167-——（排序数组）"><a href="#Two-Sum-II-167-——（排序数组）" class="headerlink" title="Two Sum II(167)——（排序数组）"></a>Two Sum II(167)——（排序数组）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (numbers[l] + numbers[r] != target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[l] + numbers[r] &gt; target) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用其有序性，设立两个标志从左右加，将其和与target比较即可。</p><h1 id="Two-Sum-IV-653-——（TODO）"><a href="#Two-Sum-IV-653-——（TODO）" class="headerlink" title="Two Sum IV(653)——（TODO）"></a>Two Sum IV(653)——（TODO）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, list);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = list.get(l) + list.get(r);</span><br><span class="line">            <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; k) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BST的中序遍历是有序的，问题就简化为上一小题了，但是这种方法并不高效，之后可以改进。</p><h1 id="Subarray-Sum-Equals-K-560"><a href="#Subarray-Sum-Equals-K-560" class="headerlink" title="Subarray Sum Equals K(560)"></a>Subarray Sum Equals K(560)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashmap.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(sum-k))&#123;</span><br><span class="line">                count+= hashmap.get(sum-k);</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap.put(sum, hashmap.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题提供了一个新思路，如果我想遍历长度的5的各种可能性，我改怎么办？比如我想试试1,2,3,4,5；{1,2}{2,3}{3,4}等等直到{1,2,3,4,5}；这道题的告诉我们可以用sum[j]-sum[i]的方式，并将其值存在map里面，map的存的是sum[i]即按序累加的值，当sum[j]-sum[i]的时候，就可以出现各种子情况了。</p><h1 id="Combination-Sum-39-——（DEBUG）"><a href="#Combination-Sum-39-——（DEBUG）" class="headerlink" title="Combination Sum(39)——（DEBUG）"></a>Combination Sum(39)——（DEBUG）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        helper(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),candidates,<span class="number">0</span>,target);<span class="comment">//new出来的不要具体说明的嘛?</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> remain)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remain == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));<span class="comment">//为什么不直接add list呢？</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (remain&lt;candidates[i])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                helper(list,candidates,i,remain-candidates[i]);</span><br><span class="line">                list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题利用了dfs的思路，而且同样使用了sum题基本思路，把本来加起来的sum变成remain(target-nums[i])，这样在不断的dfs的时候，remain的值不断变化。这道题还要注意到的是数据可以重复利用，所以其start的值不需要每层加1；最后要注意的是dfs到底部发现不满足的话要把最靠近底部的值给弹出去；add(list)的时候要用new出来的，负责list的内容会是最终状态，这个之后debug再理解。</p><h1 id="Path-Sum-112"><a href="#Path-Sum-112" class="headerlink" title="Path Sum(112)"></a>Path Sum(112)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, sum, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp += root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; temp == sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left, sum, temp) || helper(root.right, sum, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathSum的第一题简单，都是老套路，dfs的时候把remain或者sum值放在函数里面传递。</p><h1 id="Path-Sum-II-113"><a href="#Path-Sum-II-113" class="headerlink" title="Path Sum II(113)"></a>Path Sum II(113)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, sum, <span class="number">0</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> num, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(root.val);</span><br><span class="line">            num += root.val;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; num == sum) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">                temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                helper(root.left, sum, num, temp);</span><br><span class="line">                helper(root.right, sum, num, temp);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题融合了PathSum的性质和CombinationSum的要求，就是把数组找出来，这样我们需要在dfs函数上加一个temp的list来记录当前遍历的数组内容，再设一个全局list变量来作为return的ans，其他思路照旧。</p><h1 id="Path-Sum-III-437-——（DEBUG）"><a href="#Path-Sum-III-437-——（DEBUG）" class="headerlink" title="Path Sum III(437)——（DEBUG）"></a>Path Sum III(437)——（DEBUG）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        helper(root, sum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> tempSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tempSum += root.val;</span><br><span class="line">        res += map.getOrDefault(tempSum - sum, <span class="number">0</span>);<span class="comment">//??????</span></span><br><span class="line">        map.put(tempSum, map.getOrDefault(tempSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        helper(root.left, sum, tempSum);</span><br><span class="line">        helper(root.right, sum, tempSum);</span><br><span class="line">        map.put(tempSum, map.get(tempSum) - <span class="number">1</span>);<span class="comment">//?????????</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前两道pathsum都是说好从根节点到子节点的，这到题就没说了，这样按照之前的思路，我们需要一个map来记录；最后照旧，需要在dfs后把尾部弹出，不过这里还不是很理解，要再看看。</p><h1 id="Target-Sum-494-——（TODO）"><a href="#Target-Sum-494-——（TODO）" class="headerlink" title="Target Sum(494)——（TODO）"></a>Target Sum(494)——（TODO）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        helper(nums, <span class="number">1</span>, S - nums[<span class="number">0</span>]);</span><br><span class="line">        helper(nums, <span class="number">1</span>, S + nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(nums, index + <span class="number">1</span>, target - nums[index]);</span><br><span class="line">        helper(nums, index + <span class="number">1</span>, target + nums[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种dfs中的方式，一种是存sum的累加值，一种是放taregt-nums[i]的值，两种方式的详细区别之后在看看。明天改成sum的形式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天做了到利用HashMap的Sum类型题，感觉其思路挺有意思的，联想到LeetCode第一题Two Sum的高效解法也是用的HashMap，所以在此归纳总结下这类题目的深层次理解。&lt;/p&gt;
&lt;h1 id=&quot;Two-sum-1-——（无序数组）&quot;&gt;&lt;a href=&quot;#Two
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Two Sum" scheme="http://yoursite.com/tags/Two-Sum/"/>
    
  </entry>
  
  <entry>
    <title>每周总结1</title>
    <link href="http://yoursite.com/2018/10/14/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%931/"/>
    <id>http://yoursite.com/2018/10/14/每周总结1/</id>
    <published>2018-10-14T07:15:09.000Z</published>
    <updated>2019-01-02T14:50:17.593Z</updated>
    
    <content type="html"><![CDATA[<p>之前的每日算法更新结束，文章多了后，hexo编译好慢，而且每天写的话有点浪费时间，算法题还是每天在做，之后改成总结更新类的方式。</p><h1 id="TreeNode-easy系列题"><a href="#TreeNode-easy系列题" class="headerlink" title="TreeNode-easy系列题"></a>TreeNode-easy系列题</h1><ol><li>Maximum Depth of Binary Tree（树的深度）</li><li>Validate Binary Search Tree（二叉搜索树的判定）</li><li>Symmetric Tree（对称树-学到了helper的双遍历）</li><li>Binary Tree Level Order Traversal（根据树的深度来找同一层的点，helper函数需要加入level属性）</li><li>Convert Sorted Array to Binary Search Tree（有序数组变成二叉搜索树-中序遍历的特点-需要在helper函数里面不断的找中点，然后左右递归，边界条件要注意）</li></ol><h1 id="TreeNode-middle系列题"><a href="#TreeNode-middle系列题" class="headerlink" title="TreeNode-middle系列题"></a>TreeNode-middle系列题</h1><ol><li>Binary Tree Inorder Traversal（树的中序遍历）</li><li>Binary Tree Zigzag Level Order Traversal（Z形level遍历，在原有easy的基础上对add函数做一下小处理，在末端加入，有点trick的感觉）</li><li>Construct Binary Tree from Preorder and Inorder Traversal（根据先序中序遍历结果进行重新排列，有点难度，搞清楚就是先序的节点作为中序数组的分界点）</li><li>Populating Next Right Pointers in Each Node（给树增加右向指针，可以好好理解BFS和DFS的区别）</li><li>Kth Smallest Element in a BST（根据二叉搜索树的特点统计每个节点左右两边的节点个数，依据个数来找出index的node）</li><li>Number of I slands（可以说是比较经典的二维图遍历了，用dfs的思路进行遍历，找到后变0，这样之后再遇到就不会对下一个图产生误导了）</li></ol><h1 id="TreeNode-hard系列题"><a href="#TreeNode-hard系列题" class="headerlink" title="TreeNode-hard系列题"></a>TreeNode-hard系列题</h1><ol><li>Word Ladder（很难，从首到尾BFS将相差1个字的单词从原有数组去掉，加入到该level的数组中）</li><li>Surrounded Regions（二维数组，去掉被包围的点，这道题是逆向思维，从4条边缘进行dfs,将遇到的点给值，然后再遍历的时候，如果没有被给值就直接变成X）</li><li>Lowest Common Ancestor of a Binary Tree（这道题还是要在看一下YouTube视频理解一下，是一道经典题）</li><li>Binary Tree Maximum Path Sum（二叉树上的最大路径，基于DFS，需要识别负数，return的时候有点技巧）</li><li>Friend Circles（朋友圈，也是用dfs，不过要理解visited的含义）</li><li>Course Schedule（拓扑搜索，用一个set和dp的数组来解决）</li><li>Course Schedule II（用一个stack和一个set可以解决）</li><li>Longest Increasing Path in a Matrix（二维数据的找最大上升序列，需要一个visited数组作数据记录）</li><li>Alien Dictionary</li><li>Count of Smaller Numbers After Self（其实这道题换个角度理解就是一个个进行二分插入，统计插入位置的index，进index进行记录）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前的每日算法更新结束，文章多了后，hexo编译好慢，而且每天写的话有点浪费时间，算法题还是每天在做，之后改成总结更新类的方式。&lt;/p&gt;
&lt;h1 id=&quot;TreeNode-easy系列题&quot;&gt;&lt;a href=&quot;#TreeNode-easy系列题&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Treenode" scheme="http://yoursite.com/tags/Treenode/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷68</title>
    <link href="http://yoursite.com/2018/09/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B768/"/>
    <id>http://yoursite.com/2018/09/25/每日一刷68/</id>
    <published>2018-09-25T12:56:33.000Z</published>
    <updated>2018-09-25T13:15:10.156Z</updated>
    
    <content type="html"><![CDATA[<p>简单的5到tree综合总结（104、98、101、102、108）<br>代码就不贴了，暂时就说说感想：</p><ul><li>tree的题基本都是可以用递归做的，可以用来巩固递归的知识</li><li>tree的遍历基本知识：先中后序遍历，层次遍历及递归与非递归实现</li><li>tree的树高，对称判断，建树等基本操作的递归实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单的5到tree综合总结（104、98、101、102、108）&lt;br&gt;代码就不贴了，暂时就说说感想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tree的题基本都是可以用递归做的，可以用来巩固递归的知识&lt;/li&gt;
&lt;li&gt;tree的遍历基本知识：先中后序遍历，层次遍历及递归与非递归
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Treenode" scheme="http://yoursite.com/tags/Treenode/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷67</title>
    <link href="http://yoursite.com/2018/09/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B767/"/>
    <id>http://yoursite.com/2018/09/09/每日一刷67/</id>
    <published>2018-09-09T11:50:55.000Z</published>
    <updated>2018-09-25T12:57:38.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="241-Different-Ways-to-Add-Parentheses"><a href="#241-Different-Ways-to-Add-Parentheses" class="headerlink" title="241. Different Ways to Add Parentheses"></a>241. Different Ways to Add Parentheses</h1><p>iven a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.<br><strong>Example 1:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"2-1-1"</span></span><br><span class="line">Output: [<span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">Explanation: </span><br><span class="line">((<span class="number">2</span><span class="number">-1</span>)<span class="number">-1</span>) = <span class="number">0</span> </span><br><span class="line">(<span class="number">2</span>-(<span class="number">1</span><span class="number">-1</span>)) = <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"2*3-4*5"</span></span><br><span class="line">Output: [<span class="number">-34</span>, <span class="number">-14</span>, <span class="number">-10</span>, <span class="number">-10</span>, <span class="number">10</span>]</span><br><span class="line">Explanation: </span><br><span class="line">(<span class="number">2</span>*(<span class="number">3</span>-(<span class="number">4</span>*<span class="number">5</span>))) = <span class="number">-34</span> </span><br><span class="line">((<span class="number">2</span>*<span class="number">3</span>)-(<span class="number">4</span>*<span class="number">5</span>)) = <span class="number">-14</span> </span><br><span class="line">((<span class="number">2</span>*(<span class="number">3</span><span class="number">-4</span>))*<span class="number">5</span>) = <span class="number">-10</span> </span><br><span class="line">(<span class="number">2</span>*((<span class="number">3</span><span class="number">-4</span>)*<span class="number">5</span>)) = <span class="number">-10</span> </span><br><span class="line">(((<span class="number">2</span>*<span class="number">3</span>)<span class="number">-4</span>)*<span class="number">5</span>) = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; operaters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        split(input,nums,operaters);<span class="comment">//以后有想法就先把函数写出来再说</span></span><br><span class="line">        <span class="keyword">return</span> calculate(nums, operaters, <span class="number">0</span>, nums.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(String input, List&lt;Integer&gt; nums, List&lt;String&gt; operaters)</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();<span class="comment">//不需要预先设置长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> character = input.charAt(i);<span class="comment">//charAt充当遍历器</span></span><br><span class="line">            <span class="keyword">if</span> (character == <span class="string">'+'</span> || character == <span class="string">'-'</span> || character == <span class="string">'*'</span>)&#123;</span><br><span class="line">                nums.add(Integer.valueOf(sb.toString()));<span class="comment">//是错位的加法</span></span><br><span class="line">                sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                operaters.add(character+<span class="string">""</span>);<span class="comment">//只是为了char 2 string,一定要是双引号</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(character);<span class="comment">//这么感觉有点蠢，之后再看看</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.add(Integer.valueOf(sb.toString()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">calculate</span><span class="params">(List&lt;Integer&gt; nums, List&lt;String&gt; operaters, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//这个是要返回的结果呀</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 写结束条件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (start == end)&#123;</span><br><span class="line">            res.add(nums.get(start));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 一般处理情况</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; left = calculate(nums, operaters, start, i);</span><br><span class="line">            List&lt;Integer&gt; right = calculate(nums, operaters, i+<span class="number">1</span>, end);</span><br><span class="line">            mergelist(left, right, res, operaters.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergelist</span><span class="params">(List&lt;Integer&gt; left, List&lt;Integer&gt; right, List&lt;Integer&gt; res, String operator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; right.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = operate(left.get(i), right.get(j), operator);</span><br><span class="line">                res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, String operator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (operator)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                <span class="keyword">return</span> i+j;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                <span class="keyword">return</span> i-j;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                <span class="keyword">return</span> i*j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数字符合种类合集</p><ul><li>分治的思想</li><li>程序较为复杂，自己还hold不住</li><li>对于string字符串中数据的提取很不熟练</li><li>对于switch基本函数的运用</li><li>对于stringbuilder的运用</li><li>递归的基本思想实践能力不行</li><li>程序的逻辑性分析大体倒是对了</li><li>最近事情多，不能静下心来思考很伤</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;241-Different-Ways-to-Add-Parentheses&quot;&gt;&lt;a href=&quot;#241-Different-Ways-to-Add-Parentheses&quot; class=&quot;headerlink&quot; title=&quot;241. Different Way
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷66</title>
    <link href="http://yoursite.com/2018/09/05/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B766/"/>
    <id>http://yoursite.com/2018/09/05/每日一刷66/</id>
    <published>2018-09-05T07:40:57.000Z</published>
    <updated>2018-09-24T14:03:00.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a>138. Copy List with Random Pointer</h1><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * class RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode next, random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;RandomListNode,RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;RandomListNode,RandomListNode&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 节点意义复制到map中</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        RandomListNode point = head;</span><br><span class="line">        <span class="keyword">while</span>(point!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(point,<span class="keyword">new</span> RandomListNode(point.label));</span><br><span class="line">            point = point.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 指针重新指向开头的地方</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        point = head;</span><br><span class="line">        <span class="keyword">while</span>(point!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.get(point).next = map.get(point.next);</span><br><span class="line">            map.get(point).random = map.get(point.random);</span><br><span class="line">            point = point.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带随机指针链表的深拷贝:</p><ul><li>做的不明所以</li><li>步骤能能够理解，但是效率不高，之后可以再改进</li><li>最近一周实在是效率低下，装机也要适可而止，不能影响到日常生活</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;138-Copy-List-with-Random-Pointer&quot;&gt;&lt;a href=&quot;#138-Copy-List-with-Random-Pointer&quot; class=&quot;headerlink&quot; title=&quot;138. Copy List with Random
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷65</title>
    <link href="http://yoursite.com/2018/09/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B765/"/>
    <id>http://yoursite.com/2018/09/04/每日一刷65/</id>
    <published>2018-09-04T08:25:30.000Z</published>
    <updated>2018-09-24T14:03:00.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h1><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><p><strong>Example</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortByPartition(lists, <span class="number">0</span>, lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">sortByPartition</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 递归先确定结束条件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (start == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 经典的分治理念，切半，递归递归，合并</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">int</span> mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">        ListNode left = sortByPartition(lists, start, mid);</span><br><span class="line">        ListNode right = sortByPartition(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> merge(left,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 同样是递归，先要确定结束条件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 链表合并总是要有连接的过程的，这边需要额外注意</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (left.val&lt;right.val)&#123;</span><br><span class="line">            left.next = merge(left.next,right);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right.next = merge(left,right.next);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常经典非常好的题-多链表按序合并</p><ul><li>可以使用优先级队列（但是这样使用了内建函数）</li><li><p>最后参考的方法是分治，其有着有一定的规律，比如先中分，俩边递归，然后合并</p></li><li><p>链表合并的递归函数还是蛮经典的，之后要会默写</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;23-Merge-k-Sorted-Lists&quot;&gt;&lt;a href=&quot;#23-Merge-k-Sorted-Lists&quot; class=&quot;headerlink&quot; title=&quot;23. Merge k Sorted Lists&quot;&gt;&lt;/a&gt;23. Merge k Sort
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷64</title>
    <link href="http://yoursite.com/2018/08/31/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B764/"/>
    <id>http://yoursite.com/2018/08/31/每日一刷64/</id>
    <published>2018-08-31T07:40:10.000Z</published>
    <updated>2018-09-24T14:03:00.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a>148. Sort List</h1><p>Sort a linked list in O(n log n) time using constant space complexity.</p><p><strong>Example 1:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">-1</span>-&gt;<span class="number">5</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">0</span></span><br><span class="line">Output: <span class="number">-1</span>-&gt;<span class="number">0</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 链表合并的递归方式，妙的很，理解上需要从最后一步反推，链表的连接像是倒着连一样</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode h1, ListNode h2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> h2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> h1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h1.val&lt;h2.val)&#123;</span><br><span class="line">            h1.next = merge(h1.next,h2);</span><br><span class="line">            <span class="keyword">return</span> h1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            h2.next = merge(h1,h2.next);</span><br><span class="line">            <span class="keyword">return</span> h2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 同样是递归，原理是归并排序的原理，先分开排序再进行合并，具体原理再多理解一下</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 归并的第一步：确定最后的返回条件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 快慢指针达到二分的效果</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        ListNode slow = head, fast = head, pre = head;<span class="comment">//pre存储slow指针的上一个节点，用于分割</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 由于有快指针，循环条件要以快的那个为准，而且要有两种情况，以防跳到null</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * x.next进行分割；不同于slow = slow.next是指针滑动</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 归并的一般推演逻辑</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        ListNode h1 = sortList(head);</span><br><span class="line">        ListNode h2 = sortList(slow);</span><br><span class="line">        <span class="keyword">return</span> merge(h1,h2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        ListNode.print(solution.sortList(ListNode.createTestData(<span class="string">"[2,1,3,5]"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表排序题：</p><ul><li>用到的排序原理是归并</li><li>不知道为啥不用其他排序算法</li><li>各种排序算法优劣学习</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;148-Sort-List&quot;&gt;&lt;a href=&quot;#148-Sort-List&quot; class=&quot;headerlink&quot; title=&quot;148. Sort List&quot;&gt;&lt;/a&gt;148. Sort List&lt;/h1&gt;&lt;p&gt;Sort a linked list in O(
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷63</title>
    <link href="http://yoursite.com/2018/08/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B763/"/>
    <id>http://yoursite.com/2018/08/30/每日一刷63/</id>
    <published>2018-08-30T13:35:10.000Z</published>
    <updated>2018-09-24T14:03:00.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a>61. Rotate List</h1><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.<br><strong>Example 1:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: <span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">2</span> steps to the right: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL, k = <span class="number">4</span></span><br><span class="line">Output: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">2</span> steps to the right: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">0</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">3</span> steps to the right: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">4</span> steps to the right: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head, pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = head;</span><br><span class="line">        k %= count;</span><br><span class="line">        <span class="keyword">int</span> left = count-k;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>旋转链表题：</p><ul><li>先连成环；再走到起点；把终点断开</li><li>连成环是一种新的基本思想</li><li>如果需要使用某一位置之前的一个指针时，可以在while循环里用pre=cur来记录，然后让cur自增</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;61-Rotate-List&quot;&gt;&lt;a href=&quot;#61-Rotate-List&quot; class=&quot;headerlink&quot; title=&quot;61. Rotate List&quot;&gt;&lt;/a&gt;61. Rotate List&lt;/h1&gt;&lt;p&gt;Given a linked list,
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷62</title>
    <link href="http://yoursite.com/2018/08/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B762/"/>
    <id>http://yoursite.com/2018/08/29/每日一刷62/</id>
    <published>2018-08-29T11:52:59.000Z</published>
    <updated>2018-09-24T14:03:00.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a>160. Intersection of Two Linked Lists</h1><p>Write a program to find the node at which the intersection of two singly linked lists begins.<br>For example, the following two linked lists:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure></p><p>begin to intersect at node c1.<br><strong>Notes</strong>:</p><ul><li>If the two linked lists have no intersection at all, return null.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pointA = headA;</span><br><span class="line">        ListNode pointB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pointA!=pointB)&#123;</span><br><span class="line">            pointA = pointA == <span class="keyword">null</span> ? headB : pointA.next;</span><br><span class="line">            pointB = pointB == <span class="keyword">null</span> ? headA : pointB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pointA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找公共起始点：</p><ul><li>核心问题是两条链路长度不一样怎么办？</li><li>我的写法是写计数两个指针到null的值，然后让其中一个先走几步，但是显然有点蠢</li><li>答案的方法很妙，如果两者长度相同，不会超时额外操作；如果不用的话根据x+y=y+x的原理，走完自己这里的链路再走对方的链路，总长度一定一样，一定能找到</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;160-Intersection-of-Two-Linked-Lists&quot;&gt;&lt;a href=&quot;#160-Intersection-of-Two-Linked-Lists&quot; class=&quot;headerlink&quot; title=&quot;160. Intersection of
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷61</title>
    <link href="http://yoursite.com/2018/08/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B761/"/>
    <id>http://yoursite.com/2018/08/29/每日一刷61/</id>
    <published>2018-08-29T08:34:31.000Z</published>
    <updated>2018-09-24T14:03:00.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a>92. Reverse Linked List II</h1><p>Reverse a linked list from position m to n. Do it in one-pass.</p><p><strong>Note:</strong> 1 ≤ m ≤ n ≤ length of list.</p><p><strong>Example</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, m = <span class="number">2</span>, n = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode start = pre.next;</span><br><span class="line">        ListNode then = start.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-m ; i++) &#123;</span><br><span class="line">            start.next = then.next;</span><br><span class="line">            then.next = pre.next;</span><br><span class="line">            pre.next = then;</span><br><span class="line">            then = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表指定区间反转：</p><ul><li>自己的方法没有顾忌到结尾的反转</li><li>对于链表指针的熟悉使用</li><li>这道题是有点绕的</li><li>x.next = y.next（链路重置）</li><li>x = x.next; (指针移动，不影响原来的链路)</li><li>x.next = y（建立链路链接）</li><li>x = y.next（同理）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;92-Reverse-Linked-List-II&quot;&gt;&lt;a href=&quot;#92-Reverse-Linked-List-II&quot; class=&quot;headerlink&quot; title=&quot;92. Reverse Linked List II&quot;&gt;&lt;/a&gt;92. Revers
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷60</title>
    <link href="http://yoursite.com/2018/08/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B760/"/>
    <id>http://yoursite.com/2018/08/28/每日一刷60/</id>
    <published>2018-08-28T11:54:08.000Z</published>
    <updated>2018-09-24T14:03:00.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328. Odd Even Linked List"></a>328. Odd Even Linked List</h1><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p><p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p><p><strong>Example 1:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br></pre></td></tr></table></figure></p><p><strong>Example 2:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">4</span>-&gt;<span class="number">7</span>-&gt;NULL</span><br><span class="line">Output: <span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span>-&gt;<span class="number">1</span>-&gt;<span class="number">5</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong></p><ul><li>The relative order inside both the even and odd groups should remain as it was in the input.</li><li>The first node is considered odd, the second node even and so on …</li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode odd = head, even = head.next, evenhead = even;<span class="comment">//指针定位</span></span><br><span class="line">            <span class="keyword">while</span>(even!=<span class="keyword">null</span>&amp;&amp;even.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                odd.next = odd.next.next;<span class="comment">//编织链表</span></span><br><span class="line">                even.next = even.next.next;</span><br><span class="line">                odd = odd.next;<span class="comment">//链表向后拓展</span></span><br><span class="line">                even = even.next;</span><br><span class="line">            &#125;</span><br><span class="line">            odd.next = evenhead;<span class="comment">//evenhead保存even头部位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>链表奇偶改造：</p><ul><li>道理不难</li><li>没有必要新建链表保存数据</li><li>基本功不扎实</li><li>有<code>.next.next</code>形式时七while条件往往是<code>(even!=null&amp;&amp;even.next!=null)</code></li><li>两个指针时，考虑奇偶情况，以位置靠后的那个为准，一般是偶数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;328-Odd-Even-Linked-List&quot;&gt;&lt;a href=&quot;#328-Odd-Even-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;328. Odd Even Linked List&quot;&gt;&lt;/a&gt;328. Odd Even
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷59</title>
    <link href="http://yoursite.com/2018/08/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B759/"/>
    <id>http://yoursite.com/2018/08/25/每日一刷59/</id>
    <published>2018-08-25T07:55:37.000Z</published>
    <updated>2018-09-24T14:03:00.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="445-Add-Two-Numbers-II"><a href="#445-Add-Two-Numbers-II" class="headerlink" title="445. Add Two Numbers II"></a>445. Add Two Numbers II</h1><p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Follow up</strong>:<br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p><p><strong>Example</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: (<span class="number">7</span> -&gt; <span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">Output: <span class="number">7</span> -&gt; <span class="number">8</span> -&gt; <span class="number">0</span> -&gt; <span class="number">7</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s1.add(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s2.add(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(! s1.empty() || !s2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (! s1.empty())&#123;</span><br><span class="line">                temp += s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (! s2.empty())&#123;</span><br><span class="line">                temp += s2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            head.val = temp%<span class="number">10</span>;</span><br><span class="line">            ListNode tempnode = <span class="keyword">new</span> ListNode(temp/<span class="number">10</span>);<span class="comment">//考虑最后一步</span></span><br><span class="line">            tempnode.next = head;<span class="comment">//指向反转</span></span><br><span class="line">            head = tempnode;<span class="comment">//指向反转</span></span><br><span class="line">            temp = temp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.val == <span class="number">0</span> ? head.next:head;<span class="comment">//同样为了考虑最后一步</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表加法的升级版，顺序反过来了：</p><ul><li>思路一致</li><li>不准反转</li><li>使用堆栈</li><li>由于链路指向反过来了，细节上需要注意</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;445-Add-Two-Numbers-II&quot;&gt;&lt;a href=&quot;#445-Add-Two-Numbers-II&quot; class=&quot;headerlink&quot; title=&quot;445. Add Two Numbers II&quot;&gt;&lt;/a&gt;445. Add Two Number
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷58</title>
    <link href="http://yoursite.com/2018/08/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B758/"/>
    <id>http://yoursite.com/2018/08/25/每日一刷58/</id>
    <published>2018-08-25T06:45:50.000Z</published>
    <updated>2018-09-24T14:03:00.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h1><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">Output: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//新建链表头，当做返回值</span></span><br><span class="line">        ListNode point = result;<span class="comment">//设立指针</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位标志位</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//和标志位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry != <span class="number">0</span>)&#123;</span><br><span class="line">            sum = (l1 != <span class="keyword">null</span>?l1.val:<span class="number">0</span>) + (l2 != <span class="keyword">null</span>? l2.val : <span class="number">0</span>) + carry;<span class="comment">//计算和</span></span><br><span class="line">            carry = sum/<span class="number">10</span>;<span class="comment">//计算进位</span></span><br><span class="line">            ListNode temp = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);<span class="comment">//新建临时节点，用于连接</span></span><br><span class="line">            point.next = temp;<span class="comment">//建立连接</span></span><br><span class="line">            point = point.next;<span class="comment">//i++</span></span><br><span class="line">            <span class="keyword">if</span> (l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表的加法进位题：</p><ul><li>自己对于链表的概念是对的</li><li>具体思路见注释</li><li>还有提升空间见下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">       ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode point = result;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || temp != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode tempnode = <span class="keyword">new</span> ListNode(temp%<span class="number">10</span>);</span><br><span class="line">            point.next = tempnode;</span><br><span class="line">            point = point.next;</span><br><span class="line">            temp = temp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化如下：</p><ul><li>由于sum,carry,和取余值有顺序，所以一个temp按照顺序来就可以了</li><li>先当做sum</li><li>再当做取余</li><li>最后做进位</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-Add-Two-Numbers&quot;&gt;&lt;a href=&quot;#2-Add-Two-Numbers&quot; class=&quot;headerlink&quot; title=&quot;2. Add Two Numbers&quot;&gt;&lt;/a&gt;2. Add Two Numbers&lt;/h1&gt;&lt;p&gt;You are 
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷57</title>
    <link href="http://yoursite.com/2018/08/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B757/"/>
    <id>http://yoursite.com/2018/08/24/每日一刷57/</id>
    <published>2018-08-24T06:41:22.000Z</published>
    <updated>2018-09-24T14:03:00.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. Linked List Cycle II</h1><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p><strong>Note</strong>: Do not modify the linked list.</p><p>Follow up:<br>Can you solve it without using extra space?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!= <span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fast == slow)&#123;</span><br><span class="line">                ListNode slow2 = head;</span><br><span class="line">                <span class="keyword">while</span>(slow!=slow2)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    slow2 = slow2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断回环找到起始点：</p><ul><li>快慢指针</li><li>加入数学分析（A+B=N -&gt; A=N-B）根据这个找到A的值</li><li>N的值可以从图上分析得到</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;142-Linked-List-Cycle-II&quot;&gt;&lt;a href=&quot;#142-Linked-List-Cycle-II&quot; class=&quot;headerlink&quot; title=&quot;142. Linked List Cycle II&quot;&gt;&lt;/a&gt;142. Linked L
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>每日一刷56</title>
    <link href="http://yoursite.com/2018/08/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B756/"/>
    <id>http://yoursite.com/2018/08/24/每日一刷56/</id>
    <published>2018-08-24T06:40:18.000Z</published>
    <updated>2018-09-24T14:03:00.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h1><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:<br>Can you solve it without using extra space?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!= <span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fast == slow)&#123;</span><br><span class="line">                ListNode slow2 = head;</span><br><span class="line">                <span class="keyword">while</span>(slow!=slow2)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    slow2 = slow2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断回环：</p><ul><li>快慢指针（要是有机会，总是能再相见）</li><li>找不到起始点的</li><li>对于while循环的判断条件要细细考虑</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;141-Linked-List-Cycle&quot;&gt;&lt;a href=&quot;#141-Linked-List-Cycle&quot; class=&quot;headerlink&quot; title=&quot;141. Linked List Cycle&quot;&gt;&lt;/a&gt;141. Linked List Cycle
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
</feed>
