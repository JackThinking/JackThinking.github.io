---
title: 每日一刷48
date: 2018-08-16 16:19:05
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
## 647. Palindromic Substrings

Given a string, your task is to count how many palindromic substrings in this string.

The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.

**Example 1:**
```js
Input: "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".
```
**Example 2**:
```js
Input: "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
```
**Note**:
The input string length won't exceed 1000.

```java
public class Solution {
    int res;
    public int countSubstrings(String s) {
        int[][] memo = new int[s.length()][s.length()];
        helper(s,memo,0,s.length()-1);
        return res;
    }

    public int helper(String s, int[][] memo, int left, int right){

        if (memo[left][right] != 0){
            return memo[left][right];
        }

        if (left == right){
            memo[left][right] = 1;
            res++;
            return memo[left][right];
        }

        if (s.charAt(left) == s.charAt(right)){
            if (left == right-1){
                memo[left][right] = 1;
                res++;
            }
            else{
                if (helper(s,memo,left+1,right-1)!=0){
                    memo[left][right] = 1;
                    res++;
                }
            }

        }
        if (left<s.length()){
            helper(s,memo,left+1,right);
        }
        if (right>0){
            helper(s,memo,left,right-1);
        }
        return memo[left][right];
    }
}
```
回文判断：
- 带备忘录的自顶向下
- 超时（？？？）
- return的值有讲究，这个问题出错导致debug了好久
- 子问题重复严重，这个时候带备忘录效果还是不好

```java
class Solution {
    public int countSubstrings(String s) {
        int sum = 0;
        for(int i = 0;i < s.length();i++) {
            int t1 = search(s, i, i);
            int t2 = search(s, i, i + 1);
            sum += t1 + t2;
        }      
        return sum;
    }
    
    public int search(String s, int left, int right) {
        int valid = 1;
        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
            valid++;
        }
        return valid - 1;
    }
}
```
高效解法：
- 不知道归啥类
- 基本不会产生重复判断
- 自底向上
- 分成两种情况考虑
