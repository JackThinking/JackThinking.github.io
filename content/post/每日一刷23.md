---
title: 每日一刷23
date: 2018-07-16 16:28:27
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
这道题和昨天的一样，用的是带备忘录的自顶向下的动态规划解法，这类题目一般比较难理解。
# Burst Balloons #
Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.
Find the maximum coins you can collect by bursting the balloons wisely.
**Note:**
You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.
0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100
**Example:**
```js
Input: [3,1,5,8]
Output: 167 
Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```
```java
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        Integer[][] dp = new Integer[n][n];
        return maxCoins(nums, 0,n-1,dp);
    }
    private int maxCoins(int[] nums, int start, int end, Integer[][] dp) {
        int res = 0;
        int n = nums.length;
        /*
        * 设置两边的边界条件
        * */
        int left = start == 0 ? 1 : nums[start-1];
        int right = end == n-1 ? 1 : nums[end+1];
        /*
        * 最底层的返回，结束条件
        * */
        if (start>end){
            return 0;
        }
        /*
        * 备忘录
        * */
        if (dp[start][end] != null){
            return dp[start][end];
        }
        /*
        * 核心的状态转移方程
        * */
        for (int i = start; i <= end; i++) {
            res = Math.max(res,left*nums[i]*right+maxCoins(nums,start,i-1,dp)+maxCoins(nums,i+1,end,dp));
        }
        dp[start][end] = res;
        return res;
    }
}
```
带备忘录的自顶向下的动态规划注意几点：
1. 备忘录的数组
2. 底部返回数据
3. 核心的状态转移方程
这道题难的是理解，其实做完后还是有点不能理解，看来解释后发现要从逆向去理解，从最后状态去逆推。但是超过2层我就无法理解了。
