---
title: 每日一刷11
date: 2018-07-04 16:21:56
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
真的是惰怠，16周之后就再也没刷过题了，说好的每日一刷呢？今天不要脸更新下去吧。。。
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.
**Example 1:**
```js
Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
```
**Example 2:**
```js
Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.
```
```java
public int rob(int[] nums) {
        int length = nums.length;
        int[] money = new int[length];
        if (length == 0){
            return 0;
        }
        if (length < 2){
            return nums[0];
        }
        money[0] = nums[0];
        money[1] = Math.max(nums[0],nums[1]);
        for (int i = 2; i < money.length; i++) {
            money[i] = Math.max(nums[i]+money[i-2],money[i-1]);
        }
        return money[length-1];
}
先贴上我自己的做法，思路都是按照之前的python版本来的，比较简陋，但是核心思想是对的，动态规划就是先找出状态转移方程，然后记录中间变量。不过我的写法在特殊情况的判别上很繁琐，效率也不高。
```
```java
public int rob(int[] nums) {
            int prev = 0, curr = 0;
            for (int n : nums) {
                int tmp = curr;
                curr = Math.max(prev + n, curr);
                prev = tmp;
            }
            return curr;
}
```
这个是LeetCode上的高效算法，改进的地方就是取消了数组的方式，因为之前的转移方程设计的比较对象其实是money[i-2]和money[i-1]，两个的话可以用curr和prev变量代替，这是个不错的思路。
