---
title: 网易互娱春招总结
date: 2019-04-01 19:20:36
categories: 
    - 春招
tags:
    - 网易
    - 面试
    - 算法
---

# 网易互娱基础平台开发二面记录
之前约了4月1号下午3点的网易互娱视频面试，也是我的第一次视频面试，表现的有点紧张，在此记录回顾一下。

面试主要是问了一道基础的二分搜索的算法题以及项目的一些细节，最后还问了关于岗位的一些看法和个人的兴趣。总的来说，这次表现的不是很满意，尤其是手撕代码的环节，还是暴露了自己的编程缺陷。今天着重复现一下。

## 第一阶段：写一个最常规的二分搜索

```java
public class BinarySearch {
    public int binarySearch(int[] array, int value) {
        if (array.length == 0) {
            return -1;
        }
        int left = 0;
        int right = array.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (array[mid] < value) {
                left = mid + 1;
            } else if (array[mid] > value) {
                right = mid - 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
}
```
我想还好，这个我平时有练过，然后3分钟写完，解释给了面试官，结果面试官马上看到缺点，说那你这个数组要是重复的数字多怎么办呢？我只要第一个target的下标。

## 第二阶段：二分查找返回target(可能有重复)第一次出现的下标

```java
public class BinarySearch {
    public int binarySearch(int[] array, int value) {
        if (array.length == 0) {
            return -1;
        }
        int left = 0;
        int right = array.length - 1;
        int[] res = new int[2];
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (array[mid] > value) {
                right = mid - 1;
            } else if (array[mid] < value) {
                left = mid + 1;
            } else {
                int sumVal = array[mid];
                while (array[mid - 1] == sumVal) {
                    mid--;//找到左边边界
                }
            }
        }
        return -1;
    }
}
```

想了想还好，这道题我也遇到过，不就是找到target之后再往回找嘛，然后马上改了版代码。结果写完被面试官一顿嫌弃，首先`int sumVal = array[mid]`是不是有点多余（我去，我个脑残，不就是target嘛），然后输入1怎么办（我的测试用例第一个是1，且前面没有了，故报错），然后我又改了改。

```java
public class BinarySearch {
    public int binarySearch(int[] array, int value) {
        if (array.length == 0) {
            return -1;
        }
        int left = 0;
        int right = array.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (array[mid] > value) {
                right = mid - 1;
            } else if (array[mid] < value) {
                left = mid + 1;
            } else {
                left = mid;
                while (left > 0 && array[left - 1] == value) {
                    left--;//找到左边边界
                }
                return left;
            }
        }
        return -1;
    }
}
```
接下里面试官又说，你这时间复杂度分析一下，我看了看暂时不知道怎么说，然后面试官提醒说，你考虑下最差情况，中间重复的数字很多。（哦哦哦，我去，那岂不是就是遍历了，最差复杂度O(N)啊）。然后让我想想有没有复杂更低的方法。

## 第三阶段：二分查找返回target(可能有重复)第一次出现的下标(性能提升)

自己说实话觉得上一版已经没啥问题了，结果遇到这么一遭，后来硬着头皮又写了一版。

```java
public class BinarySearch {
    public int binarySearch(int[] array, int value) {
        if (array.length == 0) {
            return -1;
        }
        int left = 0;
        int right = array.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (array[mid] > value) {
                right = mid - 1;
            } else if (array[mid] < value) {
                left = mid + 1;
            } else {
                int newLeft = left;
                int newRight = mid;
                while(newLeft<=newRight){
                    int newMid = newLeft + (newRight-newLeft)/2;
                    if (array[newMid]==target){
                        return newMid;
                    }else{
                        right = mid - 1;
                    }
                }
                return left;
            }
        }
        return -1;
    }
}
```
写完我自己都觉得尴尬，面试官说思路不对，二分里面再来个二分并不能解决问题，同时代码还是写错了，当时自己慌的不行，看着这代码自己也觉得难堪。后来看我还是没啥思路，面试官就放弃了。之后面试官提示说在判断条件里稍微改改就行了，面试完后自己去网上查了下，最后发现的确是这样，附上代码。
```java
public class BinarySearch {
    public int binarySearchWithRepeat(int[] array, int value) {
        if (array.length == 0) {
            return -1;
        }
        int left = 0;
        int right = array.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (array[mid] < value) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        if (array[left] == value) {
            return left;
        }
        return -1;
    }
}
```
思想是当`array[mid] < value`时，说明在右边；但是如果`array[mid] >= value`就统一保持右边界为mid，因为不关心后面的target，只关心第一个target，用这种方式去向左逼近，直到left到达right，循环结束后将left的值与target比较，最终得到下标。

## 总结
这次面试暴露了之前写代码的几个问题：
1. 不主动思考，浅尝辄止；
2. 对于边界的掌控能力差；
3. 面试紧张，显得不自信；
4. 自我介绍时间短；
5. 项目介绍有点冗杂；