---
title: 每日一刷28
date: 2018-07-21 15:02:36
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Sort
---
今天做了一道二分查找的简单题，发现二分虽然原理简单，但是有不少坑，在此记录一下，先看题目：
## First Bad Version ##
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

**Example:**

```js
Given n = 5, and version = 4 is the first bad version.

call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true

Then 4 is the first bad version. 
```

```java
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int left = 1;
        int right = n;
        while(left<=right){
            //int mid = left + ((right - left) >> 1);//用移位的写法
            int mid = left + (right-left)/2;// 避免整数加法溢出
            //int mid = (left + right)/2;//可能有加法溢出风险
            
            if (isBadVersion(mid)){     
                right = mid - 1;
            }
            else{
                left = mid + 1;
            }
        }
        return left;
    }
}
```
题目思路简单，没什么好说的，就是二分，下面说说二分的陷阱有哪些。
- 第一点：上述代码的问题就出在int mid = (left + right)/2，这句可能导致整数溢出，此时该方法就会抛出数组越界的异常。这个是我遇到的第一个坑。
- 第二点：while循环里面为什么取等号？具体一点就是，如果令 high = n - 1 (n是数组长度)，则 while 的循环条件为 low <= high，从而更新右边界位置的时候为 high = mid - 1；而如果令 high = n，则 while 循环的循环条件为 left < right，从而更新右边界位置的时候为 high = mid。同时，mid 的计算不能写在循环外，否则无法得到更新。
- 第三点：JDK本身对于除2的运算都是以位运算>>1来代替的，是不是效果更好，查了网上的资料后发现的确效率更高。

总结一下，二分查找大的方面需要注意三点：
- mid 赋值问题，注意溢出情况。
- 判断 while 循环体是否终止的语句的编写
- 边界值 left, right 和区间值这三个地方要保持一致
- 位运算代替除法，效率更高
