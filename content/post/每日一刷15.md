---
title: 每日一刷15
date: 2018-07-08 19:16:28
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
今天这道比昨天的难了一点。
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
**Example 1:**
```js
Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1
```
**Example 2:**
```js
Input: coins = [2], amount = 3
Output: -1
```
```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        for (int i = 1; i <= amount; i++) {
            dp[i] = Integer.MAX_VALUE;//这个值在前后相减时不会出现
            for (int coin:coins){
                if (coin<=i && dp[i-coin] != Integer.MAX_VALUE){
                    dp[i] = Math.min(dp[i-coin]+1, dp[i]);
                }
            }
        }
        if (dp[amount] == Integer.MAX_VALUE){
            return -1;
        }
        else{
            return dp[amount];
        }
    }
}
```
~~还是动态规划题，难点在于要确保这个硬币的值可能很大，故在初始化的时候要选定合适的值，这边选择Integer.MAX_VALUE或者Integer.MAX_VALUE-1都行，因为硬币至少面额为1，所以其实选择Integer.MAX_VALUE-1最合适。~~

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        int max = amount+1;
        Arrays.fill(dp,max);
        dp[0] = 0;
        for (int coin:coins){
            for (int i = coin; i <= amount; i++) {
                dp[i] = Math.min(dp[i-coin]+1,dp[i]);
            }

        }
        return dp[amount]>amount?-1:dp[amount];

    }
}
```
做了coinchange2后，发现此类背包问题还是用coin循环在外，amount循环在内，不仅循环次数减少了，还避免了原有方案需要判断不能到达点的标记。总体代码精简而且效率提高。
教训：原来的思路要死需要打补丁，那想想能不能从全局上修改逻辑，使得不需要打补丁。
