---
title: 每日一刷16
date: 2018-07-09 20:59:48
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
非常经典的最长上升子序列的题目，现在做起来还是有点吃力的。之后还要再多看几次。
Given an unsorted array of integers, find the length of longest increasing subsequence.
**Example:**
```js
Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
```
**Note:**
There may be more than one LIS combination, it is only necessary for you to return the length.
Your algorithm should run in O(n2) complexity.
Follow up: Could you improve it to O(n log n) time complexity?
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        int[] tail = new int[len];
        int size = 0;
        for (int num:nums) {
            int i = 0,j = size;
            while(i!=j){
                int m = i + (j-i)/2;
                if (num>tail[m]){
                    i = m+1;
                }
                else{
                    j = m;
                }
            }
            tail[i] = num;
            if (size == i) size++;
        }
        return size;
    }
}
```
复杂度O(nlogn)就提示我们要一次循环加一次二分搜索了，问题是中间状态数据的保留，这边有两个：size表示现有最长的长度，当做返回的数据，另外一个是tail数组，表示的是现有最合适的子序列的数据。总体来说这道题有一定的难度，之后要再看看才行。
