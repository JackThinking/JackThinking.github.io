---
title: 每日一刷27
date: 2018-07-20 20:38:14
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Greedy
---
# Gas Station #
There are N gas stations along a circular route, where the amount of gas at station i is gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.
Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.

**Note:**

If there exists a solution, it is guaranteed to be unique.
Both input arrays are non-empty and have the same length.
Each element in the input arrays is a non-negative integer.

**Example 1:**

```js
Input: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]
Output: 3
```
Explanation:
> Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.

**Example 2:**

```js
Input: 
gas  = [2,3,4]
cost = [3,4,3]
Output: -1
```
> Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int sum_gas = 0;
        int sum_cost = 0;
        int n = gas.length;
        for (int i = 0; i < n; i++) {
            sum_gas = sum_gas + gas[i];
            sum_cost = sum_cost + cost[i];
        }
        if (sum_gas < sum_cost){
            return -1;
        }
        int start = 0;
        int curr = 0;
        for (int i = 0; i < n; i++) {
            int diff = gas[i] - cost[i];
            if (curr+diff>=0){
                curr = curr + diff;
            }
            else{
                curr = 0;
                start = i + 1;
            }
        }
        return start;
    }
}
```
贪心的题，总是容易陷入做dp的思路去，自己的总体思路是对的，先求差值diff，然后找差值数组里的最大子序列，但是这就变成了dp了，而且循环的部分不好处理，可能要多写一个循环，这道题简单点的话，就安排一次循环，然后检测diff+curr的值会不会小于0，小于就重置参数再来，但是你可能会有疑虑，这样不是不能循环检测了吗，由于这道题说如果可以就只有一种解法，所以这样子做没问题。纵使要顺时针，也能找到相应的数字。
