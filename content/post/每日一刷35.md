---
title: 每日一刷35
date: 2018-07-31 20:56:18
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
# Best Time to Buy and Sell Stock IV

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

**Note**:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

**Example** 1:
```js
Input: [2,4,1], k = 2
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.
```

**Example** 2:
```js
Input: [3,2,6,5,0,3], k = 2
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.
Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
```

```java
class Solution {
     public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        if (n<2){
            return 0;
        }

        if (k >= n/2){
            int maxtemp = 0;
            for (int i = 1; i < n; i++) {
                if (prices[i]>prices[i-1]){
                    maxtemp += prices[i]-prices[i-1];
                }
            }
            return maxtemp;
        }
        int[][] dp = new int[k+1][n];
        for (int i = 1; i <= k; i++) {
            int localmax = dp[i-1][0]-prices[0];
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.max(dp[i][j-1],prices[j]+localmax);
                localmax = Math.max(localmax,dp[i-1][j]-prices[j]);
            }
        }
        return dp[k][n-1];
    }
}
```
这道题算是股票问题的最终形态了，从单次最大利益，到不限次数的最大利益到，到带冷却的最大利益，到两次交易的最大利益，到k次交易的最大利益，但是问题的本质没变，都是dp问题，变的是转移方程。越到后面，转移方程的形式越复杂。
这次这道题需要用到dp[k][n]的二维数组才行，这点我居然没有想到；还有就是状态转移方程，其结构和硬币问题很像（现在的状态要嘛和之前的一样，要嘛就是卖了这个价加上之前的dp值，看谁大，当然其满足子问题重叠性和最优子结构这两大基本要求）
还有点就是看到了状态转移方程的比较容易的写法，看到写法后能比较快的找到几个max的拆分点。这个问题之前一直无法解决。明天再看看一道max个数多的dp题目。
