---
title: 每日一刷13
date: 2018-07-06 20:44:02
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
不管了，先做一波动态规划的题练练思路。
## Jump Game
Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.
**Example 1:**
```js
Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
```
**Example 2:**
```js
Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
jump length is 0, which makes it impossible to reach the last index.
```

```java
public class Solution {
    public boolean canJump(int[] nums) {
        int curr = nums.length;
        for (int i = curr-2; i >= 0; i--) {
            if (nums[i] == 0){
                int jump = 1;
                while(nums[i] < jump){
                    i--;
                    jump++;
                    if(i<0){
                        return false;
                    }
                }
            }

        }
        return true;
    }
}
```
借鉴了大神的思想，反向思维，如果过不了，问题一定是出在有个位置是0，而且0之前的数字都跳不过0的位置，由于第一只值不为0，那么遍历nums.length-2个即可，再次基础上进行反向推导，判断之前的nums[]能不能跳过step步数。
这道题的这个解法是启发了我，那就算“反过来推导”：对于许多题目而言，其要求的结论本身就隐藏了推论，不管这个推论是充分的还是必要的，都很可能对解题有帮助。
