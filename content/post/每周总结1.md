---
title: 每周总结1
date: 2018-10-14 15:15:09
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Treenode
---
之前的每日算法更新结束，文章多了后，hexo编译好慢，而且每天写的话有点浪费时间，算法题还是每天在做，之后改成总结更新类的方式。

# TreeNode-easy系列题
1. Maximum Depth of Binary Tree（树的深度）
2. Validate Binary Search Tree（二叉搜索树的判定）
3. Symmetric Tree（对称树-学到了helper的双遍历）
4. Binary Tree Level Order Traversal（根据树的深度来找同一层的点，helper函数需要加入level属性）
5. Convert Sorted Array to Binary Search Tree（有序数组变成二叉搜索树-中序遍历的特点-需要在helper函数里面不断的找中点，然后左右递归，边界条件要注意）

# TreeNode-middle系列题
1. Binary Tree Inorder Traversal（树的中序遍历）
2. Binary Tree Zigzag Level Order Traversal（Z形level遍历，在原有easy的基础上对add函数做一下小处理，在末端加入，有点trick的感觉）
3. Construct Binary Tree from Preorder and Inorder Traversal（根据先序中序遍历结果进行重新排列，有点难度，搞清楚就是先序的节点作为中序数组的分界点）
4. Populating Next Right Pointers in Each Node（给树增加右向指针，可以好好理解BFS和DFS的区别）
5. Kth Smallest Element in a BST（根据二叉搜索树的特点统计每个节点左右两边的节点个数，依据个数来找出index的node）
6. Number of I slands（可以说是比较经典的二维图遍历了，用dfs的思路进行遍历，找到后变0，这样之后再遇到就不会对下一个图产生误导了）

# TreeNode-hard系列题
1. Word Ladder（很难，从首到尾BFS将相差1个字的单词从原有数组去掉，加入到该level的数组中）
2. Surrounded Regions（二维数组，去掉被包围的点，这道题是逆向思维，从4条边缘进行dfs,将遇到的点给值，然后再遍历的时候，如果没有被给值就直接变成X）
3. Lowest Common Ancestor of a Binary Tree（这道题还是要在看一下YouTube视频理解一下，是一道经典题）
4. Binary Tree Maximum Path Sum（二叉树上的最大路径，基于DFS，需要识别负数，return的时候有点技巧）
5. Friend Circles（朋友圈，也是用dfs，不过要理解visited的含义）
6. Course Schedule（拓扑搜索，用一个set和dp的数组来解决）
7. Course Schedule II（用一个stack和一个set可以解决）
8. Longest Increasing Path in a Matrix（二维数据的找最大上升序列，需要一个visited数组作数据记录）
9. Alien Dictionary
10. Count of Smaller Numbers After Self（其实这道题换个角度理解就是一个个进行二分插入，统计插入位置的index，进index进行记录）