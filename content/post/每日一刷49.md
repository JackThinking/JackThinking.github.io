---
title: 每日一刷49
date: 2018-08-17 13:26:20
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
## 213. House Robber II

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

**Example 1**:

```js
Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),because they are adjacent houses.
```

```java
public class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 0){
            return 0;
        }

        if (len < 2){
            return nums[0];
        }

        int dp1[] = new int[len+1];
        int dp2[] = new int[len+1];
        dp1[0] = 0;
        dp1[1] = nums[0];
        dp2[0] = 0;
        dp2[1] = 0;

        for (int i = 2; i <= len; i++) {
            dp1[i] = Math.max(dp1[i-1],dp1[i-2]+nums[i-1]);//最后一位取不到
            dp2[i] = Math.max(dp2[i-1],dp2[i-2]+nums[i-1]);//第一位取不到
        }

        return Math.max(dp1[len-1],dp2[len]);
    }
}
```

抢劫邻居题2：
- 最简单的状态转移方程，容易一口气写出
- 这道题难在成环
- 解决方法是设置两个dp,判断是要第一个数据还是最后一个数据（没有想到）
- 涉及到i-2,i-1,i的问题，可以设置两个标志位来取代dp数组，分别是循环里的tmp和循坏外的dp2，改造后代码如下：

```java
public class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 0){
            return 0;
        }

        if (len < 2){
            return nums[0];
        }
        int dp1 = 0,dp2 = 0,dp3 = 0,dp4 = 0;
        for (int i = 2; i < len; i++) {
            int tmp1 = Math.max(dp1,dp2+nums[i]);
            int tmp2 = Math.max(dp3,dp4+nums[i]);
            dp2 = dp1;
            dp1 = tmp1;
            dp4 = dp3;
            dp3 = tmp2;
        }
        return Math.max(dp1,dp3);
    }
}
```
