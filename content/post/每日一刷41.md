---
title: 每日一刷41
date: 2018-08-14 14:35:31
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
## 32. Longest Valid Parentheses

Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

**Example 1**:
```js
Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"

```
**Example 2**:
```js
Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```

```java
class Solution {
    public int longestValidParentheses(String s) {
        int maxVal = 0;
        int len = s.length();
        int[] dp = new int[len];
        for (int i = 1; i < len; i++) {
             if (s.charAt(i) == ')'){
                 if (s.charAt(i-1) == '('){
                     dp[i] = ((i>=2)?dp[i-2]:0)+2;
                 }
                 else{
                     if (i - dp[i - 1] - 1 >= 0 && s.charAt(i-1-dp[i-1]) == '(' ){
                         dp[i] = dp[i-1]+((i - dp[i - 1] - 2) >= 0 ? dp[i - dp[i - 1] - 2] : 0)+2;//陷阱
                     }
                 }
             }
            maxVal = Math.max(maxVal,dp[i]);
        }
        return maxVal;
    }
}
```
括号匹配类型题，这道题目而言是典型的动态规划题，解法为自底向上，核心在于状态转移方程的建立，首先是找到一对()匹配对，然后分成两种情况，一种是简单的叠加，另外一种比较复杂，要考虑到大范围括号的计算。摘抄公式如下：
```js
For s[i], 
if s[i] is '(', dp[i] will be 0.
else, 
  dp[i] will be dp[i - 2] + 2 when s[i - 1] = '('
	i.e. ...()
	         i
  dp[i] will be dp[i - 1] + dp[i - dp[i - 1] - 2]+ 2 when s[i-1] = ')' && s[i - dp[i - 1] - 1] = '('
	i.e. ...))
	         i
	e.g.  ()(() )      j = i - dp[i - 1] - 1
                j   i 

We keep track of the maximum dp[i] on the fly.
```
