---
title: 每日一刷37
date: 2018-08-03 10:53:33
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
# Coin Change 2

You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.

**Note**: You can assume that

* 0 <= amount <= 5000
* 1 <= coin <= 5000
* the number of coins is less than 500
* the answer is guaranteed to fit into signed 32-bit integer
 
**Example 1**:
```js
Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1**Example 1**
5=2+1+1+1
5=1+1+1+1+1
``` 
**Example 2**:
```js
Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
``` 
**Example 3**:
```js
Input: amount = 10, coins = [10] 
Output: 1
```

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount+1];
        dp[0] = 1;
        for (int coin:coins){
           for (int i = coin; i <= amount; i++) {
               dp[i] += dp[i-coin];
            }

        }
        if (dp[amount] == 0){
            return 0;
        }
        else{
            return dp[amount];
        }
    }
}
```
这道题可以说是和硬币题的第一题是很经典的背包问题了，之前的要求是用最少的硬币找到目标金额的值，这道题是用尽量多的方法找到目标金额的值，讲道理难度差不多，不过又没有做出来，后来翻了答案，发现把两个循环的顺序反一下就可以了，而且还避免了设置标志位的麻烦，总之，这道题非常经典，之后的笔试题很有可能会考的。
