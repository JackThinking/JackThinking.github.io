---
title: 每日一刷24
date: 2018-07-17 15:12:04
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
# Maximum Length of Repeated Subarray #
Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.
**Example 1:**
```js
Input:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
Output: 3
```
Explanation: 
The repeated subarray with maximum length is [3, 2, 1].
Note:
1. 1<= len(A), len(B) <= 1000
2. 0<= A[i], B[i] < 100

```java
public class Solution {
    public int findLength(int[] A, int[] B) {
        int max = 0;
        int m = A.length;
        int n = B.length;
        int dp[] = new int[m+1];
        for (int i = 0; i < m; i++) {
            for (int j = n; j >= 1; j--) {
                if (A[i] == B[j-1]){
                    dp[j] = dp[j-1] +1;
                    max = Math.max(max,dp[j]);
                }
                else{
                    dp[j]  = 0;
                }
            }
        }
        return max;
    }
}
```
这道题难得不是逻辑，难得是把第二个for循环倒过来减少了复杂度，一般的想法是用m*n的存储复杂度，单实际上光m或者n就可以了，二维数组可以保持详细的信息，但是如果不涉及其他操作的话可以不要，最大值的数据还是存在着的。这里详细的解释如下：
```java
public int findLength(int[] A, int[] B) {
    int n = A.length, m = B.length, max = 0;
    int[][] dp = new int[n+1][m+1];
    for(int i = 1; i <= n; i++)
        for(int j = 1; j<= m; j++) {
            if (A[i-1] == B[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
                max = Math.max(max, dp[i][j]);
            }
        }
    return max;
}
```
If you look at the only line that updates/changes array dp's value:
dp[i][j] = dp[i-1][j-1] + 1;
The value of dp[i][j] depends only on the value of dp[i-1][j-1]. If we replace the 2D array with 1D array, dp[j-1] should hold the value of dp[i-1][j-1] in the 2D version. If we loop from 1 -> m, we calculate dp[j-1] before dp[j], dp[j-1] is actually the value of dp[i][j-1] in the 2D version. if we do dp[j] = dp[j-1] + 1, it is actually dp[i][j] = dp[i][j-1] + 1, not dp[i][j] = dp[i-1][j-1] + 1 in the 2D version. But if we loop backwards, that is from m -> 1, dp[j] is calculated before dp[j-1] which still holds the value of dp[i-1][j-1] in the 2D version. After dp[j] is calculated, we don't need dp[i-1][j-1] any more. It can be used to calculate value of dp[i][j-1].

Another note is, you must set dp[j] = 0 if A[i-1] != B[j-1]. Because, remember we reuse dp[j] to hold the value of dp[i][j]. If it is not reset, it still holds the value of dp[i-1][j] which may not be zero.

Hope that will help.

- tips:要是见到dp[i][j] = dp[i-1][j-1] + 1;就有机会缩减空间复杂度
