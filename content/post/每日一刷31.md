---
title: 每日一刷31
date: 2018-07-24 21:34:24
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Sort
---
# Top K Frequent Elements

Given a non-empty array of integers, return the k most frequent elements.

```js
For example,
Given [1,1,1,2,2,3] and k = 2, return [1,2].
```

**Note**: 
You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
Your algorithm's time complexity must be better than O(n log n), where n is the array's size.

```java
class Solution {
    public List<Integer> topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> table = new HashMap<>();
        List<Integer>[] bukcet = new List[nums.length+1];
        for(int n: nums){
            table.put(n,table.getOrDefault(n,0)+1);
        }
        for(int key: table.keySet()){
            int fqc = table.get(key);
            if (bukcet[fqc] == null){
                bukcet[fqc] = new ArrayList<>();
            }
            bukcet[fqc].add(key);
        }

        List<Integer> res = new ArrayList<>();
        for (int i = nums.length; i >= 0 && res.size()<k; i--) {
           if (bukcet[i]!=null){
               res.addAll(bukcet[i]);
           }
        }
        return res;
    }
}
```

这道题是参考了别人的解法的。看上去复杂度像是O(n)，但是由于使用了HashMap，其实在操作的时候复杂度是大于O(n)的（之后好好研究一下HashMap的复杂度），其次这个桶排序和我在书中看到的桶排序有着一定的出入，不能算正宗的桶排序。

此处引用一段别人的评论：

> This is not a normal bucket sort. Normally you will sort inside the buckets when you have bucketed, but in this case the sort is unnecessary since all elements inside the single bucket have the same value (same frequency). Therefore you can simply iterate from the highest frequency to the lowest frequency. You can do this in linear time since you know the frequency for any element must be <= n.

As I mentioned in another comment. There is degenerate input for this solution and every other solution which depends on hash maps. The frequencyMap hash map can degenerate to O(n) lookup (making his first loop O(n^2)) if the input causes your hash function to map to the same slot (large amount of collisions). I think in an interview you want to discuss ways to avoid this, e.g. randomly pick from a set of hash functions
