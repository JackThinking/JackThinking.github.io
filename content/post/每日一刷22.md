---
title: 每日一刷22
date: 2018-07-15 15:23:11
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
# Best Time to Buy and Sell Stock with Cooldown #
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
**Example:**
```js
Input: [1,2,3,0,2]
Output: 3 
Explanation: transactions = [buy, sell, cooldown, buy, sell]
```
```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int max = 0, n = prices.length;
        int[] sell = new int[n];
        int[] cooldown = new int[n];
        for (int i = 1; i < n; i++) {
            cooldown[i] = Math.max(cooldown[i - 1], sell[i - 1]);
            for (int j = 0; j < i; j++) {
                if (j == 0) sell[i] = Math.max(sell[i], prices[i] - prices[j]);
                else sell[i] = Math.max(sell[i], cooldown[j - 1] + prices[i] - prices[j]);
            }
            max = Math.max(max, cooldown[i]);
            max = Math.max(max, sell[i]);
        }
        return max;
    }
}
```
```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int max = 0, n = prices.length;
        int[] sell = new int[n];
        int[] cooldown = new int[n];
        int diff = -prices[0];
        for (int i = 1; i < n; i++) {
            cooldown[i] = Math.max(cooldown[i - 1], sell[i - 1]);
            sell[i] = Math.max(sell[i], prices[i] + diff);
            diff = Math.max(diff, cooldown[i - 1] - prices[i]);
            max = Math.max(max, cooldown[i]);
            max = Math.max(max, sell[i]);
        }
        return max;
    }
}
```
```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int max = 0, n = prices.length;
        int cooldown = 0;
        int sell = 0;
        int diff = -prices[0];
        for (int i = 1; i < n; i++) {
            int temp = cooldown;
            cooldown = Math.max(temp,sell);
            sell = Math.max(sell,prices[i] + diff);
            diff = Math.max(diff, temp - prices[i]);
            max = Math.max(max,cooldown);
            max = Math.max(max,sell);

        }
        return max;
    }
}
```
之前总结出的动态规划转移方程的两点:
1. 走棋盘（之前2次状态的相加）
2. 硬币加一（之前的状态加1比较）
这次出的这道自己又没有做出来，是状态间max比较的，我称之为max型，参考了一个很好的解法，一步步写了3个解法，最后击败了100%是的全球用户。
## 解法一 ##
第一个程序最好理解，维护了sell[]和cooldown[]两个数组，不需要buy[]数组，因为最后肯定是要卖掉的。
- 转移方程1：cooldown[i] = Math.max(cooldown[i - 1], sell[i - 1])
- 转移方程2：sell[i] = Math.max(sell[i], cooldown[j - 1] + prices[i] - prices[j]);
## 解法二 ##
解法二在一的基础上去掉了第二个for循环，因为第二个for循环找的是cooldown[j - 1] - prices[j]，这个式子可以单独提出来，在第一个循环里面找，还有就是对于特殊情况从头找起的设置，即初始化diff为-prices[0]。
## 解法三 ##
在解法二的基础上还可以再优化，因为用到的比较的变量只涉及cooldown的i与i-1前后，而sell更是只有自身的大小比较，故去掉sell的数组。cooldown也可以去掉数组，只留下一个变量，在循环中加一个临时变量temp可以解决前后比较的问题。
- tips:若是涉及到i和i-1和i-2的话，用pre和curr两个变量即可（），因为等号前后的变量本省就代表了i和i-1的状态
```java
money[i] = Math.max(nums[i]+money[i-2],money[i-1]);

int tmp = curr;
curr = Math.max(prev + n, curr);
prev = tmp;
```
