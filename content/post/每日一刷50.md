---
title: 每日一刷50
date: 2018-08-18 19:10:33
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Sort
---
## 287. Find the Duplicate Number
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.

**Example 1**:
```js
Input: [1,3,4,2,2]
Output: 2
```
**Example 2**:
```js
Input: [3,1,3,4,2]
Output: 3
```
**Note:**
* You must not modify the array (assume the array is read only).
* You must use only constant, O(1) extra space.
* Your runtime complexity should be less than O(n2).
* There is only one duplicate number in the array, but it could be repeated more than once.

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int left = 1,right = nums.length-1;
        while(left<=right){
            int mid = left + (right-left)/2;
            int count = 0;
            for (int i = 0; i < nums.length; i++) {
                if (nums[i]<=mid){
                    count++;
                }
            }
            if (count>mid){
                right = mid - 1;
            }
            else{
                left = mid+1;
            }
        }
        return left;
    }
}
```
这道题的条件其实隐约告诉我们可以用O(NlogN)的做法来做：
- O(NlogN)隐含：循环+二分
- 空间复杂度限制我们不能用数组
- 自己第一次没做出来，看答案理解了很久
- 可以理解mid含义为左边不大于mid的不重复的最大值{1，2，3，4，5}，比3小的不重复的话count为3；要是count大于mid，说明mid之前的数字大小（注意不是数组里的值）肯定有重复的，进而进行二分
- left从一开始还不理解
- 这道题还有O(N)的解法，用链的思路去做（TODO）
