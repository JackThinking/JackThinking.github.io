---
title: 每日一刷44
date: 2018-08-15 16:33:59
categories: 
    - 算法
tags:
    - java
    - leetcode
    - Dynamic Programming
---
## 64. Minimum Path Sum

Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

**Example**:

```js
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
```

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;
        int dp[][] = new int[row][col];
        dp[0][0] = grid[0][0];

        if (row == 1){
            int temp = 0;
            for (int i = 0; i < col; i++) {
                temp += grid[0][i];
            }
            return temp;
        }

        if (col == 1){
            int temp = 0;
            for (int i = 0; i < row; i++) {
                temp += grid[i][0];
            }
            return temp;
        }
        
        for (int i = 1; i < row; i++) {
            dp[i][0] = dp[i-1][0]+grid[i][0];
            for (int j = 1; j < col; j++) {
                dp[0][j] = dp[0][j-1]+grid[0][j];
                dp[i][j] = Math.min(dp[i-1][j]+grid[i][j],dp[i][j-1]+grid[i][j]);
            }
        }
        return dp[row-1][col-1];
    }
}
```
解法一：
- 自底向上
- 二维数组dp(可以优化)
- 棋盘问题

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;
        int[][] memo = new int[row][col];//备忘录
        return helper(grid,memo,row-1,col-1); //顶部开始
    }
    
    public int helper(int[][] grid, int[][] memo, int x, int y){
        //结束条件
        if (x==0 && y==0){
            return grid[0][0];
        }
        //剪枝条件
        if (memo[x][y] != 0){
            return memo[x][y];
        }
        //一般处理条件
        int left = Integer.MAX_VALUE;
        int up = Integer.MAX_VALUE;
        if (y>0){
            up = helper(grid,memo,x,y-1);
        }
        if (x>0){
            left = helper(grid,memo,x-1,y);
        }
        //核心转移方程
        int dist = grid[x][y]+Math.min(left,up);
        //备忘录记录
        memo[x][y] = dist;
        return dist;
    }
}
```
解法二：
- 带备忘录自顶向下
- 带剪枝
- helper函数的状态量确定（不熟练）
- 回溯写法不熟练
